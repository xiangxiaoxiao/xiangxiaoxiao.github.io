<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>话唠先生</title>
 <link href="http://http://coolshell.info/atom.xml" rel="self"/>
 <link href="http://http://coolshell.info"/>
 <updated>2016-07-28T14:04:16+00:00</updated>
 <author>
   <name>Li Ming</name>
   <email>362471259@qq.com</email>
 </author>

 
 <entry>
   <title>Git操作手册|命令速查表</title>
   <link href="http://http://coolshell.info/blog/2016/02/git-guide.html"/>
   <updated>2016-02-20T00:00:00+00:00</updated>
   <id>/blog/2016/02/git-guide</id>
   <content type="html">&lt;p&gt;这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。
本文分为以下几个部分：
1. Git与SVN差异
2. Git常用命令
3. Git进阶指南&lt;/p&gt;

&lt;p&gt;##Git与SVN差异&lt;/p&gt;

&lt;p&gt;Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的,Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快,它已经是现在的主流。&lt;/p&gt;

&lt;p&gt;Git 和 SVN 思想最大的差别有四个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;去中心化&lt;/li&gt;
  &lt;li&gt;直接记录快照，而非差异&lt;/li&gt;
  &lt;li&gt;不一样的分支概念&lt;/li&gt;
  &lt;li&gt;三个文件状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;去中心化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Git是一个DVCS（分布式版本管理系统），在技术层面上并不存在一个像中心仓库这样的东西 ， 所有的数据都在本地，不存在谁是中心&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/git.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中每个开发者拉取(pull)并推送(push)到origin。但除了这种集中式的推送拉取关系，每个开发者也可能会从其他的开发者处拉取代码的变更，从技术上讲，这意味着Alice定义了一个名为bob的Git的remote，它指向了Bob的软件仓库。反之亦然。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;直接记录快照，而非差异&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Git每一个版本都是直接记录快照，而非文件的差异。 下面两个对比图在网上是广为流传大家应该熟悉：&lt;/p&gt;

&lt;p&gt;SVN：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/svn.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/gitgit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git使用SHA-1算法计算数据的校验和，通过文件的内容或目录计算出SHA-1哈希值，作为指纹字符串，每个Version 都是一个快照。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不一样的分支概念&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Git的分支本质是一个指向提交快照的指针，是从某个提交快照往回看的历史。当创建/切换分支的时候，只是变换了指针指向而已.而SVN创建一个分支， 是的的确确的复制了一份文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三个文件状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Git中文件有三种状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;已提交（committed）：该文件被安全地保存在了本地数据库&lt;/li&gt;
  &lt;li&gt;已修改（modified）：修改了某个文件，但还没有保存&lt;/li&gt;
  &lt;li&gt;已暂存（staged）：把已修改的文件放下下次保存的清单中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Git常用命令&lt;/p&gt;

&lt;p&gt;###创建&lt;/p&gt;

&lt;p&gt;复制一个已创建的仓库:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone ssh://user@domain.com/repo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建一个新的本地仓库:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###本地修改&lt;/p&gt;

&lt;p&gt;显示工作路径下已修改的文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示与上次提交版本文件的不同：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git diff
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把当前所有修改添加到下次提交中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把对某个文件的修改添加到下次提交中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add -p &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;提交本地的所有修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit -a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;提交之前已标记的变化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;附加消息提交：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit -m &#39;message here&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;提交，并将提交时间设置为之前的某个日期:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit --date=&quot;`date --date=&#39;n day ago&#39;`&quot; -am &quot;Commit Message&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###修改上次提交&lt;/p&gt;

&lt;p&gt;请勿修改已发布的提交记录!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把当前分支中未提交的修改移动到其他分支&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git stash
git checkout branch2
git stash pop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###搜索&lt;/p&gt;

&lt;p&gt;从当前目录的所有文件中查找文本内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git grep &quot;Hello&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在某一版本中搜索文本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git grep &quot;Hello&quot; v2.5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###提交历史&lt;/p&gt;

&lt;p&gt;从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示所有提交（仅显示提交的hash和message）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log --oneline
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示某个用户的所有提交：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log --author=&quot;username&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示某个文件的所有修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log -p &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;谁，在什么时间，修改了文件的什么内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git blame &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###分支与标签&lt;/p&gt;

&lt;p&gt;列出所有的分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git branch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;切换分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git checkout &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建并切换到新分支:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git checkout -b &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基于当前分支创建新分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git branch &amp;lt;new-branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基于远程分支创建新的可追溯的分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git branch --track &amp;lt;new-branch&amp;gt; &amp;lt;remote-branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;删除本地分支:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git branch -d &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;给当前版本打标签：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git tag &amp;lt;tag-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###更新与发布&lt;/p&gt;

&lt;p&gt;列出当前配置的远程端：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示远程端的信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote show &amp;lt;remote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加新的远程端：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote add &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下载远程端版本，但不合并到HEAD中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git fetch &amp;lt;remote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下载远程端版本，并自动与HEAD版本合并：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote pull &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将远程端版本合并到本地版本中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git pull origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将本地版本发布到远程端：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push remote &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;删除远程端分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push &amp;lt;remote&amp;gt; :&amp;lt;branch&amp;gt; (since Git v1.5.0)
或
git push &amp;lt;remote&amp;gt; --delete &amp;lt;branch&amp;gt; (since Git v1.7.0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发布标签:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###合并与重置&lt;/p&gt;

&lt;p&gt;将分支合并到当前HEAD中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git merge &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将当前HEAD版本重置到分支中:
请勿重置已发布的提交!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;退出重置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase --abort
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解决冲突后继续重置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase --continue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用配置好的merge tool 解决冲突：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git mergetool
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在编辑器中手动解决冲突后，标记文件为已解决冲突&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add &amp;lt;resolved-file&amp;gt;
$ git rm &amp;lt;resolved-file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###撤销&lt;/p&gt;

&lt;p&gt;放弃工作目录下的所有修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset --hard HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;移除缓存区的所有文件（i.e. 撤销上次git add）:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;放弃某个文件的所有本地修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git checkout HEAD &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重置一个提交（通过创建一个截然不同的新提交）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git revert &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset --hard &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将HEAD重置到上一次提交的版本，并保留未提交的本地修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset --keep &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##Git进阶指南&lt;/p&gt;

&lt;p&gt;###问：如何修改 origin 仓库信息？&lt;/p&gt;

&lt;p&gt;####1、添加 origin 仓库信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git remote add origin &amp;lt;git仓库地址&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####2、查看 origin 仓库信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 以下三种方式均可
git config get --remote.origin.url
git remote -v
git remote show origin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####3、删除 origin 仓库信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git remote rm origin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###问：如何配置 git ssh keys ？&lt;/p&gt;

&lt;p&gt;在本地生成 ssh 私钥 / 公钥 文件
将「公钥」添加到 git 服务（github、gitlab、coding.net 等）网站后台
测试 git ssh 连接是否成功
接下来以添加 github ssh keys 为例，请注意替换 github 文件名。&lt;/p&gt;

&lt;p&gt;注：如果对密钥机制不熟悉，建议不要指定 -f 参数，直接使用默认的 id_rsa 文件名。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 运行以下命令，一直回车，文件名可随意指定
ssh-keygen -t rsa -b 4096 -C &quot;kaiye@macbook&quot; -f ~/.ssh/github

# 如果不是默认密钥 id_rsa ，则需要以下命令注册密钥文件，-K 参数将密钥存入 Mac Keychain
ssh-add -K ~/.ssh/github

# 将 pub 公钥的内容粘贴到线上网站的后台
cat ~/.ssh/github.pub

# 测试 git ssh 是否连接成功
ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###问：如何撤销修改？&lt;/p&gt;

&lt;p&gt;修改包含四种情况，需单独区分。&lt;/p&gt;

&lt;p&gt;####1、新建的文件和目录，且从未提交至版本库&lt;/p&gt;

&lt;p&gt;此类文件的状态为 Untracked files ，撤销方法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clean -fd .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，. 表示当前目录及所有子目录中的文件，也可以直接指定对应的文件路径，以下其他情况类似。&lt;/p&gt;

&lt;p&gt;####2、提交过版本库，但未提交至暂存区的文件（未执行 git add）&lt;/p&gt;

&lt;p&gt;此类文件的状态为&lt;code class=&quot;highlighter-rouge&quot;&gt; Changes not staged for commit&lt;/code&gt;，撤销方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git checkout .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####3、已提交至暂存区的文件&lt;/p&gt;

&lt;p&gt;此类文件的状态为 Changes to be committed，撤销方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git reset .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行之后文件将会回到以上的 1 或者 2 状态，可继续按以上步骤执行撤销，若 git reset 同时加上 –hard 参数，将会把修改过的文件也还原成版本库中的版本。&lt;/p&gt;

&lt;p&gt;####4、已提交至版本库（执行了 git commit）&lt;/p&gt;

&lt;p&gt;每次提交都会生成一个 hash 版本号，通过以下命令可查阅版本号并将其回滚：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log
git reset &amp;lt;版本号&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果需要「回滚至上一次提交」，可直接使用以下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git reset head~1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行之后，再按照 1 或者 2 状态进行处理即可，如果回滚之后的代码同时需要提交至 origin 仓库（即回滚 origin 线上仓库的代码），需要使用 -f 强制提交参数，且当前用户需要具备「强制提交的权限」。&lt;/p&gt;

&lt;p&gt;####5、如果回滚了之后又不想回滚了怎么办？&lt;/p&gt;

&lt;p&gt;如果是以上的情况 1 或者 2，只能歇屁了，因为修改没入过版本库，无法回滚。&lt;/p&gt;

&lt;p&gt;如果是情况 4，回滚之后通过 git log 将看不到回滚之前的版本号，但可通过 git reflog 命令（所有使用过的版本号）找到回滚之前的版本号，然后 git reset &lt;版本号&gt; 。&lt;/版本号&gt;&lt;/p&gt;

&lt;p&gt;###问：遇到冲突了怎么解决？&lt;/p&gt;

&lt;p&gt;两个分支进行合并时（通常是 git pull 时），可能会遇到冲突，同时被修改的文件会进入 Unmerged 状态，需要解决冲突。&lt;/p&gt;

&lt;p&gt;####1、最快的办法&lt;/p&gt;

&lt;p&gt;大部分时候，「最快解决冲突」的办法是：使用当前 HEAD 的版本（ours），或使用合并进来的分支版本（theirs）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 使用当前分支 HEAD 版本，通常是冲突源文件的 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; 标记部分，======= 的上方
git checkout --ours &amp;lt;文件名&amp;gt;

 # 使用合并分支版本，通常是源冲突文件的 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 标记部分
 git checkout --theirs &amp;lt;文件名&amp;gt;

# 标记为解决状态加入暂存区
git add &amp;lt;文件名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####2、最通用的办法&lt;/p&gt;

&lt;p&gt;用编辑器打开冲突的源文件进行修改，可能会发生遗留，且体验不好，通常需要借助 git mergetool 命令。&lt;/p&gt;

&lt;p&gt;在 Mac 系统下，运行 git mergetool &lt;文件名&gt; 可以开启配置的第三方工具进行 merge，默认的是 FileMerge 应用程序，还可以配置成 Meld 或 kdiff3，体验更佳。&lt;/文件名&gt;&lt;/p&gt;

&lt;p&gt;####3、最好的习惯&lt;/p&gt;

&lt;p&gt;有三个好的习惯，可以减少代码的冲突：
 在开始修改代码前先 git pull 一下；
  将业务代码进行划分，尽量不要多个人在同一时间段修改同一文件；
  通过Gitflow 工作流也可以提升 git流程效率，减少发生冲突的可能性。&lt;/p&gt;

&lt;p&gt;####4、最复杂的情况&lt;/p&gt;

&lt;p&gt;如果你的项目周期比较长，还应该养成「定期 rebase 的习惯」，git pull –rebase 可以让分支的代码和 origin 仓库的代码保持兼容，同时还不会破坏线上代码的可靠性。&lt;/p&gt;

&lt;p&gt;它的大概原理是，先将 origin 仓库的代码按 origin 的时间流在本地分支中提交，再将本地分支的修改记录追加到 origin 分支上。如果发生冲突，则可以即时的发现问题并解决，否则到项目上线时再解决冲突，可能会发生额外的风险。&lt;/p&gt;

&lt;p&gt;rebase 大概的操作步骤如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 将当前分支的版本追加到从远程 pull 回来的节点之后
git pull --rebase

# 若发生冲突，则按以上其他方法进行解决，解决后继续
git rebase --continue

# 直到所有冲突得以解决，待项目最后上线前再执行
git push origin

# 若多次提交修改了同一文件，可能需要直接跳过后续提交，按提示操作即可
git rebase --skip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###问：如何在不提交修改的前提下，执行 pull / merge 等操作？&lt;/p&gt;

&lt;p&gt;有些修改没有完全完成之前，可能不需要提交到版本库，圡方法是将修改的文件 copy 到 git 仓库之外的目录临时存放，pull / merge 操作完成之后，再 copy 回来。&lt;/p&gt;

&lt;p&gt;这样的做法一个是效率不高，另外一个可能会遗漏潜在的冲突。此类需求最好是通过 git stash 命令来完成，它可以将当前工作状态（WIP，work in progress）临时存放在 stash 队列中，待操作完成后再从 stash 队列中重新应用这些修改。&lt;/p&gt;

&lt;p&gt;以下是 git stash 常用命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查看 stash 队列中已暂存了多少 WIP
git stash list

# 恢复上一次的 WIP 状态，并从队列中移除
git stash pop

# 添加当前 WIP，注意：未提交到版本库的文件会自动忽略，只要不运行 git clean -fd . 就不会丢失
git stash

# 恢复指定编号的 WIP，同时从队列中移除
git stash pop stash@{num}

# 恢复指定编号的 WIP，但不从队列中移除
git stash apply stash@{num}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###问：如何在 git log 中查看修改的文件列表？&lt;/p&gt;

&lt;p&gt;默认的 git log 会显示较全的信息，且不包含文件列表。使用 –name-status 可以看到修改的文件列表，使用 –oneline 可以将参数简化成一行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log --name-status --oneline
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每次手动加上参数很麻烦，可以通过自定义快捷命令的方式来简化操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config --global alias.ls &#39;log --name-status --oneline --graph&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行以上配置后，可通过 git ls 命令来实现「自定义 git log」效果，通过该方法也可以创建 git st 、 git ci 等一系列命令，以便沿用 svn 命令行习惯。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config --global alias.st &#39;status --porcelain&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更多 git log 参数，可通过 git help log 查看手册。&lt;/p&gt;

&lt;p&gt;如果是看上一次提交的版本日志，直接运行 git show 即可。&lt;/p&gt;

&lt;p&gt;此外，如果你的 Mac 安装了zsh（参考《全新Mac安装指南（编程篇），那么可以直接使用 gst、glog 等一系列快捷命令，详情见此列表：Plugin:git 。&lt;/p&gt;

&lt;p&gt;###问：git submodule update 时出错怎么解决？&lt;/p&gt;

&lt;p&gt;例如，在执行 git submodule update 时有以下错误信息：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;fatal: reference is not a tree: f869da471c5d8a185cd110bbe4842d6757b002f5
Unable to checkout ‘f869da471c5d8a185cd110bbe4842d6757b002f5’ in submodule path ‘source/i18n-php-server’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在此例中，发生以上错误是因为 i18n-php-server 子仓库在某电脑 A 的「本地」commit 了新的版本 「f869da471c5d8a185cd110bbe4842d6757b002f5」，且该次 commit 未 push origin。但其父级仓库 i18n-www 中引用了该子仓库的版本号，且将引用记录 push origin，导致其他客户机无法 update 。&lt;/p&gt;

&lt;p&gt;解决方法，在电脑 A 上将 i18n-php-server 版本库 push origin 后，在其他客户机上执行 git submodule update 。或者用以上提到的 git reset 方法，将子仓库的引用版本号还原成 origin 上存在的最新版本号。&lt;/p&gt;

&lt;p&gt;###其他问题&lt;/p&gt;

&lt;p&gt;设置本地分支与远程分支保持同步，在第一次 git push 的时候带上 -u 参数即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git push origin master -u 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;支持中文目录与文件名的显示（git 默认将非 ASCII 编码的目录与文件名以八进制编码展示）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config core.quotepath off
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;常用的打 tag 操作，更多请查看《Git 基础 - 打标签》&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 列出所有本地 tag
git tag   

# 本地新增一个 tag，推送至 origin 服务器
git tag -a v1.0.0 -m &#39;tag description&#39;
git push origin v1.0.0

# 删除本地与 origin tag
git tag -d v1.0.0
git push origin --delete v1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用 git GUI 客户端（如，SoureTree、Github Desktop）能极大的提升分支管理效率。分支合并操作通常只有两种情况：从 origin merge 到本地，使用 git pull 即可；从另外一个本地分支 merge 到当前分支，使用 git merge &lt;分支名&gt;，以下是常用命令：&lt;/分支名&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 新建分支 branch1，并切换过去
git checkout -b branch1

# 查看所有本地与远程分支
git branch -a

# 修改完成后，切换回 master 分支，将 branch1 分支合并进来
git checkout master
git merge branch1

# 删除已完成合并的分支 branch1
git branch -d branch1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###参考资料&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pro Git 简体中文版&lt;/li&gt;
  &lt;li&gt;Git权威指南&lt;/li&gt;
  &lt;li&gt;命令行man手册&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>解决百度爬虫无法抓取github pages</title>
   <link href="http://http://coolshell.info/blog/2016/02/baidu-spider-forbidden.html"/>
   <updated>2016-02-18T00:00:00+00:00</updated>
   <id>/blog/2016/02/baidu-spider-forbidden</id>
   <content type="html">&lt;p&gt;由于Github Pages禁止了百度爬虫，导致自己的博客无法被百度索引到，使用七牛云和又拍云做镜像存储能解决问题，但是要求域名要备案，由于我的域名从Godaddy上购买的，国内备案手续太复杂，故放弃了CDN的办法，琢磨了一段时间找到了Gitcafe的解决办法。&lt;/p&gt;

&lt;p&gt;##解决方案&lt;/p&gt;

&lt;p&gt;既然不想放弃Github，唯一的办法就是不让百度爬虫直接抓取GIthub的内容，而是抓取自己网站的一个镜像，将网站的内容镜像到&lt;a href=&quot;www.gitcafe.com&quot;&gt;gitcafe&lt;/a&gt;,步骤如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;注册 gitcafe 帐号&lt;/li&gt;
  &lt;li&gt;创建一个跟用户名一样的项目,比如我的&lt;a href=&quot;https://gitcafe.com/ezlippi/ezlippi&quot;&gt;https://gitcafe.com/ezlippi/ezlipp&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;把 github 的项目推到 gitcafe 上面去，步骤如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git remote add gitcafe https://gitcafe.com/ezlippi/ezlippi.git
git checkout -b gitcafe-pages
切换到一个新分支 &lt;span class=&quot;s1&quot;&gt;&#39;gitcafe-pages&#39;&lt;/span&gt;
git push gitcafe master:gitcafe-pages
Username &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;https://gitcafe.com&#39;&lt;/span&gt;:ezlippi 
Password &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;https://ezlippi@gitcafe.com&#39;&lt;/span&gt;
Counting objects: 17, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
Delta compression using up to 4 threads.
Compressing objects: 100% &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;10/10&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
Writing objects: 100% &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;10/10&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1.06 KiB | 0 bytes/s, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
Total 10 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;delta 8&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, reused 0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;delta 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
To https://gitcafe.com/ezlippi/ezlippi.git
   f0d0296..51611d7  master -&amp;gt; gitcafe-pages&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;gitcafe绑定自己的域名&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;点击项目的右上角的 项目配置&lt;/li&gt;
  &lt;li&gt;在项目的 基础设置 中配置项目主页&lt;/li&gt;
  &lt;li&gt;在 page服务 中添加自己的域名，比如我这里是&lt;a href=&quot;coolshell.info&quot;&gt;coolshell.info&lt;/a&gt;和&lt;a href=&quot;www.coolshell.info&quot;&gt;www.coolshell.info&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;DNS的配置中增加一项 CNAME.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我使用 dnspod 这个提供商来管理DNS.CNAME一般可以按解析路线或者网络类型来单独配置,网络类型选择国内或者联通，设置之后等待一段时间百度的抓取就 恢复正常了，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dnspod.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Zsh-Linux下最好的Shell简介</title>
   <link href="http://http://coolshell.info/blog/2015/08/linux-zsh.html"/>
   <updated>2015-08-23T00:00:00+00:00</updated>
   <id>/blog/2015/08/linux-zsh</id>
   <content type="html">&lt;p&gt;没听过Shell?Shell是Unix/Linux系统下的外壳，负责外界和Linux内核的交互，将用户输入的命令转换成内核能懂的语言，执行相应的指令，然后将输出返回给用户．&lt;/p&gt;

&lt;p&gt;###查看当前系统所有的Shell&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ls /etc/shells
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果如下：
&lt;img src=&quot;/images/zsh1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###安装Zsh&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install zsh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简单吧？把它设置为默认Shell,&lt;code class=&quot;highlighter-rouge&quot;&gt;chsh -s /bin/zsh&lt;/code&gt;
它的默认配置为.zshrc,你可以在里面配置各种按键别名，你也可以使用Github上比较流行的oh-my-zsh配置，安装方法：&lt;/p&gt;

&lt;p&gt;自动安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;手动安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装之后进入一个Git分支，显示是这样的，很炫对吧？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zsh2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以前切换工作目录一直按cd加tab是不是很麻烦，现在有了Zsh只需要输入d,他会显示最近使用的工作目录，然后输入数字进入对应的目录，是不是很省事？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zsh3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;它的功能不局限如此，时间长了忘记了tar的参数？输入&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -&lt;/code&gt;按一下tab键会显示所有的命令行参数，再按一下tab进入选择模式，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zsh4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以前杀死进程是不是用&lt;code class=&quot;highlighter-rouge&quot;&gt;ps aux | grep python&lt;/code&gt;
&lt;img src=&quot;/images/zsh5.png&quot; alt=&quot;&quot; /&gt;
现在只需要输入&lt;code class=&quot;highlighter-rouge&quot;&gt;kill python&lt;/code&gt;再按一下tab键，结果变成这样了,神奇把？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zsh6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###插件&lt;/p&gt;

&lt;p&gt;在.zshrc文件里可以配置你要使用的插件，Zsh提供上千种插件，你可以配置自己Shell的主题，我用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;ZSH_THEME=”robbyrussell”&lt;/code&gt;,你还可以配置需要的插件，我的插件是&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins=(git autojump mvn gradle)&lt;/code&gt;,简单介绍下git和autojump:&lt;/p&gt;

&lt;p&gt;git. 当你进入一个git目录时，Zsh会显示git和所在的分支，对git的命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考~/.oh-my-zsh/plugins/git/git.plugin.zsh&lt;/p&gt;

&lt;p&gt;autojump. 安装方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解压缩后进入目录，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;./install.sh&lt;/code&gt;,最后加上这一行代码到.zshrc中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;amp;&amp;amp; . ~/.autojump/etc/profile.d/autojump.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过workspace目录，输入j work 即可正确跳转。j –stat 可以看你的历史路径库。&lt;/p&gt;

&lt;p&gt;你还可以参考&lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot;&gt;Zsh&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Latex中英文环境设置</title>
   <link href="http://http://coolshell.info/blog/2015/08/latex-fonts-settings.html"/>
   <updated>2015-08-22T00:00:00+00:00</updated>
   <id>/blog/2015/08/latex-fonts-settings</id>
   <content type="html">&lt;p&gt;Latex默认是不支持中文的,后来有人开发了XeLatex来支持非英文字符,xetex是一种使用Unicode的TeX排版引擎,并默认其输入文件为UTF-8编码，也即,英文字符与非英文字符不再有区别，原生支持系统字体，这意味着我们无需再额外编译字体, 故可以在不进行额外配置的情况下直接使用操作系统中安装的字体。&lt;/p&gt;

&lt;p&gt;安装完TexLive后,编写下面的tex文件：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-tex&quot; data-lang=&quot;tex&quot;&gt;&lt;span class=&quot;k&quot;&gt;\documentclass&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[12pt,a4paper]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;article&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\usepackage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;xltxtra,fontspec,xunicode&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;\setmainfont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;WenQuanYi Zen Hei&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;% 设置文档默认字体&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;% 不显示文档生成日期&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;\XeTeX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; 中英文环境测试&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;\begin{document}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\maketitle&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\XeTeX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; is a &lt;span class=&quot;k&quot;&gt;\TeX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; typesetting engine using Unicode and supporting modern font technologies.&lt;span class=&quot;k&quot;&gt;\\&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\XeTeX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; 是一个使用Unicode的&lt;span class=&quot;k&quot;&gt;\TeX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;排版系统，并支持一些现代字体技术.&lt;span class=&quot;k&quot;&gt;\\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;\end{document}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;使用下面命令编译:&lt;code class=&quot;highlighter-rouge&quot;&gt;XeLatex test.tex&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/latex1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的英文也使用了中文字体, 看上去不是很美观. 于是, xetex 和 CJK 商量了一下, 就有了xeCJK 宏包, 可以分别指定中英文字体, 于是可以很好的排版中英混合的文章了．&lt;/p&gt;

&lt;p&gt;当然首先是要使用xeCJK包,添加上&lt;code class=&quot;highlighter-rouge&quot;&gt;\usepackage[slantfont,boldfont]{xeCJK}&lt;/code&gt;
分别设置中英文字体, 英文字体可以不用设置, xetex会调用默认的字体:&lt;code class=&quot;highlighter-rouge&quot;&gt;\setCJKmainfont{SimKai}   % 设置缺省中文字体为楷体&lt;/code&gt;
下面是测试文件：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-tex&quot; data-lang=&quot;tex&quot;&gt;	&lt;span class=&quot;k&quot;&gt;\documentclass&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[12pt,a4paper]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;article&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\usepackage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;xltxtra,fontspec,xunicode&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\usepackage&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[slantfont,boldfont]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;xeCJK&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\setCJKmainfont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;WenQuanYi Zen Hei&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;% 设置缺省中文字体&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;%\setCJKmonofont{Hei}   % 设置等宽字体&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;%\setmainfont{Optima}   %% 不指定，使用Tex的默认英文衬线字体&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;%\setmonofont{Monaco}   % 英文等宽字体&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;%\setsansfont{Trebuchet MS} % 英文无衬线字体&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;% 不显示文档生成日期&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;\XeTeX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; 中英文环境测试&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;\begin{document}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\maketitle&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;\XeTeX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; is a &lt;span class=&quot;k&quot;&gt;\TeX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; typesetting engine using Unicode and supporting modern font technologies.&lt;span class=&quot;k&quot;&gt;\\&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;\XeTeX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; 是一个使用Unicode的&lt;span class=&quot;k&quot;&gt;\TeX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;排版系统，并支持一些现代字体技术.&lt;span class=&quot;k&quot;&gt;\\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;\end{document}&lt;/span&gt;

 &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;输出结果如下：
&lt;img src=&quot;/images/latex2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样效果就好很多了．&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>一些强大的Vim插件</title>
   <link href="http://http://coolshell.info/blog/2015/03/vim-plugins.html"/>
   <updated>2015-03-20T01:20:26+00:00</updated>
   <id>/blog/2015/03/vim-plugins</id>
   <content type="html">
&lt;p&gt;除了一些常用的插件比如ctags，taglist，bufexplorer,winmamager之外，这里介绍一些很强大的插件。&lt;/p&gt;

&lt;p&gt;1.&lt;em&gt;Vundle&lt;/em&gt; &lt;a href=&quot;https://github.com/gmarik/Vundle.vim&quot;&gt;Github主页&lt;/a&gt;，一个强大的插件管理器&lt;/p&gt;

&lt;p&gt;###Vundle可以：&lt;/p&gt;

&lt;p&gt;1.在Vimrc文件里跟踪和配置你的插件&lt;/p&gt;

&lt;p&gt;2.只需敲一条命令就可以安装、更新、搜索、清除插件&lt;/p&gt;

&lt;p&gt;###安装Vundle&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;配置Vundle插件：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; nocompatible              &quot; be iMproved&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; required
    &lt;span class=&quot;k&quot;&gt;filetype&lt;/span&gt; off                  &quot; required
    
    &lt;span class=&quot;c&quot;&gt;&quot; set the runtime path to include Vundle and initialize&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; rtp&lt;span class=&quot;p&quot;&gt;+=~&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/.vim/&lt;/span&gt;bundle/Vundle&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;vim&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; vundle#begin&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; alternatively, pass a path where Vundle should install plugins&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot;call vundle#begin(&#39;~/some/path/here&#39;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot;在下面添加你需要安装的插件&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; let Vundle manage Vundle, required&lt;/span&gt;
    Plugin &lt;span class=&quot;s1&quot;&gt;&#39;gmarik/Vundle.vim&#39;&lt;/span&gt;
    
    &lt;span class=&quot;c&quot;&gt;&quot; The following are examples of different formats supported.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; Keep Plugin commands between vundle#begin/end.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot;在Github仓库的插件&lt;/span&gt;
    Plugin &lt;span class=&quot;s1&quot;&gt;&#39;tpope/vim-fugitive&#39;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; http://vim-scripts.org/vim/scripts.html网站上的插件直接写插件名称&lt;/span&gt;
    Plugin &lt;span class=&quot;s1&quot;&gt;&#39;L9&#39;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; Git plugin not hosted on GitHub&lt;/span&gt;
    Plugin &lt;span class=&quot;s1&quot;&gt;&#39;git://git.wincent.com/command-t.git&#39;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; 本机目录下的插件&lt;/span&gt;
    Plugin &lt;span class=&quot;s1&quot;&gt;&#39;file:///home/gmarik/path/to/plugin&#39;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; The sparkup vim script is in a subdirectory of this repo called vim.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; Pass the path to set the runtimepath properly.&lt;/span&gt;
    Plugin &lt;span class=&quot;s1&quot;&gt;&#39;rstacruz/sparkup&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;rtp&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;vim/&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; Avoid a name conflict with L9&lt;/span&gt;
    Plugin &lt;span class=&quot;s1&quot;&gt;&#39;user/L9&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;name&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;newL9&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c&quot;&gt;&quot; 所有的插件需要在这一行之前添加&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; vundle#&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;            &quot; required
    &lt;span class=&quot;k&quot;&gt;filetype&lt;/span&gt; plugin indent &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt;    &quot; required
    &lt;span class=&quot;c&quot;&gt;&quot; To ignore plugin indent changes, instead use:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot;filetype plugin on&lt;/span&gt;
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;###如何使用Vundle&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;    &lt;span class=&quot;c&quot;&gt;&quot; Brief help&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; :PluginList       - lists configured plugins&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&quot; 使用:h vundle 显示帮助文档&lt;/span&gt;

      &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;hr /&gt;

&lt;p&gt;2.&lt;em&gt;neocomplete&lt;/em&gt; &lt;a href=&quot;https://github.com/Shougo/neocomplete.vim&quot;&gt;github主页&lt;/a&gt;，一个比VIm自带补全更强大的自动补全插件，支持更多的特性。&lt;/p&gt;

&lt;p&gt;###安装&lt;/p&gt;

&lt;p&gt;确保你的系统安装了下列之一：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;vim-nox&lt;/li&gt;
  &lt;li&gt;vim-gtk&lt;/li&gt;
  &lt;li&gt;vim-gnome&lt;/li&gt;
  &lt;li&gt;vim-athena&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后再Vundle中添加一句：Plugin ‘Shougo/neocomplete.vim’，重新打开Vim就自动安装了&lt;/p&gt;

&lt;p&gt;###ScreenShots&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/2135f9b37963594325b304a7a57163b5b6ab8b11/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f3231343438382f3632333135312f32383461643836652d636635622d313165322d383238652d3235376433316266303537322e706e67&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/4a4d1893ce150863dd815fa6967e5f526ac84727/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f3231343438382f3632333439362f39346564313961322d636636382d313165322d386433332d3361616438613339643763312e676966&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###配置&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;        &lt;span class=&quot;c&quot;&gt;&quot;Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; Disable AutoComplPop.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g:acp_enableAtStartup&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; Use neocomplete.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g:neocomplete&lt;/span&gt;#enable_at_startup &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; Use smartcase.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g:neocomplete&lt;/span&gt;#enable_smart_case &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; Set minimum syntax keyword length.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g:neocomplete&lt;/span&gt;#sources#syntax#min_keyword_length &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g:neocomplete&lt;/span&gt;#lock_buffer_name_pattern &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;\*ku\*&#39;&lt;/span&gt;
        
        &lt;span class=&quot;c&quot;&gt;&quot; Define dictionary.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g:neocomplete&lt;/span&gt;#sources#dictionary#dictionaries &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;            \&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;default&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;            \&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;vimshell&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; $HOME&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;/.vimshell_hist&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;            \&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;scheme&#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; $HOME&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;/.gosh_completions&#39;&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;                \&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;c&quot;&gt;&quot; Define keyword.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;exists&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;g:neocomplete#keyword_patterns&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g:neocomplete&lt;/span&gt;#keyword_patterns &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g:neocomplete&lt;/span&gt;#keyword_patterns&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;default&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;\h\w*&#39;&lt;/span&gt;
        
        &lt;span class=&quot;c&quot;&gt;&quot; Plugin key-mappings.&lt;/span&gt;
        inoremap &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;expr&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;     neocomplete#undo_completion&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        inoremap &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;expr&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;     neocomplete#complete_common_string&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        
        &lt;span class=&quot;c&quot;&gt;&quot; Recommended key-mappings.&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; &amp;lt;CR&amp;gt;: close popup and save indent.&lt;/span&gt;
        inoremap &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;silent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;CR&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;C&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;=&amp;lt;&lt;/span&gt;SID&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;my_cr_function&lt;span class=&quot;p&quot;&gt;()&amp;lt;&lt;/span&gt;CR&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s:my_cr_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; neocomplete#close_popup&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;\&amp;lt;CR&amp;gt;&quot;&lt;/span&gt;
          &lt;span class=&quot;c&quot;&gt;&quot; For no inserting &amp;lt;CR&amp;gt; key.&lt;/span&gt;
          &lt;span class=&quot;c&quot;&gt;&quot;return pumvisible() ? neocomplete#close_popup() : &quot;\&amp;lt;CR&amp;gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;endfunction&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; &amp;lt;TAB&amp;gt;: completion.&lt;/span&gt;
        inoremap &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;expr&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;TAB&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;  pumvisible&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; ? &lt;span class=&quot;s2&quot;&gt;&quot;\&amp;lt;C-n&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;\&amp;lt;TAB&amp;gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; &amp;lt;C-h&amp;gt;, &amp;lt;BS&amp;gt;: close popup and delete backword char.&lt;/span&gt;
        inoremap &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;expr&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; neocomplete#smart_close_popup&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;\&amp;lt;C-h&amp;gt;&quot;&lt;/span&gt;
        inoremap &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;expr&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;BS&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; neocomplete#smart_close_popup&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;\&amp;lt;C-h&amp;gt;&quot;&lt;/span&gt;
        inoremap &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;expr&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;  neocomplete#close_popup&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        inoremap &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;expr&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;  neocomplete#cancel_popup&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; Close popup by &amp;lt;Space&amp;gt;.&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;inoremap &amp;lt;expr&amp;gt;&amp;lt;Space&amp;gt; pumvisible() ? neocomplete#close_popup() : &quot;\&amp;lt;Space&amp;gt;&quot;&lt;/span&gt;
        
        &lt;span class=&quot;c&quot;&gt;&quot; For cursor moving in insert mode(Not recommended)&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;inoremap &amp;lt;expr&amp;gt;&amp;lt;Left&amp;gt;  neocomplete#close_popup() . &quot;\&amp;lt;Left&amp;gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;inoremap &amp;lt;expr&amp;gt;&amp;lt;Right&amp;gt; neocomplete#close_popup() . &quot;\&amp;lt;Right&amp;gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;inoremap &amp;lt;expr&amp;gt;&amp;lt;Up&amp;gt;    neocomplete#close_popup() . &quot;\&amp;lt;Up&amp;gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;inoremap &amp;lt;expr&amp;gt;&amp;lt;Down&amp;gt;  neocomplete#close_popup() . &quot;\&amp;lt;Down&amp;gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; Or set this.&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;let g:neocomplete#enable_cursor_hold_i = 1&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; Or set this.&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;let g:neocomplete#enable_insert_char_pre = 1&lt;/span&gt;
        
        &lt;span class=&quot;c&quot;&gt;&quot; AutoComplPop like behavior.&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;let g:neocomplete#enable_auto_select = 1&lt;/span&gt;
        
        &lt;span class=&quot;c&quot;&gt;&quot; Shell like behavior(not recommended).&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;set completeopt+=longest&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;let g:neocomplete#enable_auto_select = 1&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;let g:neocomplete#disable_auto_complete = 1&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;inoremap &amp;lt;expr&amp;gt;&amp;lt;TAB&amp;gt;  pumvisible() ? &quot;\&amp;lt;Down&amp;gt;&quot; : &quot;\&amp;lt;C-x&amp;gt;\&amp;lt;C-u&amp;gt;&quot;&lt;/span&gt;
        
        &lt;span class=&quot;c&quot;&gt;&quot; Enable omni completion.&lt;/span&gt;
        autocmd &lt;span class=&quot;nb&quot;&gt;FileType&lt;/span&gt; css &lt;span class=&quot;k&quot;&gt;setlocal&lt;/span&gt; omnifunc&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;csscomplete#CompleteCSS
        autocmd &lt;span class=&quot;nb&quot;&gt;FileType&lt;/span&gt; html&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;markdown &lt;span class=&quot;k&quot;&gt;setlocal&lt;/span&gt; omnifunc&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;htmlcomplete#CompleteTags
        autocmd &lt;span class=&quot;nb&quot;&gt;FileType&lt;/span&gt; javascript &lt;span class=&quot;k&quot;&gt;setlocal&lt;/span&gt; omnifunc&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;javascriptcomplete#CompleteJS
        autocmd &lt;span class=&quot;nb&quot;&gt;FileType&lt;/span&gt; python &lt;span class=&quot;k&quot;&gt;setlocal&lt;/span&gt; omnifunc&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;pythoncomplete#Complete
        autocmd &lt;span class=&quot;nb&quot;&gt;FileType&lt;/span&gt; xml &lt;span class=&quot;k&quot;&gt;setlocal&lt;/span&gt; omnifunc&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xmlcomplete#CompleteTags
        
        &lt;span class=&quot;c&quot;&gt;&quot; Enable heavy omni completion.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;exists&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;g:neocomplete#sources#omni#input_patterns&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g:neocomplete&lt;/span&gt;#sources#omni#input_patterns &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;let g:neocomplete#sources#omni#input_patterns.php = &#39;[^. \t]-&amp;gt;\h\w*\|\h\w*::&#39;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;let g:neocomplete#sources#omni#input_patterns.c = &#39;[^.[:digit:] *\t]\%(\.\|-&amp;gt;\)&#39;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot;let g:neocomplete#sources#omni#input_patterns.cpp = &#39;[^.[:digit:] *\t]\%(\.\|-&amp;gt;\)\|\h\w*::&#39;&lt;/span&gt;
        
        &lt;span class=&quot;c&quot;&gt;&quot; For perlomni.vim setting.&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&quot; https://github.com/c9s/perlomni.vim&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;g:neocomplete&lt;/span&gt;#sources#omni#input_patterns&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;perl &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;\h\w*-&amp;gt;\h\w*\|\h\w*::&#39;&lt;/span&gt;
         &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;3.&lt;em&gt;CtrlP插件&lt;/em&gt; &lt;a href=&quot;https://github.com/kien/ctrlp.vim&quot;&gt;github主页&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;快速查找文件、缓冲区、tag的Vim插件，可以同时打开多个文件，创建文件和目录&lt;/p&gt;

&lt;p&gt;基本操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在Vim中按下Ctrl+p打开Ctrlp插件
&amp;lt;c-d&amp;gt;在路径搜索和文件名搜索之间切换
 &amp;lt;c-r&amp;gt;在字符串搜索和正则表达式搜索中切换
&amp;lt;c-f&amp;gt;和&amp;lt;c-b&amp;gt;forward和backward，搜索结果在不同搜索模式中切换
&amp;lt;c-j&amp;gt;&amp;lt;c-k&amp;gt;在结果中切换
&amp;lt;c-n&amp;gt;&amp;lt;c-p&amp;gt;在搜索历史中切换
&amp;lt;c-t&amp;gt;在新Tab中打开选中的文件
&amp;lt;c-v&amp;gt;在垂直分屏中打开选中的文件
&amp;lt;c-s&amp;gt;在水平分屏中打开选中的文件
&amp;lt;c-y&amp;gt;创建新的文件和目录
&amp;lt;c-z&amp;gt;标记将要打开的文件
&amp;lt;c-o&amp;gt;打开被&amp;lt;c-z&amp;gt;标记的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4&lt;em&gt;surround&lt;/em&gt; &lt;a href=&quot;https://github.com/tpope/vim-surround&quot;&gt;github主页&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大多数编程语言的语法都用到了配对符号surrounding: (), [], {}, &amp;lt;&amp;gt;, ‘’, “”，标记语言xml html 等更是完全依赖与这种语法。正常输入时，所有的编辑器都能胜任，大部分会在你输入一个括号时帮你补全另一半。vim 也有这样的插件auto-pair, 但是这个不是重点，真正的难题是当你需要为已一些存在的代码加上括号，删除一对括号但保留其中的内容，或者把一对()改成[]。&lt;/p&gt;

&lt;p&gt;使用surround，你将很容易添加和修改配对符号，比如：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;	     Old text                  Command		 New text &lt;span class=&quot;p&quot;&gt;~&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;&quot;Hello *world!&quot;				 ds&quot;         Hello world!&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;*&lt;span class=&quot;m&quot;&gt;56&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/2					cs])        (123+456)/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;&quot;Look ma, I&#39;m *HTML!&quot;			cs&quot;&amp;lt;q&amp;gt;      &amp;lt;q&amp;gt;Look ma, I&#39;m HTML!&amp;lt;/q&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; *&lt;span class=&quot;k&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;						ysW&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      my $str &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; *whee&lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;;				vlllls&lt;span class=&quot;s1&quot;&gt;&#39;     my $str = &#39;&lt;/span&gt;whee&lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;&#39;;
      &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;Yo&lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;*&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;/div&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;				dst         Yo&lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;Yo&lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;*&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;				cst&amp;lt;p&amp;gt;      &amp;lt;p&amp;gt;Yo!&amp;lt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
          &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上面*代表当前光标位置，添加替换时使用后半括号)]}，添加的括号和内容间就没有空格（如第2个示例），反之会在内容前后添加一个空格（如第4个实例）。第6个示例中的t代表一对HTML或者xml tag。其他表示范围的符号：w代表word, W代表WORD(被空格分开的连续的字符窜），p代表paragraph。&lt;/p&gt;

&lt;p&gt;###命令列表&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;        Normal &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;-----------&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ds&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; delete &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; surrounding
    &lt;span class=&quot;k&quot;&gt;cs&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; change &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; surrounding
    ys  &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; add &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; surrounding
    yS  &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; add &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; surrounding and place the surrounded text &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; line &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; indent it
    yss &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; add &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; surrounding &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; the whole line
    ySs &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; add &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; surrounding &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; the whole line&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; place it &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; line &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; indent it
    ySS &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; same &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; ySs
    
    Visual &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;-----------&lt;/span&gt;
    s   &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; visual &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; add &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; surrounding
    S   &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; visual &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; add &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; surrounding but place text &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; line &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; indent it
    
    Insert &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;-----------&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;CTRL&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;s&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; insert &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; add &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; surrounding
    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;CTRL&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;s&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;CTRL&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;s&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; insert &lt;span class=&quot;k&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; add &lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; line &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; surrounding &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; indent
    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;CTRL&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;s &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; same &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;CTRL&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;s&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;CTRL&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;S &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; same &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;CTRL&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;s&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;CTRL&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;s&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;5.&lt;em&gt;syntastic&lt;/em&gt;  &lt;a href=&quot;https://github.com/scrooloose/syntastic#installation&quot;&gt;githun主页&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;来看一下官方给的图片：
&lt;img src=&quot;http://foocoder.qiniudn.com/blog/syntasticsyntastic.png?token=hYfsyKwhHPe-Ga-1Hypx5F8CwimEywvTI8XdNpEm:z6zQYbdezgOYcKfzok7LEkuRDkg=:eyJTIjoiZm9vY29kZXIucWluaXVkbi5jb20vYmxvZy9zeW50YXN0aWNzeW50YXN0aWMucG5nIiwiRSI6MTQwMDA2ODU2N30=&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;图片很清楚的介绍了插件功能：&lt;/li&gt;
  &lt;li&gt;用location list 列出所有错误。&lt;/li&gt;
  &lt;li&gt;命令行窗口显示当前错误。&lt;/li&gt;
  &lt;li&gt;错误标记，有警告和错误。&lt;/li&gt;
  &lt;li&gt;鼠标悬停可以出现错误提示框&lt;/li&gt;
  &lt;li&gt;状态栏标记。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###配置&lt;/p&gt;

&lt;p&gt;当然也可以做一些简单的配置，比如设置为每次打开buffer就执行语法检查，而不只是在保存时：
    let g:syntastic_check_on_open = 1
如果想使用多个检查器，可以这样写：
    let g:syntastic_php_checkers = [‘php’, ‘phpcs’, ‘phpmd’]&lt;/p&gt;

&lt;p&gt;###错误跳转&lt;/p&gt;

&lt;p&gt;syntastic使用location list来显示所有的错误，location list和quificfix 类似，包含了位置信息。
调起这个location list
    :Errors 或者 :lopen
使用:lne[xt]和:lp[revious]就可以在错误间跳转。当然，如果用的多，可以做个mapping,更多内容可以参考帮助文档:help syntastic.&lt;/p&gt;

&lt;p&gt;6.&lt;em&gt;fugitive&lt;/em&gt;&lt;a href=&quot;https://github.com/tpope/vim-fugitive&quot;&gt;github主页&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you don’t know GIT, learn it right now!If you use GIT and VIM, use Fugitive right now!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;fugitive.vim插件是由Tim Pope创建的VIM插件。该插件与命令行git工具相辅相成，可以无缝的插入到工作流程中。&lt;/p&gt;

&lt;p&gt;在VIM的命令行中，%符号具有特殊的含义：他将扩展为当前文件的全路径。可以使用该命令来运行使用文件名作为参数的任意git命令，从而使得命令作用于当前的文件。但是fugitive也提供了一些便利的方法，其中的一些总结如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;      git	             fugitive	      action
    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;Git add %	        &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;Gwrite  	     Stage the current &lt;span class=&quot;k&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; the index
    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;Git checkout %	    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;Gread	         Revert current &lt;span class=&quot;k&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; last checked &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; version
    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;Git rm %	        &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;Gremove	     Delete the current &lt;span class=&quot;k&quot;&gt;file&lt;/span&gt; and the corresponding Vim buffer
    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;Git mv %	        &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;Gmove	         Rename the current &lt;span class=&quot;k&quot;&gt;file&lt;/span&gt; and the corresponding Vim buffer
     &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</content>
 </entry>
 
 <entry>
   <title>利用github-pages建立个人博客</title>
   <link href="http://http://coolshell.info/blog/2015/03/github-pages-blog.html"/>
   <updated>2015-03-01T00:00:00+00:00</updated>
   <id>/blog/2015/03/github-pages-blog</id>
   <content type="html">
&lt;p&gt;##前言&lt;/p&gt;

&lt;p&gt;Github很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如jQuery、Twitter等。为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，Github替你想到了这一点，他提供了Github Pages的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。&lt;/p&gt;

&lt;p&gt;Github Pages有以下几个优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;轻量级的博客系统，没有麻烦的配置&lt;/li&gt;
  &lt;li&gt;使用标记语言，比如Markdown 无需自己搭建服务器&lt;/li&gt;
  &lt;li&gt;根据Github的限制，对应的每个站有300MB空间&lt;/li&gt;
  &lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然他也有缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用Jekyll模板系统，相当于静态页发布，适合博客，文档介绍等。&lt;/li&gt;
  &lt;li&gt;动态程序的部分相当局限，比如没有评论，不过还好我们有解决方案。&lt;/li&gt;
  &lt;li&gt;基于Git，很多东西需要动手，不像Wordpress有强大的后台&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大致介绍到此，作为个人博客来说，简洁清爽的表达自己的工作、心得，就已达目标，所以Github Pages是我认为此需求最完美的解决方案了。&lt;/p&gt;

&lt;p&gt;##购买、绑定独立域名&lt;/p&gt;

&lt;p&gt;虽说Godaddy曾支持过SOPA，并且首页放着极其不专业的大胸美女，但是作为域名服务商他做的还不赖，选择它最重要的原因是他支持支付宝，没有信用卡有时真的很难过。&lt;/p&gt;

&lt;p&gt;域名的购买不用多讲，注册、选域名、支付，有网购经验的都毫无压力，优惠码也遍地皆是。域名的配置需要提醒一下，因为伟大英明的GFW的存在，我们必须多做些事情。&lt;/p&gt;

&lt;p&gt;流传Godaddy的域名解析服务器被墙掉，导致域名无法访问，后来这个事情在BeiYuu也发生了，不得已需要把域名解析服务迁移到国内比较稳定的服务商处，这个迁移对于域名来说没有什么风险，最终的控制权还是在Godaddy那里，你随时都可以改回去。&lt;/p&gt;

&lt;p&gt;我们选择DNSPod的服务，他们的产品做得不错，易用、免费，收费版有更高端的功能，暂不需要。注册登录之后，按照DNSPod的说法，只需三步（我们插入一步）：&lt;/p&gt;

&lt;p&gt;首先添加域名记录，可参考DNSPod的帮助文档：&lt;a href=&quot;https://www.dnspod.cn/Support&quot;&gt;https://www.dnspod.cn/Support&lt;/a&gt;
在DNSPod自己的域名下添加一条A记录，地址就是Github Pages的服务IP地址：&lt;code class=&quot;highlighter-rouge&quot;&gt;192.30.252.153&lt;/code&gt;
在域名注册商处修改DNS服务:去Godaddy修改Nameservers为这两个地址： &lt;code class=&quot;highlighter-rouge&quot;&gt;f1g1ns1.dnspod.net、f1g1ns2.dnspod.net&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;##配置和使用Github&lt;/p&gt;

&lt;p&gt;git是版本管理的未来，他的优点我不再赘述，相关资料很多。推荐这本&lt;a href=&quot;http://git-scm.com/book/zh&quot;&gt;Git中文教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要使用Git，需要安装它的客户端，推荐在Linux下使用Git，会比较方便。下载地址在这里：&lt;a href=&quot;http://code.google.com/p/msysgit/downloads/list&quot;&gt;http://code.google.com/p/msysgit/downloads/lis
&lt;/a&gt;。其他系统的安装也可以参考官方的安装教程。&lt;/p&gt;

&lt;p&gt;安装完成后，还需要最后一步设置，在命令行输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config --global user.name &quot;Your Name&quot;
$ git config --global user.email &quot;email@example.com&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###检查SSH keys的设置&lt;/p&gt;

&lt;p&gt;首先我们需要检查你电脑上现有的ssh key：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~/.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ssh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;如果显示“No such file or directory”，跳到第三步，否则继续。&lt;/p&gt;

&lt;p&gt;###备份和移除原来的ssh key设置&lt;/p&gt;

&lt;p&gt;因为已经存在key文件，所以需要备份旧的数据并删除：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;ls
config  id_rsa  id_rsa.pub  known_hosts
mkdir key_backup
cp id_rsa&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; key_backup
rm id_rsa&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;###生成新的SSH Key&lt;/p&gt;

&lt;p&gt;输入下面的代码，就可以生成新的key文件，我们只需要默认设置就好，所以当需要输入文件名的时候，回车就好。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ssh-keygen -t rsa -C &lt;span class=&quot;s2&quot;&gt;&quot;邮件地址@youremail.com&quot;&lt;/span&gt;
Generating public/private rsa key pair.
Enter file &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;which to save the key &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;/Users/	your_user_directory/.ssh/id_rsa&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:&amp;lt;回车就好&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;然后系统会要你输入加密串（Passphrase）：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Enter passphrase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;empty &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;no passphrase&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:&amp;lt;输入加密串&amp;gt;
Enter same passphrase again:&amp;lt;再次输入加密串&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;最后看到ssh key success，就成功设置ssh key了.&lt;/p&gt;

&lt;p&gt;###添加SSH Key到GitHub&lt;/p&gt;

&lt;p&gt;在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。&lt;/p&gt;

&lt;p&gt;用文本编辑工具打开id_rsa.pub文件，如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。&lt;/p&gt;

&lt;p&gt;在GitHub的主页上点击设置按钮： github account setting&lt;/p&gt;

&lt;p&gt;选择SSH Keys项，把复制的内容粘贴进去，然后点击Add Key按钮即可： 
&lt;img src=&quot;/images/images/githubpages/bootcamp_1_ssh.jpg&quot; alt=&quot;set ssh keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PS：如果需要配置多个GitHub账号，可以参看这个&lt;a href=&quot;http://ju.outofmemory.cn/entry/16775&quot;&gt;多个github帐号的SSH key切换&lt;/a&gt;，不过需要提醒一下的是，如果你只是通过这篇文章中所述配置了Host，那么你多个账号下面的提交用户会是一个人，所以需要通过命令&lt;code class=&quot;highlighter-rouge&quot;&gt;git config --global --unset user.email&lt;/code&gt;删除用户账户设置，在每一个repo下面使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git config --local user.email &#39;你的github邮箱@mail.com&#39; &lt;/code&gt;命令单独设置用户账户信息&lt;/p&gt;

&lt;p&gt;###测试一下&lt;/p&gt;

&lt;p&gt;可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh -T git@github.com

    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;如果是下面的反应：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不要紧张，输入yes就好，然后会看到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hi &amp;lt;em&amp;gt;username&amp;lt;/em&amp;gt;! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###设置你的账号信息&lt;/p&gt;

&lt;p&gt;现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。&lt;/p&gt;

&lt;p&gt;Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git config --global user.name &lt;span class=&quot;s2&quot;&gt;&quot;你的名字&quot;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git config --global user.email &lt;span class=&quot;s2&quot;&gt;&quot;your_email@youremail.com&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;好了，你已经可以成功连接GitHub了。&lt;/p&gt;

&lt;p&gt;##快速开始&lt;/p&gt;

&lt;p&gt;###帐号注册&lt;/p&gt;

&lt;p&gt;在创建博客之前，当然必须有GitHub的帐号，该帐号将用来创建项目，默认的域名&lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.com/projectName&lt;/code&gt;中的username也要用到这个帐号。&lt;/p&gt;

&lt;p&gt;注意：下面涉及到的一些命令凡是更用户名和项目名有关的一律会用这里的username和projectName代替，注意替换
访问：&lt;a href=&quot;http://www.github.com/&quot;&gt;http://www.github.com/ &lt;/a&gt;sign up for free的意思就是“免费注册登录”，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。比如你的主页上传并构建成功会通过邮箱通知，更重要的是，如果构建失败的话也会在邮件中说明原因。&lt;/p&gt;

&lt;p&gt;###创建项目仓库&lt;/p&gt;

&lt;p&gt;在创建博客之前，还需要用已有的帐号创建一个项目，上面那个链接的projectName将是这里即将创建的项目名称。在Git中，项目被称为仓库(Repository)，仓库顾名思义，当然可以包含代码或者非代码。将来我们的网页或者模板实际上都是保存在这个仓库中的。&lt;/p&gt;

&lt;p&gt;登录后，访问&lt;a href=&quot;https://github.com/new&quot;&gt;https://github.com/new&lt;/a&gt;，创建仓库如下图：
&lt;img src=&quot;/images/images/githubpages/build-github-blog-page-02-img0.png&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建了仓库后，我们就需要管理它，无论是管理本地仓库还是远程仓库都需要Git客户端。Git客户端实际上十分强大，它本身就可以offline的创建本地仓库，而本地仓库和远程仓库之间的同步也是通过Git客户端完成的。&lt;/p&gt;

&lt;p&gt;这里省略了windows下安装和使用Git客户端的基本技巧，您应该已经掌握此技能了。虽然，您仍然可以按照本教程的指引完成一个简单的网站，但是后期的维护工作无论如何都不能少了这项技能。&lt;/p&gt;

&lt;p&gt;下面的步骤假设您已经安装好了Git客户端，安装和使用技巧请参见：Git学习资源&lt;/p&gt;

&lt;p&gt;###本地编辑及上传&lt;/p&gt;

&lt;p&gt;在磁盘上创建一个目录，该目录与上面的项目名同名，在该目录下启用Git Bash命令行，并输入如下命令&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$git&lt;/span&gt; init

    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;该命令实际上是在该目录下初始化一个本地的仓库，会在目录下新建一个.git的隐藏文件夹，可以看成是一个仓库数据库。&lt;/p&gt;

&lt;p&gt;创建一个没有父节点的分支gh-pages，并自动切换到这个分支上。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$git&lt;/span&gt; checkout --orphan gh-pages

    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;在Git中，分支(branch)的概念非常重要，Git之所以强大，很大程度上就是因为它强大的分支体系。这里的分支名字必须是gh-pages，因为github规定，只有该分支中的页面，才会生成网页文件。&lt;/p&gt;

&lt;p&gt;在该目录下手动创建如下文件和文件夹，最终形成这样的结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/githubpages/build-github-blog-page-02-img1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;_includes：默认的在模板中可以引用的文件的位置，后面会提到&lt;/li&gt;
  &lt;li&gt;_layouts：默认的公共页面的位置，后面会提到&lt;/li&gt;
  &lt;li&gt;_posts：博客文章默认的存放位置&lt;/li&gt;
  &lt;li&gt;.gitignore：git将忽略这个文件中列出的匹配的文件或文件夹，不将这些纳入源码管理&lt;/li&gt;
  &lt;li&gt;_config.yml：关于jekyll模板引擎的配置文件&lt;/li&gt;
  &lt;li&gt;index.html：默认的主页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在_layouts目录下创建一个default.html，在其中输入如下内容，注意：文件本身要以UTF-8 without BOM的格式保存，以防止各种编码问题，建议使用notepad++或者VIM编辑&lt;/p&gt;

&lt;p&gt;default.html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
　&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;http-equiv=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;content-type&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/html; charset=utf-8&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
　&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;一步步在GitHub上创建博客主页(2)&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
　
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编辑index.html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: default
title: test title
---
&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再次打开Git Bash，先后输入如下命令：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git add .
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -m &lt;span class=&quot;s2&quot;&gt;&quot;first post&quot;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git remote add origin https://github.com/username/projectName.git
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git push origin gh-pages&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;据网友反应，如果是初次安装git的话，在commit的时候会提示需要配置username和email，请读者注意根据提示配置一下，至于username和email可以随便填&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将当前的改动暂存在本地仓库&lt;/li&gt;
  &lt;li&gt;将暂存的改动提交到本地仓库，并写入本次提交的注释是”first post“&lt;/li&gt;
  &lt;li&gt;将远程仓库在本地添加一个引用：origin&lt;/li&gt;
  &lt;li&gt;向origin推送gh-pages分支，该命令将会将本地分支gh-pages推送到github的远程仓库，并在远程仓库创建一个同名的分支。该命令后会提示输入用户名和密码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在，你只需要稍等半分钟时间，访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://username.github.com/projectName&lt;/code&gt;就可以看到生成的博客了&lt;/p&gt;

&lt;p&gt;另外上面提到的，如果生成失败，Github会向你的邮箱发送一封邮件说明，请注意查收。&lt;/p&gt;

&lt;p&gt;##域名扫盲&lt;/p&gt;

&lt;p&gt;说实话，虽然明白什么是域名以及域名解析的原理，但是在实际的互联网环境中，域名的问题其实比理论上说的要复杂些。这里对一些概念稍作整理。&lt;/p&gt;

&lt;p&gt;###A（Address）记录&lt;/p&gt;

&lt;p&gt;是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。&lt;/p&gt;

&lt;p&gt;###CNAME&lt;/p&gt;

&lt;p&gt;也被称为规范名字。这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为&lt;code class=&quot;highlighter-rouge&quot;&gt;“host.mydomain.com”&lt;/code&gt;（A记录）。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。 这两个别名的全称就是&lt;code class=&quot;highlighter-rouge&quot;&gt;“www.mydomain.com”&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;“mail.mydomain.com”&lt;/code&gt;。实际上他们都指向&lt;code class=&quot;highlighter-rouge&quot;&gt;“host.mydomain.com”&lt;/code&gt;。 同样的方法可以用于当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP然后将其他的域名做别名到之前做A记录的域名上，那么当您的服务器IP地址变更时您就可以不必麻烦的一个一个域名更改指向了 只需要更改做A记录的那个域名其他做别名的那些域名的指向也将自动更改到新的IP地址上了。&lt;/p&gt;

&lt;p&gt;###TTL&lt;/p&gt;

&lt;p&gt;TTL值全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上缓存时间。要理解TTL值，请先看下面的一个例子：
假设，有这样一个域名&lt;code class=&quot;highlighter-rouge&quot;&gt;myhost.cnMonkey.com&lt;/code&gt;（其实，这就是一条DNS记录，通常表示在abc.com域中有一台名为myhost的主机）对应IP地 址为1.1.1.1，它的TTL为10分钟。这个域名或称这条记录存储在一台名为dns.cnMonkey.com的DNS服务器上。
现在有一个用户键入一下地址（又称URL）：&lt;code class=&quot;highlighter-rouge&quot;&gt;http://myhost.cnMonkey.com&lt;/code&gt; 这时会发生什么呢？
该 访问者指定的DNS服务器（或是他的ISP,互联网服务商, 动态分配给他的)8.8.8.8就会试图为他解释myhost.cnMonkey.com，当然8.8.8.8这台DNS服务器由于没有包含 myhost.cnMonkey.com这条信息，因此无法立即解析，但是通过全球DNS的递归查询后，最终定位到dns.cnMonkey.com这台DNS服务器， dns.cnMonkey.com这台DNS服务器将myhost.cnMonkey.com对应的IP地址1.1.1.1告诉8.8.8.8这台DNS服务器，然有再由 8.8.8.8告诉用户结果。8.8.8.8为了以后加快对myhost.cnMonkey.com这条记录的解析，就将刚才的1.1.1.1结果保留一段时间，这 就是TTL时间，在这段时间内如果用户又有对myhost.cnMonkey.com这条记录的解析请求，它就直接告诉用户1.1.1.1，当TTL到期则又会重复 上面的过程。&lt;/p&gt;

&lt;p&gt;###域名分级&lt;/p&gt;

&lt;p&gt;子域名是个相对的概念，是相对父域名来说的。域名有很多级，中间用点分开。例如中国国家顶级域名CN，所有以 CN 结尾的域名便都是它的子域。例如：www.zzy.cn 便是 zzy.cn 的子域，而 zzy.cn 是 cn 的子域。&lt;/p&gt;

&lt;p&gt;“二级域名”：目前有很多用户认为“二级域名”是自己所注册域名的下一级域名，实际上这里所谓的“二级域名”并非真正的“二级”，而应该称为“次级”(相对次级)&lt;/p&gt;

&lt;p&gt;例如您注册的域名是abc.cn来说：CN为顶级域，abc.cn为二级域，www.abc.cn、mail.abc.cn、help.zzy.cn为三级域。&lt;/p&gt;

&lt;p&gt;还有一些特殊的二级域被用来作顶级域使用，例如：com.cn、net.cn、org.cn、gov.cn（包括地区域名bj.cn、fj.cn等）。那么此时用户所注册的就应该是三级域了，例如114.com.cn。（备注：www.gov.cn实际上是以gov.cn为后缀的www域名，就是说如果您在域名Whois信息查询中输入gov.cn是查询不到注册信息的因为gov.cn是作为顶级域来使用的域名后缀，真正开放注册的是www.gov.cn）。然而当前有很多用户还是习惯地将可以允许用户注册的域名称为顶级域名，而所注册域名的下一级域名称为“二级域名”，其实从严格意义上来讲这是不对的，所以我们前面会说“子域名”、“二级域名”是相对的概念，准确的应该称为“次级域名”。&lt;/p&gt;

&lt;p&gt;###域名购买&lt;/p&gt;

&lt;p&gt;众所周知，域名是要购买的，国内用域名访问主机大概是要备案的，有些麻烦。所以现在很多人从国外的域名注册商那儿买域名，比如goddady。如果是新手想在国外买域名的话，最好准备一张VISA信用卡，并用paypal来支付（可以省手续费）。goddady现在也支持支付宝，支付起来也很方便。&lt;/p&gt;

&lt;p&gt;###绑定域名到GitHub-Page&lt;/p&gt;

&lt;p&gt;其实十分简单，假设我们购买了域名&lt;a href=&quot;coolshell.info&quot;&gt;coolshell.info&lt;/a&gt;，想用coolshell.info访问你的站点&lt;code class=&quot;highlighter-rouge&quot;&gt;http://username.github.com/projectname&lt;/code&gt;，你可以参考这个链接：&lt;a href=&quot;https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/&quot;&gt;Setting up a custom domain with Pages&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在你的域名提供商那边，设置一条A记录：&lt;/p&gt;

&lt;p&gt;colshell.info  204.232.175.78（注意：这个IP难保不会变，所以要及时关注上面这个链接中给出的IP，并及时更新A记录）。下面这个截图是goddady上的A记录配置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/githubpages/build-github-blog-page-03-img0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后在你的gh-pages分支的根目录中创建一个CNAME文件，其中只能有一行，就是coolshell.info，用Git客户端上传更改，大约等十几分钟就能生效了。&lt;/p&gt;

&lt;p&gt;可以先ping一下coolshell.info，如果返回的IP地址更配置的A记录一样的话，说明域名已经注册好了，就等GitHub生效了。不过别急，你还需要把_config.yml中的baseurl设置如下&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;	baseurl : /
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;或者是&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;	baseurl :
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这取决于你的模板如何引用baseurl，总之指向根目录就好了。&lt;/p&gt;

&lt;p&gt;刚开始的时候我比较困惑的是，为什么A记录都指向的是同一个IP，GitHub是如何知道应该返回哪个用户的页面的。其实很简单，秘密就是上面提到的CNAME文件，GitHub应该会缓存所有gh-pages分支中的CNAME文件，用户对域名的请求被定向到GitHub住服务器的IP地址后，再根据用户请求的域名，判断对应哪个gh-pages，而且它会自动带上项目名，所以baseurl需要改为根目录。&lt;/p&gt;

&lt;p&gt;##jekyll的安装&lt;/p&gt;

&lt;p&gt;前几篇介绍了GitHub-Page的基本原理和使用方法，还介绍了如何将购买的域名绑定博客主页。然而，当需要正儿八经的将一个博客构建起来，不仅要知道如何上传我们的文件，还要能够高效的更好的设计博客。因此，必须能够在上传之前在本地完成测试；另一方面，完全靠html来编辑博客，显然工作量太大，随着博客越来越复杂，简直不可能维护，因此，需要用jekyll这个模板引擎来帮忙。本篇先介绍如何搭建一个本地的测试环境。&lt;/p&gt;

&lt;p&gt;###更新&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据网友的反应，需要注意的是Ruby的版本和RubyDevKit的版本要对应，不要装错；&lt;/li&gt;
  &lt;li&gt;另外，目前新版的Ruby自带gem了，所以gem安装可以跳过；&lt;/li&gt;
  &lt;li&gt;由于国内的网络（你们懂的），gem官方的源基本上是没法用了，参考文中的链接，使用淘宝的镜像比较靠谱；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jekyll有一个问题，可能需要修改下面这个文件，否则会出现GBK错误
&lt;code class=&quot;highlighter-rouge&quot;&gt;D:\Ruby193\lib\ruby\gems\1.9.1\gems\jekyll-1.2.1\lib\jekyll\convertible.rb&lt;/code&gt;
将它改成
&lt;code class=&quot;highlighter-rouge&quot;&gt;self.content = File.read(File.join(base, name),:encoding =&amp;gt; &quot;utf-8&quot;)&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;D:\Ruby193\lib\ruby\gems\1.9.1\gems\jekyll-1.2.1\lib\jekyll\tags\include.rb&lt;/code&gt;中的最后几行的地方改成
&lt;code class=&quot;highlighter-rouge&quot;&gt;File.read_with_options(file,:encoding =&amp;gt; &quot;utf-8&quot;)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;最新的jekyll修改了命令行参数，需使用如下命令行 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve --safe --watch&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;jekyll 1.4.3在windows下本地生成的时候可能会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;fileutils.rb:247:in mkdir Invalid argument&#39;&lt;/code&gt;的错误&lt;/li&gt;
  &lt;li&gt;jekyll 1.4.3在–watch参数的情况下可能会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;cannot load such file -- wdm (LoadError)&#39;&lt;/code&gt;的错误，用gem安装wdm就好了： 	gem install wdm&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###Ruby安装&lt;/p&gt;

&lt;p&gt;jekyll本身基于Ruby开发，因此，想要在本地构建一个测试环境需要具有Ruby的开发和运行环境。在windows下，可以使用Rubyinstaller安装&lt;/p&gt;

&lt;p&gt;ruby安装说明：&lt;a href=&quot;http://www.ruby-lang.org/zh_cn/downloads/&quot;&gt;http://www.ruby-lang.org/zh_cn/downloads/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ruby安装下载(windows)：&lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;http://rubyinstaller.org/downloads/&lt;/a&gt;
windows的安装还是一如既往的“无脑”，不多说了。&lt;/p&gt;

&lt;p&gt;如果想要快速体验ruby开发，可以参考：&lt;a href=&quot;https://www.ruby-lang.org/zh_cn/documentation/quickstart/&quot;&gt;20分钟体验 Ruby&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###RubyDevKit安装&lt;/p&gt;

&lt;p&gt;从这个页面下载DevKit：&lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;http://rubyinstaller.org/downloads/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载下来的是一个很有意思的sfx文件，如果你安装有7-zip吧，可以直接双击，它会自解压到你所选择的目录。&lt;/p&gt;

&lt;p&gt;解压完成之后，用cmd进入到刚才解压的目录下，运行下面命令，该命令会生成config.yml。（这种安装方式让我想起了，linux下安装三步走&lt;code class=&quot;highlighter-rouge&quot;&gt;config-&amp;gt;make-&amp;gt;make install中的config&lt;/code&gt;）&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ruby&lt;/span&gt; dk.rb init
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;config.yml文件实际上是检测系统安装的ruby的位置并记录在这个文件中，以便稍后使用。但上面的命令只针对使用rubyinstall安装的ruby有效，如果是其他方式安装的话，需要手动修改config.yml。我生成的config.yml文件内容如下：（注意路径用的是linux的斜杠方向）&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# This configuration file contains the absolute path locations of all&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# installed Rubies to be enhanced to work with the DevKit. This config&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# file is generated by the &#39;ruby dk.rb init&#39; step and may be modified&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# before running the &#39;ruby dk.rb install&#39; step. To include any installed&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Rubies that were not automagically discovered, simply add a line below&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# the triple hyphens with the absolute path to the Ruby root directory.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Example:&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# ---&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# - C:/ruby19trunk&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# - C:/ruby192dev&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
---
- C:/Ruby193&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;最后，执行如下命令，执行安装：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ruby&lt;/span&gt; setup.rb
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;如果没有setup.rb的话，执行：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;	&lt;span class=&quot;nv&quot;&gt;$ruby&lt;/span&gt; dk.rb install
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;###Rubygems&lt;/p&gt;

&lt;p&gt;Rubygems是类似Radhat的RPM、centOS的Yum、Ubuntu的apt-get的应用程序打包部署解决方案。Rubygems本身基于Ruby开发，在Ruby命令行中执行。我们需要它主要是因为jekyll的执行需要依赖很多Ruby应用程序，如果一个个手动安装比较繁琐。jekyll作为一个Ruby的应用，也实现了Rubygems打包标准。只要通过简单的命令就可以自动下载其依赖。&lt;/p&gt;

&lt;p&gt;gems下载地址：&lt;a href=&quot;http://rubyforge.org/frs/?group_id=126&quot;&gt;http://rubyforge.org/frs/?group_id=126&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解压后，用cmd进入到解压后的目录，执行命令即可：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ruby&lt;/span&gt; setup.rb
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;就像yum仓库一样，仓库本身有很多，如果希望加快应用程序的下载速度，特别绕过“天朝”的网络管理制度，可以选择国内的仓库镜像，taobao有一个：&lt;a href=&quot;http://ruby.taobao.org/&quot;&gt;http://ruby.taobao.org/&lt;/a&gt;。配置方法这个链接里面很完全。&lt;/p&gt;

&lt;p&gt;###安装jekyll&lt;/p&gt;

&lt;p&gt;有了上面的基础，安装jekyll就十分轻松了，在此之前，建议国内用户换成淘宝服务器，速度更快：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sudo gem sources --remove http://rubygems.org/
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sudo gem sources -a http://ruby.taobao.org/
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;执行下面gem命令即可全自动搞定：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;	&lt;span class=&quot;nv&quot;&gt;$gem&lt;/span&gt; install jekyll
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;jekyll依赖的组件如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;directory_watcher&lt;/li&gt;
  &lt;li&gt;liquid&lt;/li&gt;
  &lt;li&gt;open4&lt;/li&gt;
  &lt;li&gt;maruku&lt;/li&gt;
  &lt;li&gt;classifier&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;测试jekyll服务&lt;/p&gt;

&lt;p&gt;安装好之后就可以测试我们的环境了。用cmd进入到上一节我们创建的目录，执行下面命令：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$jekyll&lt;/span&gt; --server --safe
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;jekyll此时会在localhost的4000端口监听http请求，用浏览器访问&lt;a href=&quot;http://localhost:4000/index.html&quot;&gt;http://localhost:4000/index.html&lt;/a&gt;，之前的页面出现了！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;
jekyll最新的动态和文档现在可以在&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyllrb&lt;/a&gt;上找到&lt;/p&gt;

&lt;p&gt;##jekyll介绍&lt;/p&gt;

&lt;p&gt;在前几篇中，多多少少对jekyll有所涉及，在这篇中将带读者进一步了解jekyll以及模板引擎liquid。&lt;/p&gt;

&lt;p&gt;jekyll是一个基于ruby开发的，专用于构建静态网站的程序。它能够将一些动态的组件：模板、liquid代码等构建成静态的页面集合，Github-Page全面引入jekyll作为其构建引擎，这也是学习jekyll的主要动力。同时，除了jekyll引擎本身，它还提供一整套功能，比如web server。我们用jekyll –server启动本地调试就是此项功能。读者可能已经发现，在启动server后，之前我们的项目目录下会多出一个_site目录。jekyll默认将转化的静态页面保存在_site目录下，并以某种方式组织。使用jekyll构建博客是十分适合的，因为其内建的对象就是专门为blog而生的，在后面的逐步介绍中读者会体会到这一点。但是需要强调的是，jekyll并不是博客软件，跟workpress之类的完全两码事，它仅仅是个一次性的模板解析引擎，它不能像动态服务端脚本那样处理请求。&lt;/p&gt;

&lt;p&gt;更多关于jekyll请看&lt;a href=&quot;https://github.com/jekyll/jekyll/wiki/Liquid-Extensions&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###jekyll是如何工作的&lt;/p&gt;

&lt;p&gt;在jekyll解析你的网站结构前，需要确保网站目录像下面那样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 20011-10-25-open-source-is-good.html
|   |-- 20011-04-26-hello-world.html
|-- _site
|-- index.html
|-- images
   |-- css
       |-- style.css
   |-- javascripts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;_config.yml：保存配置，该配置将影响jekyll构造网站的各种行为。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;_includes：该目录下的文件可以用来作为公共的内容被其他文章引用，就跟C语言include头文件的机制完全一样，jekyll在解析时会对&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;file.ext&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;标记扩展成对应的在_includes文件夹中的文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;_layouts：该目录下的文件作为主要的模板文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;_posts：文章或网页应当放在这个目录中，但需要注意的是，文章的文件名必须是YYYY-MM-DD-title&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;_site：上面提到过，这是jekyll默认的转化结果存放的目录&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;images：这个目录没有强制的要求，主要目的是存放你的资源文件，图片、样式表、脚本等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###一个例子&lt;/p&gt;

&lt;p&gt;完成一个例子总是最快的入门方式。&lt;/p&gt;

&lt;p&gt;对于基于静态页面的网站，你显然不希望每篇文章都要写html、head等与文章本身无关的重复的东西，那么容易想到的是将这些东西作为模板提取出来，以便复用，_layouts文件夹中的文件可以作为这样的模板。现在我们在_layouts文件夹中创建一个模板文件，default.html：&lt;/p&gt;

&lt;p&gt;default.html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;http-equiv=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/html; charset=UTF-8&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My blog&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Blog Post --&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Title --&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;post-area post&quot;&gt;

 	&lt;div class=&quot;post-list-body&quot;&gt;
        	&lt;div class=&quot;all-posts&quot; post-cate=&quot;All&quot;&gt;
 		&lt;header&gt;
		&lt;h1&gt;
		  谈谈缓存和基本的缓存算法
		  &lt;div class=&quot;post-date&quot;&gt;&lt;a href=&quot;https://github.com/xiangxiaoxiao/xiangxiaoxiao.github.io/edit/master/_posts/2015-02-04-cache.md&quot; target=&quot;_blank&quot;&gt;纠错&lt;/a&gt;&amp;nbsp;&amp;nbsp;
			&lt;span class=&quot;glyphicon glyphicon-time&quot;&gt;&lt;/span&gt;
			04 Feb 2015
		  &lt;/div&gt;
		&lt;/h1&gt;
 		&lt;/header&gt;
		&lt;!-- Author --&gt;
		&lt;hr /&gt;
		 &lt;article&gt;
		&lt;p&gt;很久很久以前，在还没有缓存的时候……用户经常是去请求一个对象，而这个对象是从数据库去取，然后，这个对象变得越来越大，这个用户每次的请求时间也越来越长了，这也把数据库弄得很痛苦，他无时不刻不在工作。所以，这个事情就把用户和数据库弄得很生气，接着就有可能发生下面两件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户很烦，在抱怨，甚至不去用这个应用了（这是大多数情况下都会发生的）&lt;/li&gt;
  &lt;li&gt;数据库为打包回家，离开这个应用，然后，就出现了大麻烦（没地方去存储数据了）（发生在极少数情况下）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;####上帝派来了缓存####&lt;/p&gt;

&lt;p&gt;在几年之后，IBM（60年代）的研究人员引进了一个新概念，它叫“缓存”。&lt;/p&gt;

&lt;p&gt;###什么是缓存？&lt;/p&gt;

&lt;p&gt;通俗来说，缓存是“存贮数据（使用频繁的数据）的临时地方，因为取原始数据的代价太大了，所以我可以取得快一些。”&lt;/p&gt;
&lt;p&gt;我们都听说过线程池、对象池，缓存可以认为是数据的池，这些数据是从数据库里的真实数据复制出来的，并且为了能别取回，被标上了标签（键 ID）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://img2.tuicool.com/QNvequ.jpg&quot;&gt;!&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;命中：&lt;/h4&gt;
&lt;p&gt;当客户发起一个请求（我们说他想要查看一个产品信息），我们的应用接受这个请求，并且如果是在第一次检查缓存的时候，需要去数据库读取产品信息。&lt;/p&gt;
&lt;p&gt;如果在缓存中，一个条目通过一个标记被找到了，这个条目就会被使用、我们就叫它缓存命中。所以，命中率也就不难理解了。&lt;/p&gt;
&lt;h4&gt;Cache Miss：&lt;/h4&gt;
&lt;p&gt;但是这里需要注意两点：&lt;/p&gt;
&lt;p&gt;１. 如果还有缓存的空间，那么，没有命中的对象会被存储到缓存中来。&lt;/p&gt;
&lt;p&gt;２. 如果缓存慢了，而又没有命中缓存，那么就会按照某一种策略，把缓存中的旧对象踢出，而把新的对象加入缓存池。而这些策略统称为*替代策略*（缓存算法），这些策略会决定到底应该提出哪些对象。&lt;/p&gt;
&lt;h4&gt;存储成本：&lt;/h4&gt;
&lt;p&gt;当没有命中时，我们会从数据库取出数据，然后放入缓存。而把这个数据放入缓存所需要的时间和空间，就是存储成本。&lt;/p&gt;
&lt;h4&gt;索引成本：&lt;/h4&gt;
&lt;p&gt;和存储成本相仿。&lt;/p&gt;
&lt;h4&gt;失效：&lt;/h4&gt;
&lt;p&gt;当存在缓存中的数据需要更新时，就意味着缓存中的这个数据失效了。&lt;/p&gt;
&lt;h4&gt;替代策略：&lt;/h4&gt;
&lt;p&gt;当缓存没有命中时，并且缓存容量已经满了，就需要在缓存中踢出一个老的条目，加入一条新的条目，而到底应该踢出什么条目，就由替代策略决定。&lt;/p&gt;
&lt;h4&gt;最优替代策略：&lt;/h4&gt;
&lt;p&gt;最优的替代策略就是想把缓存中最没用的条目给踢出去，但是未来是不能够被预知的，所以这种策略是不可能实现的。但是有很多策略，都是朝着这个目前去努力。&lt;/p&gt;
&lt;h1&gt;缓存算法&lt;/h1&gt;
&lt;p&gt;没有人能说清哪种缓存算法优于其他的缓存算法&lt;/p&gt;
&lt;h4&gt;Least Frequently Used（LFU）：&lt;/h4&gt;
&lt;p&gt;大家好，我是 LFU，我会计算为每个缓存对象计算他们被使用的频率。我会把最不常用的缓存对象踢走。&lt;/p&gt;
&lt;h4&gt;Least Recently User（LRU）：&lt;/h4&gt;
&lt;p&gt;我是 LRU 缓存算法，我把最近最少使用的缓存对象给踢走。&lt;/p&gt;
&lt;p&gt;我总是需要去了解在什么时候，用了哪个缓存对象。如果有人想要了解我为什么总能把最近最少使用的对象踢掉，是非常困难的。&lt;/p&gt;
&lt;p&gt;浏览器就是使用了我（LRU）作为缓存算法。新的对象会被放在缓存的顶部，当缓存达到了容量极限，我会把底部的对象踢走，而技巧就是：我会把最新被访问的缓存对象，放到缓存池的顶部。&lt;/p&gt;
&lt;p&gt;所以，经常被读取的缓存对象就会一直呆在缓存池中。有两种方法可以实现我，array 或者是 linked list。&lt;/p&gt;
&lt;p&gt;我的速度很快，我也可以被数据访问模式适配。我有一个大家庭，他们都可以完善我，甚至做的比我更好（我确实有时会嫉妒，但是没关系）。我家庭的一些成员包括 LRU2 和 2Q，他们就是为了完善 LRU 而存在的。&lt;/p&gt;
&lt;h4&gt;Least Recently Used 2（LRU2）：&lt;/h4&gt;
&lt;p&gt;我是 Least Recently Used 2，有人叫我最近最少使用 twice，我更喜欢这个叫法。我会把被两次访问过的对象放入缓存池，当缓存池满了之后，我会把有两次最少使用的缓存对象踢走。因为需要跟踪对象2次，访问负载就会随着缓存池的增加而增加。如果把我用在大容量的缓存池中，就会有问题。另外，我还需要跟踪那么不在缓存的对象，因为他们还没有被第二次读取。我比LRU好，而且是 adoptive to access 模式 。&lt;/p&gt;
&lt;h4&gt;Two Queues（2Q）：&lt;/h4&gt;
&lt;p&gt;我是 Two Queues；我把被访问的数据放到 LRU 的缓存中，如果这个对象再一次被访问，我就把他转移到第二个、更大的 LRU 缓存。&lt;/p&gt;
&lt;p&gt;我踢走缓存对象是为了保持第一个缓存池是第二个缓存池的1/3。当缓存的访问负载是固定的时候，把 LRU 换成 LRU2，就比增加缓存的容量更好。这种机制使得我比 LRU2 更好，我也是 LRU 家族中的一员，而且是 adoptive to access 模式 。&lt;/p&gt;
&lt;h4&gt;Adaptive Replacement Cache（ARC）：&lt;/h4&gt;
&lt;p&gt;我是 ARC，有人说我是介于 LRU 和 LFU 之间，为了提高效果，我是由2个 LRU 组成，第一个，也就是 L1，包含的条目是最近只被使用过一次的，而第二个 LRU，也就是 L2，包含的是最近被使用过两次的条目。因此， L1 放的是新的对象，而 L2 放的是常用的对象。所以，别人才会认为我是介于 LRU 和 LFU 之间的，不过没关系，我不介意。&lt;/p&gt;
&lt;p&gt;我被认为是性能最好的缓存算法之一，能够自调，并且是低负载的。我也保存着历史对象，这样，我就可以记住那些被移除的对象，同时，也让我可以看到被移除的对象是否可以留下，取而代之的是踢走别的对象。我的记忆力很差，但是我很快，适用性也强。&lt;/p&gt;
&lt;h4&gt;Most Recently Used（MRU）：&lt;/h4&gt;
&lt;p&gt;我是 MRU，和 LRU 是对应的。我会移除最近最多被使用的对象，你一定会问我为什么。好吧，让我告诉你，当一次访问过来的时候，有些事情是无法预测的，并且在缓存系统中找出最少最近使用的对象是一项时间复杂度非常高的运算，这就是为什么我是最好的选择。&lt;/p&gt;
&lt;p&gt;我是数据库内存缓存中是多么的常见！每当一次缓存记录的使用，我会把它放到栈的顶端。当栈满了的时候，你猜怎么着？我会把栈顶的对象给换成新进来的对象！&lt;/p&gt;
&lt;h4&gt;First in First out（FIFO）：&lt;/h4&gt;
&lt;p&gt;我是先进先出，我是一个低负载的算法，并且对缓存对象的管理要求不高。我通过一个队列去跟踪所有的缓存对象，最近最常用的缓存对象放在后面，而更早的缓存对象放在前面，当缓存容量满时，排在前面的缓存对象会被踢走，然后把新的缓存对象加进去。我很快，但是我并不适用。&lt;/p&gt;
&lt;h4&gt;Second Chance：&lt;/h4&gt;
&lt;p&gt;大家好，我是 second chance，我是通过 FIFO 修改而来的，被大家叫做 second chance 缓存算法，我比 FIFO 好的地方是我改善了 FIFO 的成本。我是 FIFO 一样也是在观察队列的前端，但是很FIFO的立刻踢出不同，我会检查即将要被踢出的对象有没有之前被使用过的标志（1一个 bit 表示），没有没有被使用过，我就把他踢出；否则，我会把这个标志位清除，然后把这个缓存对象当做新增缓存对象加入队列。你可以想象就这就像一个环队列。当我再一次在队头碰到这个对象时，由于他已经没有这个标志位了，所以我立刻就把他踢开了。我在速度上比 FIFO 快。&lt;/p&gt;
&lt;h4&gt;CLock：&lt;/h4&gt;
&lt;p&gt;我是 Clock，一个更好的 FIFO，也比 second chance 更好。因为我不会像 second chance 那样把有标志的缓存对象放到队列的尾部，但是也可以达到 second chance 的效果。&lt;/p&gt;
&lt;p&gt;我持有一个装有缓存对象的环形列表，头指针指向列表中最老的缓存对象。当缓存 miss 发生并且没有新的缓存空间时，我会问问指针指向的缓存对象的标志位去决定我应该怎么做。如果标志是0，我会直接用新的缓存对象替代这个缓存对象；如果标志位是1，我会把头指针递增，然后重复这个过程，知道新的缓存对象能够被放入。我比 second chance 更快。&lt;/p&gt;
&lt;h4&gt;Simple time-based：&lt;/h4&gt;
&lt;p&gt;我是 simple time-based 缓存算法，我通过绝对的时间周期去失效那些缓存对象。对于新增的对象，我会保存特定的时间。我很快，但是我并不适用。&lt;/p&gt;
&lt;h4&gt;Extended time-based expiration：&lt;/h4&gt;
&lt;p&gt;我是 extended time-based expiration 缓存算法，我是通过相对时间去失效缓存对象的；对于新增的缓存对象，我会保存特定的时间，比如是每5分钟，每天的12点。&lt;/p&gt;
&lt;h4&gt;Sliding time-based expiration：&lt;/h4&gt;
&lt;p&gt;我是 sliding time-based expiration，与前面不同的是，被我管理的缓存对象的生命起点是在这个缓存的最后被访问时间算起的。我很快，但是我也不太适用。&lt;/p&gt;
&lt;h4&gt;其他的缓存算法还考虑到了下面几点：&lt;/h4&gt;
&lt;p&gt;成本：如果缓存对象有不同的成本，应该把那些难以获得的对象保存下来。&lt;/p&gt;
&lt;p&gt;容量：如果缓存对象有不同的大小，应该把那些大的缓存对象清除，这样就可以让更多的小缓存对象进来了。&lt;/p&gt;
&lt;p&gt;时间：一些缓存还保存着缓存的过期时间。电脑会失效他们，因为他们已经过期了。&lt;/p&gt;
&lt;p&gt;根据缓存对象的大小而不管其他的缓存算法可能是有必要的。&lt;/p&gt;

&lt;p&gt;在这一部分中，我们来看看如何实现这些著名的缓存算法。以下的代码只是示例用的，如果你想自己实现缓存算法，可能自己还得加上一些额外的工作。&lt;/p&gt;

&lt;h4&gt;Random Cache&lt;/h4&gt;
&lt;p&gt;我是随机缓存，我随意的替换缓存实体，没人敢抱怨。你可以说那个被替换的实体很倒霉。通过这些行为，我随意的去处缓存实体。我比 FIFO 机制好，在某些情况下，我甚至比 LRU 好，但是，通常LRU都会比我好。&lt;/p&gt;

&lt;h4&gt;看看缓存元素（缓存实体）&lt;/h4&gt;
&lt;p&gt;public class CacheElement&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;private Object objectValue;&lt;/p&gt;
&lt;p&gt;private Object objectKey;&lt;/p&gt;
&lt;p&gt;private int index;&lt;/p&gt;
&lt;p&gt;private int hitCount; // getters and setters&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这个缓存实体拥有缓存的key和value，这个实体的数据结构会被以下所有缓存算法用到。&lt;/p&gt;
&lt;h4&gt;缓存算法的公用代码&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; 		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// get the entry from the table&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// If we have the entry already in our table&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// then get it and replace only its value.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;err&quot;&gt;｝&lt;/span&gt;
 	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上面的代码会被所有的缓存算法实现用到。这段代码是用来检查缓存元素是否在缓存中了，如果是，我们就替换它，但是如果我们找不到这个 key 对应的缓存，我们会怎么做呢？那我们就来深入的看看会发生什么吧！&lt;/p&gt;

&lt;h4&gt;看看随机缓存的实现&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; 		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// Just replace the value.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// If we haven&#39;t filled the cache yet, put it at the end.&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Otherwise, replace a random entry.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextFloat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4&gt;看看FIFO缓算法的实现&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt; 	 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Objectkey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; 		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 	 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Just replace the value.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 	 &lt;span class=&quot;c1&quot;&gt;// If we haven&#39;t filled the cache yet, put it at the end.&lt;/span&gt;
 	 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Otherwise, replace the current pointer,&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// entry with the new one.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// in order to make Circular FIFO&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4&gt;看看LFU缓存算法的实现&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 	 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; 		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Just replace the value.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeLfuElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeLfuElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getElementsFromTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leastElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leastHit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leastElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;leastHit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 	 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;最重点的代码，就应该是 leastHit 这个方法，这段代码就是把&lt;/p&gt;
&lt;p&gt;hitCount 最低的元素找出来，然后删除，给新进的缓存元素留位置。&lt;/p&gt;
&lt;h4&gt;看看LRU缓存算法实现&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// Only the head has a prev entry that is an invalid index&lt;/span&gt;
 	 &lt;span class=&quot;c1&quot;&gt;// so we don&#39;t check.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// Make sure index is valid. If it isn&#39;t, we&#39;re at the tail&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// and don&#39;t set prev[next].&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 	 &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; 		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
   	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Just replace the value, but move it to the front.&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// If we haven&#39;t filled the cache yet, place in next available&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// spot and move to front.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_numEntries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// We replace the tail of the list.&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这段代码的逻辑如 LRU算法 的描述一样，把再次用到的缓存提取到最前面，而每次删除的都是最后面的元素。&lt;/p&gt;
&lt;h4&gt;结论&lt;/h4&gt;
&lt;p&gt;我们已经看到 LFU缓存算法 和 LRU缓存算法的实现方式，至于如何实现，采用数组还是 LinkedHashMap，都由你决定，不够我一般是小的缓存容量用数组，大的用 LinkedHashMap。&lt;/p&gt;

&lt;p3&gt;几个著名Java开源缓存框架介绍&lt;/p3&gt;
&lt;p&gt;1.OSCache&lt;/p&gt;

&lt;p&gt;　　OSCache是个一个广泛采用的高性能的J2EE缓存框架，OSCache能用于任何Java应用程序的普通的缓存解决方案。 OSCache有以下特点：缓存任何对象，你可以不受限制的缓存部分jsp页面或HTTP请求，任何java对象都可以缓存。拥有全面的API–OSCache API给你全面的程序来控制所有的OSCache特性。永久缓存–缓存能随意的写入硬盘，因此允许昂贵的创建(expensive-to-create)数据来保持缓存，甚至能让应用重启。支持集群–集群缓存数据能被单个的进行参数配置，不需要修改代码。缓存记录的过期–你可以有最大限度的控制缓存对象的过期，包括可插入式的刷新策略(如果默认性能不需要时)。&lt;/p&gt;

&lt;p&gt;2.Java Caching system&lt;/p&gt;

&lt;p&gt;　　JSC(Java Caching system)是一个用分布式的缓存系统，是基于服务器的java应用程序。它是通过提供管理各种动态缓存数据来加速动态web应用。 JCS和其他缓存系统一样，也是一个用于高速读取，低速写入的应用程序。动态内容和报表系统能够获得更好的性能。如果一个网站，有重复的网站结构，使用间歇性更新方式的数据库(而不是连续不断的更新数据库)，被重复搜索出相同结果的，就能够通过执行缓存方式改进其性能和伸缩性。&lt;/p&gt;

&lt;p&gt;3.EHCache&lt;/p&gt;

&lt;p&gt;　　EHCache 是一个纯java的在进程中的缓存，它具有以下特性：快速，简单，为Hibernate2.1充当可插入的缓存，最小的依赖性，全面的文档和测试。&lt;/p&gt;

&lt;p&gt;4.JCache&lt;/p&gt;

&lt;p&gt;　　JCache是个开源程序，正在努力成为JSR-107开源规范，JSR-107规范已经很多年没改变了。这个版本仍然是构建在最初的功能定义上。&lt;/p&gt;

&lt;p&gt;5.ShiftOne&lt;/p&gt;

&lt;p&gt;　　ShiftOne Java Object Cache是一个执行一系列严格的对象缓存策略的Java lib，就像一个轻量级的配置缓存工作状态的框架。&lt;/p&gt;

&lt;p&gt;6.SwarmCache&lt;/p&gt;

&lt;p&gt;　　SwarmCache是一个简单且有效的分布式缓存，它使用IP multicast与同一个局域网的其他主机进行通讯，是特别为集群和数据驱动web应用程序而设计的。SwarmCache能够让典型的读操作大大超过写操作的这类应用提供更好的性能支持。 SwarmCache使用JavaGroups来管理从属关系和分布式缓存的通讯。&lt;/p&gt;

&lt;p&gt;7.TreeCache / JBossCache&lt;/p&gt;

&lt;p&gt;　　JBossCache是一个复制的事务处理缓存，它允许你缓存企业级应用数据来更好的改善性能。缓存数据被自动复制，让你轻松进行JBoss服务器之间的集群工作。JBossCache能够通过JBoss应用服务或其他J2EE容器来运行一个MBean服务，当然，它也能独立运行。 JBossCache包括两个模块：TreeCache和TreeCacheAOP。 TreeCache –是一个树形结构复制的事务处理缓存。TreeCacheAOP –是一个“面向对象”缓存，它使用AOP来动态管理POJO(Plain Old Java Objects) 注：AOP是OOP的延续，是Aspect Oriented Programming的缩写，意思是面向方面编程。&lt;/p&gt;

&lt;p&gt;8.WhirlyCache&lt;/p&gt;

&lt;p&gt;　　Whirlycache是一个快速的、可配置的、存在于内存中的对象的缓存。它能够通过缓存对象来加快网站或应用程序的速度，否则就必须通过查询数据库或其他代价较高的处理程序来建立。&lt;/p&gt;

		  &lt;/article&gt;
		&lt;hr /&gt;
	&lt;br /&gt;
        &lt;p&gt;
          本作品由 &lt;a href=&quot;mailto:362471259@qq.com&quot;&gt;Li Ming&lt;/a&gt; 创作，采用
          &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot; title=&quot;查看协议详细信息&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 3.0 许可协议&lt;/a&gt;
          进行许可。
        &lt;/p&gt;
	&lt;div style=&quot;margin-top:10px;margin-bottom:10px&quot;&gt;
	  
	  &lt;span class=&quot;next&quot;&gt;
	    上篇：
	    &lt;a href=&quot;/blog/2014/12/skip-list.html&quot;&gt;
	      skip list跳跃表实现
	    &lt;/a&gt;
	  &lt;/span&gt;
	   
	  
	  &lt;span class=&quot;prev&quot;&gt;
	    下篇：
	    &lt;a href=&quot;/blog/2015/03/github-pages-blog.html&quot;&gt;
	      利用github-pages建立个人博客
	    &lt;/a&gt;
	  &lt;/span&gt;
	  
	&lt;/div&gt;
	&lt;/div&gt;
	
        
	&lt;div post-cate=&quot;java&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2015/02/cache.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;谈谈缓存和基本的缓存算法&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Feb 4, 2015&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/08/78-golden-rules-of-the-java-programming.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;java编程的78条黄金法则&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Aug 16, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/06/26-methods-to-improve-java-performance.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;Java编程Tips&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Jun 18, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;c&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/08/libevent.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;处理并发之二：libevent的eventbuffer&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Aug 24, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/08/linux-epoll.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;处理并发之一：LINUX Epoll机制介绍&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Aug 23, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/07/c-advaced-programming.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;C语言高级编程指南&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Jul 5, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;programming&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2015/03/github-pages-blog.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;利用github-pages建立个人博客&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Mar 1, 2015&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/07/qualified-programmer-should-read-what-books.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;一个合格的程序员应该读过哪些书&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Jul 15, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/07/c-advaced-programming.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;C语言高级编程指南&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Jul 5, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;jekyll&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/07/use-jekyll-build-blog-on-github.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;使用jekyll在Github上搭建博客&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Jul 15, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/07/markdown-syntax.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;Markdown 语法 (简体中文版)&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Jul 11, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/07/markdown-basics.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;markdown 快速入门&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Jul 10, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;other&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2015/03/vim-plugins.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;一些强大的Vim插件&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Mar 20, 2015&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2015/03/github-pages-blog.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;利用github-pages建立个人博客&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Mar 1, 2015&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/07/qualified-programmer-should-read-what-books.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;一个合格的程序员应该读过哪些书&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Jul 15, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;reprints&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/08/78-golden-rules-of-the-java-programming.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;java编程的78条黄金法则&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Aug 16, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/07/use-jekyll-build-blog-on-github.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;使用jekyll在Github上搭建博客&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Jul 15, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/07/qualified-programmer-should-read-what-books.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;一个合格的程序员应该读过哪些书&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Jul 15, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;web&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/10/xmpp-analise.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;XMPP协议分析-具体分析&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Oct 31, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/10/how-to-use-smack.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;Smack开发手册&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Oct 30, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/10/xmpp.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;XMPP协议分析-原理&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Oct 28, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/10/how-http-works.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;当我们打开网页时发生了什么&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Oct 11, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;book&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/11/how-to-evaluate-the-hackers-and-painters.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;如何评价『黑客与画家』&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Nov 1, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;algorithm&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/12/skip-list.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;skip list跳跃表实现&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Dec 18, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/11/graph.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;计算机算法--图算法介绍&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Nov 29, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2014/11/leveldb.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;leveldb原理剖析&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Nov 18, 2014&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;Latex&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2015/08/latex-fonts-settings.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;Latex中英文环境设置&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Aug 22, 2015&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;Unix/Linux&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2016/02/baidu-spider-forbidden.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;解决百度爬虫无法抓取github pages&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Feb 18, 2016&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2015/08/linux-zsh.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;Zsh-Linux下最好的Shell简介&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Aug 23, 2015&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	&lt;div post-cate=&quot;Git&quot;&gt;
          &lt;ul class=&quot;posts&quot;&gt;
            
              
                
              
            
              
                
		&lt;li&gt;
                  &lt;a href=&quot;/blog/2016/02/git-guide.html&quot; class=&quot;post-list-item&quot;&gt;
                    &lt;h2&gt;Git操作手册|命令速查表&lt;/h2&gt;
                    &lt;span class=&quot;date&quot;&gt;Feb 20, 2016&lt;/span&gt;
                  &lt;/a&gt;
		&lt;/li&gt;
                
              
            
          &lt;/ul&gt;
	&lt;/div&gt;
        
	 &lt;/div&gt;

&lt;/div&gt;


&lt;!-- Blog Comments --&gt;
&lt;div class=&quot;media&quot;&gt;
  &lt;!-- UY BEGIN 
&lt;div id=&quot;uyan_frame&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v2.uyan.cc/code/uyan.js?uid=2023801&quot;&gt;&lt;/script&gt;
UY END --&gt;

&lt;!-- 多说评论框 start --&gt;
  &lt;div class=&quot;post-comment&quot;&gt;
            &lt;span&gt;Comments&lt;/span&gt;
	&lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;/blog/2015/02/cache&quot; data-title=&quot;谈谈缓存和基本的缓存算法&quot; data-url=&quot;LippiOuYang.github.io/blog/2015/02/cache.html&quot;&gt;
	&lt;/div&gt;
 &lt;/div&gt;
&lt;!-- 多说评论框 end --&gt;
&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var duoshuoQuery = {short_name:&quot;lippiouyang&quot;};
	(function() {
		var ds = document.createElement(&#39;script&#39;);
		ds.type = &#39;text/javascript&#39;;ds.async = true;
		ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;;
		ds.charset = &#39;UTF-8&#39;;
		(document.getElementsByTagName(&#39;head&#39;)[0] 
		 || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds);
	})();
	&lt;/script&gt;
&lt;!-- 多说公共JS代码 end --&gt;
 
&lt;/div&gt; 
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;default.html包含了每个html都需要的一些标记，以及一个个liquid标记。&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;是liquid中用来表示“内容”的标记，其中的对象在解析时会被替换成文件到页面中&lt;/p&gt;

&lt;p&gt;content：表示在这里的地方用子页面的内容替换。&lt;/p&gt;

&lt;p&gt;现在我们来实现一个主页，在根目录下，创建一个index.html&lt;/p&gt;

&lt;p&gt;index.html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: default
---
&amp;lt;h1&amp;gt;Hello jekyll&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;This is the index page&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了普通的html标记外，开头这一段称为YAML格式，以一行“—”开头，一行“—”结尾，在虚线的中间以key-value的形式对一些全局变量进行赋值。&lt;/p&gt;

&lt;p&gt;layout变量表示该文章应当使用_layouts/default这个文件作为父模板，并将index.html中的内容替换父模板中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;标记。&lt;/p&gt;

&lt;p&gt;在根目录中启动jekyll –server，并访问http://localhost:4000/index.html，你将得到下面页面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/githubpages/build-github-blog-page-05-img0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该页面的Html源码如下，可以看到，index.html中的内容替换了default.html中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;http-equiv=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/html; charset=UTF-8&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My blog&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Hello jekyll&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This is the index page&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在请观察一下_site中的index.html，就是上面的Html代码！OK，现在你明白jekyll的工作方式了吧，它仅仅一次性的完成静态页面的转化，其余的事情全都交给普通的web server了！&lt;/p&gt;

&lt;p&gt;需要注意的是，如果你失败了，请确保你的文件都是UTF-8 without BOM的格式。&lt;/p&gt;

&lt;p&gt;在windows中，为了甄别UTF-8编码格式的文本文件，默认会在文件头插入两个字节的标识，被称为BOM。事实证明这是个“歪门邪道”，jekyll不识别这种特殊的标记，所以可以使用Notepad++或其他的工具将UTF-8编码文件开头的BOM去掉。&lt;/p&gt;

&lt;p&gt;###第一篇文章&lt;/p&gt;

&lt;p&gt;现在我们来创建一篇博客文章，并在index.html页面添加文章的链接。&lt;/p&gt;

&lt;p&gt;在 _posts目录下创建2014-06-21-first-post.html&lt;/p&gt;

&lt;p&gt;2014-06-21-first-post.html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: default
title: my first post
---
&amp;lt;h1&amp;gt;利用github-pages建立个人博客&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;This is my first post.Click the link below to go back to index:&amp;lt;/p&amp;gt;
&amp;lt;a href=&quot;/index.html&quot;&amp;gt;Go back&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改index.html&lt;/p&gt;

&lt;p&gt;index.html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: default
---
&amp;lt;h1&amp;gt;Hello jekyll&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;This is the index page&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;My post list:&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/githubpages/build-github-blog-page-05-img1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个是略微复杂的例子，这里涉及到两个主要的对象&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;site：全局站点对象。比如site.posts返回当前站点所有在_post目录下的文章，上面的例子结合for循环来罗列所有的文章&lt;/li&gt;
  &lt;li&gt;page：文章对象。比如page.url将返回page对象的url，上面的例子用该对象和属性返回了文章的链接
另外要补充的是site.baseurl，该值就是我们在_config.yml中配置的baseurl啦！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些对象被称为“模板数据API”，更多API文档请参见&lt;a href=&quot;http://jekyllbootstrap.com/api/template-data-api.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###liquid&lt;/p&gt;

&lt;p&gt;liquid是jekyll底层用于解析的引擎，我们用到的&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;亦或是&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;标记其实是靠liquid去解析的。本节将详细介绍liquid的使用。&lt;/p&gt;

&lt;p&gt;liquid包含两种标记，理解他们的机理是十分重要的：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;：输入标记，其中的内容将被文本输出
&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;：操作标记，通常包含控制流代码
例如：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;     
       Sorry, you are too young
     
     
     
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;另外liquid还包含一种叫filter的机制。这是种对输出标记的扩展，通过它可以对输出标记中的内容进行更细致的处理，例如：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;     Hello TOBI
     Hello tobi has 4 letters!
     Hello 2016 Jul
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;返回字符串大写的结果：TOBI
返回字符串的长度：4
将当前时间格式化输出
liquid内置了一些filter，并且该机制可以被扩展，jekyll便扩展了liquid的filter。&lt;/p&gt;

&lt;p&gt;更多关于liquid的使用方法，请参见&lt;a href=&quot;https://github.com/Shopify/liquid/wiki/Liquid-for-Designers&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更多关于jekyll对liquid的扩展，请参见&lt;a href=&quot;https://github.com/Shopify/liquid/wiki/Liquid-for-Designers&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;##样式、分类、标签&lt;/p&gt;

&lt;p&gt;在前一篇中我们实际使用jekyll做了一个略微“复杂”的模板。并用它生成了站点。但是这样的blog显然太粗糙了，别说不能吸引别人了，自己都看不下去啊。作为自己的“门户”，当然要把美化工作放在第一位啦。&lt;/p&gt;

&lt;p&gt;网站的美观十分重要，这当然要依靠CSS咯。因为完全基于静态页面，所以没有现成的动态模板可以使用，我们只能手写CSS了，这里不介绍CSS了，因为这是设计师的范畴了，屌丝程序员搞不来了。我的blog的样式是从网上找过来改的。&lt;/p&gt;

&lt;p&gt;从功能的角度blog除了文章以外，对文章的分类、标签、归档都是主流的功能。&lt;/p&gt;

&lt;p&gt;分类和标签功能是jekyll的yaml-format的内置功能，在每篇文章上方可以设置：这里需要注意的是如果多个分类或者tag的话，用逗号分隔，并且要紧跟一个空格。分类可以任意添加，Jekyll在解析网站的时候会统计所有的分类，并放到site.categories中；换句话说，不能脱离文章而设置分类。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: default
title: Title
description: 这里的description是自定义属性。
categories: [web-build]
tags: [github-page, jekyll, liquid]
---
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是本站罗列分类的代码，供大家参考&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div id=&quot;categories-3&quot; class=&quot;left&quot;&amp;gt;
     &amp;lt;h3&amp;gt;Categories&amp;lt;/h3&amp;gt;
     &amp;lt;ul&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/java.html&quot;&amp;gt;java&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/c.html&quot;&amp;gt;c&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/programming.html&quot;&amp;gt;programming&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/jekyll.html&quot;&amp;gt;jekyll&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/other.html&quot;&amp;gt;other&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/reprints.html&quot;&amp;gt;reprints&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/web.html&quot;&amp;gt;web&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/book.html&quot;&amp;gt;book&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/algorithm.html&quot;&amp;gt;algorithm&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/Latex.html&quot;&amp;gt;Latex&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/Unix/Linux.html&quot;&amp;gt;Unix/Linux&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
         &amp;lt;li class=&quot;cat-item cat-item-6&quot;&amp;gt;
         	&amp;lt;a href=&quot;/categories/Git.html&quot;&amp;gt;Git&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意到分类的url链接，这里的categories目录以及其中的html不会自动生成，需要手动添加的，也就是说每增加一个分类，都需要在categories下添加一个该分类的html。当然你可以选择其他目录，甚至考虑其他解决方案，不过我还没想到更简单的方法。Tag的处理方式类似，这里就省略了。&lt;/p&gt;

&lt;p&gt;推荐大家下载jekyll原作者推荐的简单例子来学习：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$git clone https://github.com/plusjade/jekyll-bootstrap.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下载的目录里面是一个完整的网站，可以使用我们本地的jekyll –server启动。另外，作者的网站：&lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;http://jekyllbootstrap.com/
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###代码高亮&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&quot;http://jekyllrb.com/docs/templates/&quot;&gt;Jekyll官网文档&lt;/a&gt;里&lt;em&gt;Code snippet highlighting&lt;/em&gt;一节。玩颜色魔法的大魔术师是&lt;a href=&quot;http://pygments.org/&quot;&gt;Pygments&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;###安装Python Pygments&lt;/p&gt;

&lt;p&gt;Ubtuntu下：sudo apt-get install python-pygments&lt;/p&gt;

&lt;p&gt;###设置代码高亮的样式&lt;/p&gt;

&lt;p&gt;通过下面的命令可以查看当前支持的样式
	from pygments.styles import STYLE_MAP
	STYLE_MAP.keys()
输出：
    	[‘monokai’, ‘manni’, ‘rrt’, ‘perldoc’, ‘borland’, ‘colorful’, 		‘default’, ‘murphy’, ‘vs’, ‘trac’, ‘tango’, ‘fruity’, ‘autumn’, 	‘bw’, ‘emacs’, ‘vim’, ‘pastie’, ‘friendly’, ‘native’]&lt;/p&gt;

&lt;p&gt;###生成指定样式的css文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pygmentize -S native -f html &amp;gt; pygments.css
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将生成的css文件拷贝到主题的css目录下，如：&lt;/p&gt;

   	 %github pages project folder%\assets\themes\twitter\css\

&lt;p&gt;引入default.html中引入css文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// default目录如
	%github pages project folder%\includes\themes\twitter\

// 引入如下代码
	&amp;lt;link href=&#39;/css/pygments.css&#39; rel=&quot;stylesheet&quot; media=&quot;all&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在文章中高亮代码:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HelloWorld&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
       	 &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
    	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 

	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;###给文章添加目录&lt;/p&gt;

&lt;p&gt;如你所见，我的这个博客里，稍长点的文章，都会生成目录树（Table of Content），并且配合有Bootstrap的&lt;a href=&quot;http://www.zfanw.com/blog/twitter-bootstrap-affix-js.html&quot;&gt;affix&lt;/a&gt;、&lt;a href=&quot;http://www.zfanw.com/blog/bootstrap-scrollspy.html&quot;&gt;ScrollSpy&lt;/a&gt; 效果。同样地，在Jekyll构建的静态博客上，我一样想生成目录树。
Jekyll的Plugins页面中有提到一个插件 &lt;a href=&quot;https://github.com/dafi/jekyll-toc-generator&quot;&gt;jekyll-toc-generator&lt;/a&gt;，但其实没有必要使用插件，因为 Jekyll 的 Markdown 渲染器 &lt;a href=&quot;http://kramdown.gettalong.org/converter/html.html#toc&quot;&gt;kramdown&lt;/a&gt; 已经具备这个功能。我们只需要启用它即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启用 kramdown&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;打开 _config.yml 文件，确保以下一行存在：
	markdown: kramdown&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生成 TOC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下来是在文章中标识 toc 的生成位置：
	* 目录
	{:toc}
	# 陈三
	## 陈三的博客&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;请注意，&lt;code class=&quot;highlighter-rouge&quot;&gt;* 目录&lt;/code&gt;这一行是必需的，它表示目录树列表，至于星号后面写什么请随意&lt;/li&gt;
  &lt;li&gt;如果要把某标题从目录树中排除，则在该标题的下一行写上 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:.no_toc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;目录深度可以通过 config.yml 文件中添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;toc_levels&lt;/code&gt; 选项来定制，默认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;1..6&lt;/code&gt;，表示标题一至标题六全部渲染&lt;/li&gt;
  &lt;li&gt;默认生成的目录列表会添加 id 值 &lt;code class=&quot;highlighter-rouge&quot;&gt;markdown-toc&lt;/code&gt;，我们可以自定义 id 值，比如 {:toc #chen}，生成的目录列表添加的 id 将会是 chen。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###评论功能&lt;/p&gt;

&lt;p&gt;静态的网站不可能自己存放评论，于是只能考虑外挂评论了，查了一下比较靠谱和广泛的就是DISQUS了;
Disqus是一个社会化的评论解决方案，请允许我使用这个烂透了的词，调用它的接口非常简单，在自己的页面加载他的一段JS代码即可，如果别人注册了Disqus，那么就可以方便的留言，交流，一处登录，处处方便，而且Disqus也提供了一些spam等策略，不用自己操心了，并且可以和一些现有的博客系统很好的转换对接。越来越多的网站开始使用Disqus的服务了，这是一个非常不错的趋势，Jekyll配合&lt;a href=&quot;http://disqus.com&quot; title=&quot;Disqus&quot;&gt;Disqus&lt;/a&gt;实在是完美了。我别无所求了。&lt;/p&gt;

&lt;p&gt;点击&lt;img src=&quot;/images/images/githubpages/build-github-blog-page-06-img0.png&quot; alt=&quot;&quot; /&gt;，在下面的页面中填写相关的信息，注意先在右侧注册登录信息，然后再在左侧增加一个站点：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/githubpages/build-github-blog-page-06-img1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;填写完成后点击“Continue”，在接下来的页面中选择Universal Code，然后根据提示完成接下来的操作，后面的操作就十分简单了：主要就是把产生的脚本文件复制到你的站点页面中即可。&lt;/p&gt;

&lt;p&gt;DISQUS还有一个Dashboard，可以用来管理评论，这里就不再详述了。最后的效果就是本blog文章下方的评论咯，还是挺好看的，国内的还有个多说的评论引擎，支持国内的各大网站帐号。&lt;/p&gt;

&lt;p&gt;###站内搜索&lt;/p&gt;

&lt;p&gt;blog当然不能缺少站内搜索功能。主流的站内搜索都是主流的搜索引擎提供的。作为一个google控，当然必须选择google啊。当然你必须拥有一个google帐号。&lt;/p&gt;

&lt;p&gt;google的站内搜索叫：custome search engine：&lt;a href=&quot;http://www.google.com/cse&quot;&gt;http://www.google.com/cse&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;创建一个自定义搜索与添加评论类似只要三步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;填写自定义搜索的名字、描述、语言、站点信息，这些信息中唯一需要注意的是站点信息，建议使用mydomain.com作为搜索范围，因为这样的话，会自动转化成&lt;em&gt;.mydomain.com/&lt;/em&gt;，能包含全站的内容&lt;/li&gt;
  &lt;li&gt;选择样式和尝试搜索。尝试搜索有时不能成功，但是不要紧&lt;/li&gt;
  &lt;li&gt;将生成脚本写到网页中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这时，可能搜索功能仍然无法使用，尤其是你的网站没有什么名气，也没有什么外链。因为google的爬虫不可能很快的抓到你的网站。但这里有个技巧可以让你的网站立刻被google收录（姑且不论排名），那就是google的Webmaster Tools工具，该工具是免费的，而且还集成了站点流量统计功能，十分强大。&lt;/p&gt;

&lt;p&gt;进入地址：&lt;a href=&quot;https://www.google.com/webmasters/tools/home&quot;&gt;https://www.google.com/webmasters/tools/home&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/githubpages/build-github-blog-page-06-img5.png&quot; alt=&quot;&quot; /&gt;
它会要你认证你对网站的所有权，下载一个HTML文件，把它上传到你的网站上，
设置完成之后基本上立刻就生效了，无需等待一天。&lt;/p&gt;

&lt;p&gt;认证成功后，进入&lt;a href=&quot;http://www.xml-sitemaps.com/&quot;&gt;sitemaps网站&lt;/a&gt;,在下面填入你的网站后点击start，
&lt;img src=&quot;/images/images/githubpages/sitemap.jpg&quot; alt=&quot;&quot; /&gt;
接下来下载sitemap文件，把它上传到你的域名根目录，
打开Optimization-&amp;gt;Sitemaps，点击Add/TEST SITEMAP，输入指向你的站点的sitemap地址，本博客的sitemap是：&lt;a href=&quot;http://coolshell.info/sitemap.xml&quot;&gt;http://coolshell.info/sitemap.xml&lt;/a&gt;,过几分钟就看到下面的结果：
！&lt;a href=&quot;/images/images/githubpages/sitemap2.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;sitemap是网站所有链接的集合，最简单的sitemap可以是一个文本文件，其中只存放你网站的所有可用资源的链接，这有利于搜索引擎收录你的网站内容。复杂的sitemap还可以利用sitemap的专用格式来标注资源的形式，更多关于sitemap可以参考：http://www.sitemaps.org/
完成站点认证和sitemap测试后，我们回到自定义搜索的页面，进入到control panel-&amp;gt;Indexing，在其中使用sitemap来迫使google索引你的网站。这样，你的网站就算被google收录了。&lt;/p&gt;

&lt;p&gt;至于我们的站内搜索应该是可以用的了，试试本站点上方的搜索就知道啦～&lt;/p&gt;

&lt;p&gt;###站点统计&lt;/p&gt;

&lt;p&gt;这里介绍的站点统计是google的analytics，analytics的使用十分简单，同样的原理，利用注入脚本来实现流量统计的外挂，统计功能十分强大，谁用谁知道。这里就不再唠叨了。。&lt;/p&gt;

&lt;p&gt;##GoDaddy &amp;amp; DNSPod&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://godaddy.com&quot; title=&quot;Godaddy&quot;&gt;GoDaddy&lt;/a&gt;是一家非常不错的域名注册商，良好的用户体验，飞快的生效速度，给力的优惠码，也支持支付宝，永远不用担心国内那些流氓厂商的流氓行为，注册了域名，就可以放心不会被别人抢走。在Godaddy注册域名是一件很简单的事情，按照提示走就完全没有问题，唯一需要动脑筋的可能是，你要想一个既有个人标识，又没有被别人注册的域名了。&lt;/p&gt;

&lt;p&gt;Godaddy一切都很完美，直到遇到了GFW，原因你肯定懂。前段时间推上风传Godaddy的DNS服务器被墙，导致域名不能解析，看起来好像自己的站被墙了一样，这个确实是个闹心的事情，还好国内有DNS服务的替代产品，而且做得还非常的不错，也是免费的，功能强大，速度快，不用担心被和谐，所以隆重推荐&lt;a href=&quot;http://dnspod.cn&quot; title=&quot;DNSPod&quot;&gt;DNSPod&lt;/a&gt;给大家，可以试用一下，把DNS服务迁移到DNSPod来，解决后顾之忧，配置比较简单，不懂的可以等我后面的博客啦，哈。&lt;/p&gt;

&lt;p&gt;##GitHub &amp;amp; Jekyll&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com&quot; title=&quot;Github:social coding&quot;&gt;GitHub&lt;/a&gt;是一个非常优秀的产品，爆发式的增长，各大优质开源软件的蜂涌而至，只能说明人们太需要他了。&lt;strong&gt;Social Coding&lt;/strong&gt;是他的Slogan，产品的设计确实解决了很多代码交流的难题，让世界更平，让交流更畅，关于Git的学习，大家可以移步这里&lt;a href=&quot;http://progit.org/book/zh/&quot; title=&quot;Pro Git&quot;&gt;Pro Git中文版&lt;/a&gt;，这也是一个本身就在Github维护的一个项目，高质量的翻译了Git入门书，讲解详细，是学习Git的好资料。&lt;/p&gt;

&lt;p&gt;GitHub是一个伟大的产品，&lt;a href=&quot;http://pages.github.com&quot; title=&quot;GitHub Pages&quot;&gt;GitHub Pages&lt;/a&gt;是他伟大的一部分，GitHub Pages基于&lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt;博客引擎，当我深入的研究了他之后，我深深的想给Jekyll的作者一个拥抱，列举一下Jekyll的优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以单独放在自己的服务器上，他也是GitHub Pages的基础，质量可靠&lt;/li&gt;
  &lt;li&gt;将博客最重要的功能抽取出来，去除了&lt;a href=&quot;http://wordpress.org&quot; title=&quot;WordPress&quot;&gt;WordPress&lt;/a&gt;的复杂、烦躁的东西，一切都是清晰可控的&lt;/li&gt;
  &lt;li&gt;可以方便的使用&lt;a href=&quot;http://markdown.tw/&quot; title=&quot;Markdown语法&quot;&gt;Markdown&lt;/a&gt;等其他标记语言&lt;/li&gt;
&lt;/ul&gt;
&lt;li&gt;清晰、简洁的文件组织，完美的永久链接方案，既漂亮、又可定制&lt;/li&gt;
&lt;li&gt;博客静态化，速度快&lt;/li&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt;是完美的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;写到这里，基本的点已经介绍完毕，现在介绍下怎么获取别人的博客模板来建立自己的博客。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;获取并修改别人的博客&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll官方建立了一个&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/sites&quot;&gt;页面&lt;/a&gt;，里面有许多的模板可供参考。接下来我们就要奉行“拿来主义”了，将别人的模板为我们所用。&lt;/p&gt;

&lt;p&gt;我自己用了Yukang’s Page&amp;lt;/a&amp;gt;，他采用了一个叫做&lt;a href=&quot;http://themes.jekyllbootstrap.com/preview/twitter/&quot;&gt;twitter&lt;/a&gt;的Jekyll Bootstrap的模板。下面假设你已经安装了git，我们把他人的网站代码clone下来，为了举例方便，还是选取了Yukang’s Page：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/chenyukang/chenyukang.github.com.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后删去别人的.git文件夹：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm -rf .git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们参考&lt;a href=&quot;http://jekyllrb.com/docs/structure/&quot;&gt;jekyll的文件目录&lt;/a&gt;，可以把他人的博客删去，并且做一些小的调整。接下来，我们把改头换面的博客上传到自己的GitHub帐号中去。一般情况下，假设你的帐号名是USERNAME，你需要建一个名为USERNAME.github.io的帐号，分支为master。这样，在你将本地的网站push上去之后，不到10分钟，访问USERNAME.github.io，就可以看到你新鲜出炉的网站了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init
git add -A
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/USERNAME/USERNAME.github.io.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git博大精深，我还没有熟练掌握。具体的命令可以参考下面一些参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;入门：&lt;a href=&quot;http://rogerdudler.github.io/git-guide/index.zh.html&quot;&gt;git - 简易指南&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进阶：&lt;a href=&quot;http://think-like-a-git.net/epic.html&quot;&gt;Think Like (a) Git&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;参考图解：&lt;a href=&quot;http://marklodato.github.io/visual-git-guide/index-en.html&quot;&gt;A Visual Git Reference&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你想要在push之前就在本地预览一下网站，可以使用
&lt;code&gt;jekyll serve --watch&lt;/code&gt;
命令。默认设置下，可以在浏览器中访问localhost:4000预览。详细情况请&lt;a href=&quot;http://jekyllrb.com/docs/usage/&quot;&gt;点击这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;那么，我们如何撰写新的博客呢？下面，我们隆重推出Markdown。&lt;/p&gt;

&lt;p&gt;##Markdown语法&lt;/p&gt;

&lt;p&gt;根据&lt;a href=&quot;http://zh.wikipedia.org/zh-cn/Markdown&quot;&gt;维基百科上的介绍&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;想到&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8&quot;&gt;Aaron Swartz&lt;/a&gt;已经故去，不禁一阵伤感。&lt;/p&gt;

&lt;p&gt;Markdown的介绍有许多，个人推荐：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;入门：&lt;a href=&quot;http://jianshu.io/p/q81RER&quot;&gt;献给写作者的 Markdown 新手指南&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一份入门文档：&lt;a href=&quot;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&quot;&gt;Markdown Cheatsheet&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进阶：&lt;a href=&quot;http://wowubuntu.com/markdown/&quot;&gt;Markdown 语法说明 (简体中文版) &lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kramdown使用心得：&lt;a href=&quot;http://mindspill.net/computing/web-development-notes/kramdown-notes/&quot;&gt;Kramdown notes&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;备注：如何在Markdown中写注释呢？&lt;a href=&quot;https://twitter.com/denialduan/status/180532937358454784&quot;&gt;这里&lt;/a&gt;提供了最原始的一种解决方法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;看来在Markdown文件里写注释的唯一方法就是用&amp;lt;!– –&amp;gt;了，好吧。&lt;/p&gt;
&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>谈谈缓存和基本的缓存算法</title>
   <link href="http://http://coolshell.info/blog/2015/02/cache.html"/>
   <updated>2015-02-04T00:00:00+00:00</updated>
   <id>/blog/2015/02/cache</id>
   <content type="html">&lt;p&gt;很久很久以前，在还没有缓存的时候……用户经常是去请求一个对象，而这个对象是从数据库去取，然后，这个对象变得越来越大，这个用户每次的请求时间也越来越长了，这也把数据库弄得很痛苦，他无时不刻不在工作。所以，这个事情就把用户和数据库弄得很生气，接着就有可能发生下面两件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户很烦，在抱怨，甚至不去用这个应用了（这是大多数情况下都会发生的）&lt;/li&gt;
  &lt;li&gt;数据库为打包回家，离开这个应用，然后，就出现了大麻烦（没地方去存储数据了）（发生在极少数情况下）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;####上帝派来了缓存####&lt;/p&gt;

&lt;p&gt;在几年之后，IBM（60年代）的研究人员引进了一个新概念，它叫“缓存”。&lt;/p&gt;

&lt;p&gt;###什么是缓存？&lt;/p&gt;

&lt;p&gt;通俗来说，缓存是“存贮数据（使用频繁的数据）的临时地方，因为取原始数据的代价太大了，所以我可以取得快一些。”&lt;/p&gt;
&lt;p&gt;我们都听说过线程池、对象池，缓存可以认为是数据的池，这些数据是从数据库里的真实数据复制出来的，并且为了能别取回，被标上了标签（键 ID）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://img2.tuicool.com/QNvequ.jpg&quot;&gt;!&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;命中：&lt;/h4&gt;
&lt;p&gt;当客户发起一个请求（我们说他想要查看一个产品信息），我们的应用接受这个请求，并且如果是在第一次检查缓存的时候，需要去数据库读取产品信息。&lt;/p&gt;
&lt;p&gt;如果在缓存中，一个条目通过一个标记被找到了，这个条目就会被使用、我们就叫它缓存命中。所以，命中率也就不难理解了。&lt;/p&gt;
&lt;h4&gt;Cache Miss：&lt;/h4&gt;
&lt;p&gt;但是这里需要注意两点：&lt;/p&gt;
&lt;p&gt;１. 如果还有缓存的空间，那么，没有命中的对象会被存储到缓存中来。&lt;/p&gt;
&lt;p&gt;２. 如果缓存慢了，而又没有命中缓存，那么就会按照某一种策略，把缓存中的旧对象踢出，而把新的对象加入缓存池。而这些策略统称为*替代策略*（缓存算法），这些策略会决定到底应该提出哪些对象。&lt;/p&gt;
&lt;h4&gt;存储成本：&lt;/h4&gt;
&lt;p&gt;当没有命中时，我们会从数据库取出数据，然后放入缓存。而把这个数据放入缓存所需要的时间和空间，就是存储成本。&lt;/p&gt;
&lt;h4&gt;索引成本：&lt;/h4&gt;
&lt;p&gt;和存储成本相仿。&lt;/p&gt;
&lt;h4&gt;失效：&lt;/h4&gt;
&lt;p&gt;当存在缓存中的数据需要更新时，就意味着缓存中的这个数据失效了。&lt;/p&gt;
&lt;h4&gt;替代策略：&lt;/h4&gt;
&lt;p&gt;当缓存没有命中时，并且缓存容量已经满了，就需要在缓存中踢出一个老的条目，加入一条新的条目，而到底应该踢出什么条目，就由替代策略决定。&lt;/p&gt;
&lt;h4&gt;最优替代策略：&lt;/h4&gt;
&lt;p&gt;最优的替代策略就是想把缓存中最没用的条目给踢出去，但是未来是不能够被预知的，所以这种策略是不可能实现的。但是有很多策略，都是朝着这个目前去努力。&lt;/p&gt;
&lt;h1&gt;缓存算法&lt;/h1&gt;
&lt;p&gt;没有人能说清哪种缓存算法优于其他的缓存算法&lt;/p&gt;
&lt;h4&gt;Least Frequently Used（LFU）：&lt;/h4&gt;
&lt;p&gt;大家好，我是 LFU，我会计算为每个缓存对象计算他们被使用的频率。我会把最不常用的缓存对象踢走。&lt;/p&gt;
&lt;h4&gt;Least Recently User（LRU）：&lt;/h4&gt;
&lt;p&gt;我是 LRU 缓存算法，我把最近最少使用的缓存对象给踢走。&lt;/p&gt;
&lt;p&gt;我总是需要去了解在什么时候，用了哪个缓存对象。如果有人想要了解我为什么总能把最近最少使用的对象踢掉，是非常困难的。&lt;/p&gt;
&lt;p&gt;浏览器就是使用了我（LRU）作为缓存算法。新的对象会被放在缓存的顶部，当缓存达到了容量极限，我会把底部的对象踢走，而技巧就是：我会把最新被访问的缓存对象，放到缓存池的顶部。&lt;/p&gt;
&lt;p&gt;所以，经常被读取的缓存对象就会一直呆在缓存池中。有两种方法可以实现我，array 或者是 linked list。&lt;/p&gt;
&lt;p&gt;我的速度很快，我也可以被数据访问模式适配。我有一个大家庭，他们都可以完善我，甚至做的比我更好（我确实有时会嫉妒，但是没关系）。我家庭的一些成员包括 LRU2 和 2Q，他们就是为了完善 LRU 而存在的。&lt;/p&gt;
&lt;h4&gt;Least Recently Used 2（LRU2）：&lt;/h4&gt;
&lt;p&gt;我是 Least Recently Used 2，有人叫我最近最少使用 twice，我更喜欢这个叫法。我会把被两次访问过的对象放入缓存池，当缓存池满了之后，我会把有两次最少使用的缓存对象踢走。因为需要跟踪对象2次，访问负载就会随着缓存池的增加而增加。如果把我用在大容量的缓存池中，就会有问题。另外，我还需要跟踪那么不在缓存的对象，因为他们还没有被第二次读取。我比LRU好，而且是 adoptive to access 模式 。&lt;/p&gt;
&lt;h4&gt;Two Queues（2Q）：&lt;/h4&gt;
&lt;p&gt;我是 Two Queues；我把被访问的数据放到 LRU 的缓存中，如果这个对象再一次被访问，我就把他转移到第二个、更大的 LRU 缓存。&lt;/p&gt;
&lt;p&gt;我踢走缓存对象是为了保持第一个缓存池是第二个缓存池的1/3。当缓存的访问负载是固定的时候，把 LRU 换成 LRU2，就比增加缓存的容量更好。这种机制使得我比 LRU2 更好，我也是 LRU 家族中的一员，而且是 adoptive to access 模式 。&lt;/p&gt;
&lt;h4&gt;Adaptive Replacement Cache（ARC）：&lt;/h4&gt;
&lt;p&gt;我是 ARC，有人说我是介于 LRU 和 LFU 之间，为了提高效果，我是由2个 LRU 组成，第一个，也就是 L1，包含的条目是最近只被使用过一次的，而第二个 LRU，也就是 L2，包含的是最近被使用过两次的条目。因此， L1 放的是新的对象，而 L2 放的是常用的对象。所以，别人才会认为我是介于 LRU 和 LFU 之间的，不过没关系，我不介意。&lt;/p&gt;
&lt;p&gt;我被认为是性能最好的缓存算法之一，能够自调，并且是低负载的。我也保存着历史对象，这样，我就可以记住那些被移除的对象，同时，也让我可以看到被移除的对象是否可以留下，取而代之的是踢走别的对象。我的记忆力很差，但是我很快，适用性也强。&lt;/p&gt;
&lt;h4&gt;Most Recently Used（MRU）：&lt;/h4&gt;
&lt;p&gt;我是 MRU，和 LRU 是对应的。我会移除最近最多被使用的对象，你一定会问我为什么。好吧，让我告诉你，当一次访问过来的时候，有些事情是无法预测的，并且在缓存系统中找出最少最近使用的对象是一项时间复杂度非常高的运算，这就是为什么我是最好的选择。&lt;/p&gt;
&lt;p&gt;我是数据库内存缓存中是多么的常见！每当一次缓存记录的使用，我会把它放到栈的顶端。当栈满了的时候，你猜怎么着？我会把栈顶的对象给换成新进来的对象！&lt;/p&gt;
&lt;h4&gt;First in First out（FIFO）：&lt;/h4&gt;
&lt;p&gt;我是先进先出，我是一个低负载的算法，并且对缓存对象的管理要求不高。我通过一个队列去跟踪所有的缓存对象，最近最常用的缓存对象放在后面，而更早的缓存对象放在前面，当缓存容量满时，排在前面的缓存对象会被踢走，然后把新的缓存对象加进去。我很快，但是我并不适用。&lt;/p&gt;
&lt;h4&gt;Second Chance：&lt;/h4&gt;
&lt;p&gt;大家好，我是 second chance，我是通过 FIFO 修改而来的，被大家叫做 second chance 缓存算法，我比 FIFO 好的地方是我改善了 FIFO 的成本。我是 FIFO 一样也是在观察队列的前端，但是很FIFO的立刻踢出不同，我会检查即将要被踢出的对象有没有之前被使用过的标志（1一个 bit 表示），没有没有被使用过，我就把他踢出；否则，我会把这个标志位清除，然后把这个缓存对象当做新增缓存对象加入队列。你可以想象就这就像一个环队列。当我再一次在队头碰到这个对象时，由于他已经没有这个标志位了，所以我立刻就把他踢开了。我在速度上比 FIFO 快。&lt;/p&gt;
&lt;h4&gt;CLock：&lt;/h4&gt;
&lt;p&gt;我是 Clock，一个更好的 FIFO，也比 second chance 更好。因为我不会像 second chance 那样把有标志的缓存对象放到队列的尾部，但是也可以达到 second chance 的效果。&lt;/p&gt;
&lt;p&gt;我持有一个装有缓存对象的环形列表，头指针指向列表中最老的缓存对象。当缓存 miss 发生并且没有新的缓存空间时，我会问问指针指向的缓存对象的标志位去决定我应该怎么做。如果标志是0，我会直接用新的缓存对象替代这个缓存对象；如果标志位是1，我会把头指针递增，然后重复这个过程，知道新的缓存对象能够被放入。我比 second chance 更快。&lt;/p&gt;
&lt;h4&gt;Simple time-based：&lt;/h4&gt;
&lt;p&gt;我是 simple time-based 缓存算法，我通过绝对的时间周期去失效那些缓存对象。对于新增的对象，我会保存特定的时间。我很快，但是我并不适用。&lt;/p&gt;
&lt;h4&gt;Extended time-based expiration：&lt;/h4&gt;
&lt;p&gt;我是 extended time-based expiration 缓存算法，我是通过相对时间去失效缓存对象的；对于新增的缓存对象，我会保存特定的时间，比如是每5分钟，每天的12点。&lt;/p&gt;
&lt;h4&gt;Sliding time-based expiration：&lt;/h4&gt;
&lt;p&gt;我是 sliding time-based expiration，与前面不同的是，被我管理的缓存对象的生命起点是在这个缓存的最后被访问时间算起的。我很快，但是我也不太适用。&lt;/p&gt;
&lt;h4&gt;其他的缓存算法还考虑到了下面几点：&lt;/h4&gt;
&lt;p&gt;成本：如果缓存对象有不同的成本，应该把那些难以获得的对象保存下来。&lt;/p&gt;
&lt;p&gt;容量：如果缓存对象有不同的大小，应该把那些大的缓存对象清除，这样就可以让更多的小缓存对象进来了。&lt;/p&gt;
&lt;p&gt;时间：一些缓存还保存着缓存的过期时间。电脑会失效他们，因为他们已经过期了。&lt;/p&gt;
&lt;p&gt;根据缓存对象的大小而不管其他的缓存算法可能是有必要的。&lt;/p&gt;

&lt;p&gt;在这一部分中，我们来看看如何实现这些著名的缓存算法。以下的代码只是示例用的，如果你想自己实现缓存算法，可能自己还得加上一些额外的工作。&lt;/p&gt;

&lt;h4&gt;Random Cache&lt;/h4&gt;
&lt;p&gt;我是随机缓存，我随意的替换缓存实体，没人敢抱怨。你可以说那个被替换的实体很倒霉。通过这些行为，我随意的去处缓存实体。我比 FIFO 机制好，在某些情况下，我甚至比 LRU 好，但是，通常LRU都会比我好。&lt;/p&gt;

&lt;h4&gt;看看缓存元素（缓存实体）&lt;/h4&gt;
&lt;p&gt;public class CacheElement&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;private Object objectValue;&lt;/p&gt;
&lt;p&gt;private Object objectKey;&lt;/p&gt;
&lt;p&gt;private int index;&lt;/p&gt;
&lt;p&gt;private int hitCount; // getters and setters&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这个缓存实体拥有缓存的key和value，这个实体的数据结构会被以下所有缓存算法用到。&lt;/p&gt;
&lt;h4&gt;缓存算法的公用代码&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; 		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// get the entry from the table&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// If we have the entry already in our table&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// then get it and replace only its value.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;err&quot;&gt;｝&lt;/span&gt;
 	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上面的代码会被所有的缓存算法实现用到。这段代码是用来检查缓存元素是否在缓存中了，如果是，我们就替换它，但是如果我们找不到这个 key 对应的缓存，我们会怎么做呢？那我们就来深入的看看会发生什么吧！&lt;/p&gt;

&lt;h4&gt;看看随机缓存的实现&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; 		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// Just replace the value.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// If we haven&#39;t filled the cache yet, put it at the end.&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Otherwise, replace a random entry.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextFloat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4&gt;看看FIFO缓算法的实现&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt; 	 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Objectkey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; 		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 	 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Just replace the value.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 	 &lt;span class=&quot;c1&quot;&gt;// If we haven&#39;t filled the cache yet, put it at the end.&lt;/span&gt;
 	 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Otherwise, replace the current pointer,&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// entry with the new one.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// in order to make Circular FIFO&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4&gt;看看LFU缓存算法的实现&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 	 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; 		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Just replace the value.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeLfuElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeLfuElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getElementsFromTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leastElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leastHit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leastElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;leastHit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 	 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;最重点的代码，就应该是 leastHit 这个方法，这段代码就是把&lt;/p&gt;
&lt;p&gt;hitCount 最低的元素找出来，然后删除，给新进的缓存元素留位置。&lt;/p&gt;
&lt;h4&gt;看看LRU缓存算法实现&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// Only the head has a prev entry that is an invalid index&lt;/span&gt;
 	 &lt;span class=&quot;c1&quot;&gt;// so we don&#39;t check.&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// Make sure index is valid. If it isn&#39;t, we&#39;re at the tail&lt;/span&gt;
  	&lt;span class=&quot;c1&quot;&gt;// and don&#39;t set prev[next].&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 	 &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 	 &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; 		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
   	 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Just replace the value, but move it to the front.&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// If we haven&#39;t filled the cache yet, place in next available&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// spot and move to front.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_numEntries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// We replace the tail of the list.&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这段代码的逻辑如 LRU算法 的描述一样，把再次用到的缓存提取到最前面，而每次删除的都是最后面的元素。&lt;/p&gt;
&lt;h4&gt;结论&lt;/h4&gt;
&lt;p&gt;我们已经看到 LFU缓存算法 和 LRU缓存算法的实现方式，至于如何实现，采用数组还是 LinkedHashMap，都由你决定，不够我一般是小的缓存容量用数组，大的用 LinkedHashMap。&lt;/p&gt;

&lt;p3&gt;几个著名Java开源缓存框架介绍&lt;/p3&gt;
&lt;p&gt;1.OSCache&lt;/p&gt;

&lt;p&gt;　　OSCache是个一个广泛采用的高性能的J2EE缓存框架，OSCache能用于任何Java应用程序的普通的缓存解决方案。 OSCache有以下特点：缓存任何对象，你可以不受限制的缓存部分jsp页面或HTTP请求，任何java对象都可以缓存。拥有全面的API–OSCache API给你全面的程序来控制所有的OSCache特性。永久缓存–缓存能随意的写入硬盘，因此允许昂贵的创建(expensive-to-create)数据来保持缓存，甚至能让应用重启。支持集群–集群缓存数据能被单个的进行参数配置，不需要修改代码。缓存记录的过期–你可以有最大限度的控制缓存对象的过期，包括可插入式的刷新策略(如果默认性能不需要时)。&lt;/p&gt;

&lt;p&gt;2.Java Caching system&lt;/p&gt;

&lt;p&gt;　　JSC(Java Caching system)是一个用分布式的缓存系统，是基于服务器的java应用程序。它是通过提供管理各种动态缓存数据来加速动态web应用。 JCS和其他缓存系统一样，也是一个用于高速读取，低速写入的应用程序。动态内容和报表系统能够获得更好的性能。如果一个网站，有重复的网站结构，使用间歇性更新方式的数据库(而不是连续不断的更新数据库)，被重复搜索出相同结果的，就能够通过执行缓存方式改进其性能和伸缩性。&lt;/p&gt;

&lt;p&gt;3.EHCache&lt;/p&gt;

&lt;p&gt;　　EHCache 是一个纯java的在进程中的缓存，它具有以下特性：快速，简单，为Hibernate2.1充当可插入的缓存，最小的依赖性，全面的文档和测试。&lt;/p&gt;

&lt;p&gt;4.JCache&lt;/p&gt;

&lt;p&gt;　　JCache是个开源程序，正在努力成为JSR-107开源规范，JSR-107规范已经很多年没改变了。这个版本仍然是构建在最初的功能定义上。&lt;/p&gt;

&lt;p&gt;5.ShiftOne&lt;/p&gt;

&lt;p&gt;　　ShiftOne Java Object Cache是一个执行一系列严格的对象缓存策略的Java lib，就像一个轻量级的配置缓存工作状态的框架。&lt;/p&gt;

&lt;p&gt;6.SwarmCache&lt;/p&gt;

&lt;p&gt;　　SwarmCache是一个简单且有效的分布式缓存，它使用IP multicast与同一个局域网的其他主机进行通讯，是特别为集群和数据驱动web应用程序而设计的。SwarmCache能够让典型的读操作大大超过写操作的这类应用提供更好的性能支持。 SwarmCache使用JavaGroups来管理从属关系和分布式缓存的通讯。&lt;/p&gt;

&lt;p&gt;7.TreeCache / JBossCache&lt;/p&gt;

&lt;p&gt;　　JBossCache是一个复制的事务处理缓存，它允许你缓存企业级应用数据来更好的改善性能。缓存数据被自动复制，让你轻松进行JBoss服务器之间的集群工作。JBossCache能够通过JBoss应用服务或其他J2EE容器来运行一个MBean服务，当然，它也能独立运行。 JBossCache包括两个模块：TreeCache和TreeCacheAOP。 TreeCache –是一个树形结构复制的事务处理缓存。TreeCacheAOP –是一个“面向对象”缓存，它使用AOP来动态管理POJO(Plain Old Java Objects) 注：AOP是OOP的延续，是Aspect Oriented Programming的缩写，意思是面向方面编程。&lt;/p&gt;

&lt;p&gt;8.WhirlyCache&lt;/p&gt;

&lt;p&gt;　　Whirlycache是一个快速的、可配置的、存在于内存中的对象的缓存。它能够通过缓存对象来加快网站或应用程序的速度，否则就必须通过查询数据库或其他代价较高的处理程序来建立。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>skip list跳跃表实现</title>
   <link href="http://http://coolshell.info/blog/2014/12/skip-list.html"/>
   <updated>2014-12-18T00:00:00+00:00</updated>
   <id>/blog/2014/12/skip-list</id>
   <content type="html">&lt;p&gt;跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。跳表的具体定义，
 跳表是由William Pugh发明的，这位确实是个大牛，搞出一些很不错的东西。简单说来跳表也是&lt;/p&gt;

&lt;p&gt;链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(log n)的时间复杂&lt;/p&gt;

&lt;p&gt;度。红黑树等这样的平衡数据结构查找的时间复杂度也是O(log n)，并且相对于红黑树这样的平衡二叉树skiplist的优点是更好的支持并&lt;/p&gt;

&lt;p&gt;发操作，但是要实现像红黑树这样的数据结构并非易事,但是只要你熟悉链表的基本操作,再加之对跳表原理的理解，实现一个跳表数据&lt;/p&gt;

&lt;p&gt;结构就是一个很自然的事情了。&lt;/p&gt;

&lt;p&gt;此外，跳表在当前热门的开源项目中也有很多应用，比如LevelDB的核心数据结构memtable是用跳表实现的，redis的sorted set数据&lt;/p&gt;

&lt;p&gt;结构也是有跳表实现的。&lt;/p&gt;

&lt;p&gt;##skiplist主要思想&lt;/p&gt;

&lt;p&gt;先从链表开始，如果是一个简单的链表（不一定有序），那么我们在链表中查找一个元素X的话，需要将遍历整个链表直到找到元素X为止。&lt;/p&gt;

&lt;p&gt;现在我们考虑一个有序的链表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/githubpages/skiplist1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从该有序表中搜索元素 {13, 39} ，需要比较的次数分别为 {3, 5}，总共比较的次数为 3 + 5 = 8 次。我们想下有没有更优的算法?  我们想到了对于&lt;/p&gt;

&lt;p&gt;有序数组查找问题我们可以使用二分查找算法，但对于有序链表却不能使用二分查找。这个时候我们在想下平衡树,比如BST,他们都是通过把一些&lt;/p&gt;

&lt;p&gt;节点取出来作为其节点下某种意义的索引，比如父节点一般大于左子节点而小于右子节点。因此这个时候我们想到类似二叉搜索树的做法把一些&lt;/p&gt;

&lt;p&gt;节点提取出来，作为索引。得到如下结构：
 &lt;img src=&quot;/images/images/githubpages/skiplist2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个结构里我们把{3, 18, 77}提取出来作为一级索引，这样搜索的时候就可以减少比较次数了,比如在搜索39时仅比较了3次(通过比较3,18,39)。&lt;/p&gt;

&lt;p&gt;当然我们还可以再从一级索引提取一些元素出来，作为二级索引,这样更能加快元素搜索。&lt;/p&gt;

&lt;p&gt;这基本上就是跳表的核心思想，其实是一种通过“空间来换取时间”的一个算法，通过在每个节点中增加了向前的指针(即层)，从而提升查找的效率。&lt;/p&gt;

&lt;p&gt;跳跃列表是按层建造的。底层是一个普通的有序链表。每个更高层都充当下面列表的「快速跑道」，这里在层 i 中的元素按某个固定的概率 p (通常&lt;/p&gt;

&lt;p&gt;为0.5或0.25)出现在层 i+1 中。平均起来，每个元素都在 1/(1-p) 个列表中出现, 而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）&lt;/p&gt;

&lt;p&gt;在 O(log1/p n) 个列表中出现。&lt;/p&gt;

&lt;p&gt;##SkipList基本数据结构及其实现&lt;/p&gt;

&lt;p&gt;一个跳表，应该具有以下特征：&lt;/p&gt;

&lt;p&gt;1,一个跳表应该有几个层（level）组成；&lt;/p&gt;

&lt;p&gt;2,跳表的第一层包含所有的元素；&lt;/p&gt;

&lt;p&gt;3,每一层都是一个有序的链表；&lt;/p&gt;

&lt;p&gt;4,如果元素x出现在第i层，则所有比i小的层都包含x；&lt;/p&gt;

&lt;p&gt;5,每个节点包含key及其对应的value和一个指向同一层链表的下个节点的指针数组&lt;/p&gt;

&lt;p&gt;如图所示。
 &lt;img src=&quot;/images/images/githubpages/skiplist3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跳表基本数据结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义跳表数据类型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//跳表结构  
typedef struct skip_list  
{  
    int level;// 层数  
    Node *head;//指向头结点  
} skip_list;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中level是当前跳表最大层数,head是指向跳表的头节点如上图。&lt;/p&gt;

&lt;p&gt;跳表的每个节点的数据结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct node  
{  
    keyType key;// key值  
    valueType value;// value值  
    struct node *next[1];// 后继指针数组，柔性数组 可实现结构体的变长  
} Node;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于这个结构体重点说说，struct node *next[1] 其实它是个柔性数组，主要用于使结构体包含可变长字段。我们可以通过如下方法得到包含可变&lt;/p&gt;

&lt;p&gt;层数(n)的Node *类型的内存空间:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define new_node(n)((Node*)malloc(sizeof(Node)+n*sizeof(Node*)))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过上面我们可以根据层数n来申请指定大小的内存，从而节省了不必要的内存空间(比如固定大小的next数组就会浪费大量的内存空间)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跳表节点的创建&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 创建节点  
Node *create_node(int level, keyType key, valueType val)  
{  
    Node *p=new_node(level);  
    if(!p)  
        return NULL;  
    p-&amp;gt;key=key;  
    p-&amp;gt;value=val;  
    return p;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;跳表的创建&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;列表的初始化需要初始化头部，并使头部每层（根据事先定义的MAX_LEVEL）指向末尾（NULL）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//创建跳跃表  
skip_list *create_sl()  
{  
    skip_list *sl=(skip_list*)malloc(sizeof(skip_list));//申请跳表结构内存  
    if(NULL==sl)  
        return NULL;  
  
    sl-&amp;gt;level=0;// 设置跳表的层level，初始的层为0层（数组从0开始）  
  
    Node *h=create_node(MAX_L-1, 0, 0);//创建头结点  
    if(h==NULL)  
    {  
        free(sl);  
        return NULL;  
    }  
    sl-&amp;gt;head = h;  
    int i;  
     // 将header的next数组清空  
    for(i=0; i&amp;lt;MAX_L; ++i)  
    {  
        h-&amp;gt;next[i] = NULL;  
    }  
    srand(time(0));  
    return sl;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;跳表插入操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道跳表是一种随机化数据结构，其随机化体现在插入元素的时候元素所占有的层数完全是随机的，层数是通过随机算法产生的:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//插入元素的时候元素所占有的层数完全是随机算法  
int randomLevel()  
{  
    int level=1;  
    while (rand()%2)  
        level++;  
    level=(MAX_L&amp;gt;level)? level:MAX_L;  
    return level;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相当与做一次丢硬币的实验，如果遇到正面(rand产生奇数)，继续丢，遇到反面，则停止，用实验中丢硬币的次数level作为元素占有的层数。&lt;/p&gt;

&lt;p&gt;显然随机变量 level 满足参数为 p = 1/2 的几何分布，level 的期望值 E[level] = 1/p = 2. 就是说，各个元素的层数，期望值是 2 层。&lt;/p&gt;

&lt;p&gt;由于跳表数据结构整体上是有序的，所以在插入时，需要首先查找到合适的位置，然后就是修改指针（和链表中操作类似），然后更新跳表的&lt;/p&gt;

&lt;p&gt;level变量。 跳表的插入总结起来需要三步:&lt;/p&gt;

&lt;p&gt;1:查找到待插入位置, 每层跟新update数组;&lt;/p&gt;

&lt;p&gt;2:需要随机产生一个层数;&lt;/p&gt;

&lt;p&gt;3:从高层至下插入,与普通链表的插入完全相同;&lt;/p&gt;

&lt;p&gt;比如插入key为25的节点，如下图:
 &lt;img src=&quot;/images/images/githubpages/skiplist4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于步骤1,我们需要对于每一层进行遍历并保存这一层中下降的节点(其后继节点为NULL或者后继节点的key大于等于要插入的key)，如下图,
 &lt;img src=&quot;/images/images/githubpages/skiplist5.jpg&quot; alt=&quot;&quot; /&gt;
节点中有白色星花标识的节点保存到update数组。&lt;/p&gt;

&lt;p&gt;对于步骤2我们上面已经说明了是通过一个随机算法产生一个随机的层数，但是当这个随机产生的层数level大于当前跳表的最大层数时，我们&lt;/p&gt;

&lt;p&gt;此时需要更新当前跳表最大层数到level之间的update内容，这时应该更新其内容为跳表的头节点head，想想为什么这么做,呵呵。然后就是更&lt;/p&gt;

&lt;p&gt;新跳表的最大层数。&lt;/p&gt;

&lt;p&gt;对于步骤3就和普通链表插入一样了，只不过现在是对每一层链表进行插入节点操作。最终的插入结果如图所示，因为新插入key为25的节点level随机&lt;/p&gt;

&lt;p&gt;为4大于插入前的最大层数，所以此时跳表的层数为4。&lt;/p&gt;

&lt;p&gt;实现代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool insert(skip_list *sl, keyType key, valueType val)  
{  
    Node *update[MAX_L];  
    Node *q=NULL,*p=sl-&amp;gt;head;//q,p初始化  
    int i=sl-&amp;gt;level-1;  
    /******************step1*******************/  
    //从最高层往下查找需要插入的位置,并更新update  
    //即把降层节点指针保存到update数组  
    for( ; i&amp;gt;=0; --i)  
    {  
        while((q=p-&amp;gt;next[i])&amp;amp;&amp;amp; q-&amp;gt;key&amp;lt;key)  
            p=q;  
        update[i]=p;  
    }  
    if(q &amp;amp;&amp;amp; q-&amp;gt;key == key)//key已经存在的情况下  
    {  
        q-&amp;gt;value = val;  
        return true;  
    }  
    /******************step2*******************/  
    //产生一个随机层数level  
    int level = randomLevel();  
    //如果新生成的层数比跳表的层数大  
    if(level&amp;gt;sl-&amp;gt;level)  
    {  
        //在update数组中将新添加的层指向header  
        for(i=sl-&amp;gt;level; i&amp;lt;level; ++i)  
        {  
            update[i]=sl-&amp;gt;head;  
        }  
        sl-&amp;gt;level=level;  
    }  
    //printf(&quot;%d\n&quot;, sizeof(Node)+level*sizeof(Node*));  
    /******************step3*******************/  
    //新建一个待插入节点,一层一层插入  
    q=create_node(level, key, val);  
    if(!q)  
        return false;  
  
    //逐层更新节点的指针,和普通链表插入一样  
    for(i=level-1; i&amp;gt;=0; --i)  
    {  
        q-&amp;gt;next[i]=update[i]-&amp;gt;next[i];  
            update[i]-&amp;gt;next[i]=q;  
        }  
        return true;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;跳表删除节点操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;删除节点操作和插入差不多，找到每层需要删除的位置，删除时和操作普通链表完全一样。不过需要注意的是，如果该节点的level是最大的，&lt;/p&gt;

&lt;p&gt;则需要更新跳表的level。实现代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool erase(skip_list *sl, keyType key)  
{  
    Node *update[MAX_L];  
    Node *q=NULL, *p=sl-&amp;gt;head;  
    int i = sl-&amp;gt;level-1;  
    for(; i&amp;gt;=0; --i)  
    {  
        while((q=p-&amp;gt;next[i]) &amp;amp;&amp;amp; q-&amp;gt;key &amp;lt; key)  
        {  
            p=q;  
        }  
        update[i]=p;  
    }  
    //判断是否为待删除的key  
    if(!q || (q&amp;amp;&amp;amp;q-&amp;gt;key != key))  
        return false;  
  
    //逐层删除与普通链表删除一样  
    for(i=sl-&amp;gt;level-1; i&amp;gt;=0; --i)  
    {  
        if(update[i]-&amp;gt;next[i]==q)//删除节点  
        {  
            update[i]-&amp;gt;next[i]=q-&amp;gt;next[i];  
            //如果删除的是最高层的节点,则level--  
            if(sl-&amp;gt;head-&amp;gt;next[i]==NULL)  
                sl-&amp;gt;level--;  
        }  
    }  
    free(q);  
    q=NULL;  
    return true;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;跳表的查找操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;跳表的优点就是查找比普通链表快，其实查找操已经在插入、删除操作中有所体现，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;valueType *search(skip_list *sl, keyType key)  
{  
    Node *q,*p=sl-&amp;gt;head;  
    q=NULL;  
    int i=sl-&amp;gt;level-1;  
    for(; i&amp;gt;=0; --i)  
    {  
        while((q=p-&amp;gt;next[i]) &amp;amp;&amp;amp; q-&amp;gt;key&amp;lt;key)  
        {  
            p=q;  
        }  
        if(q &amp;amp;&amp;amp; key==q-&amp;gt;key)  
            return &amp;amp;(q-&amp;gt;value);  
    }  
    return NULL;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;跳表的销毁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面分别介绍了跳表的创建、节点插入、节点删除，其中涉及了内存的动态分配，在使用完跳表后别忘了释放所申请的内存，不然会内存泄露的。&lt;/p&gt;

&lt;p&gt;不多说了，代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 释放跳跃表  
void sl_free(skip_list *sl)  
{  
    if(!sl)  
        return;  
      
    Node *q=sl-&amp;gt;head;  
    Node *next;  
    while(q)  
    {  
        next=q-&amp;gt;next[0];  
        free(q);  
        q=next;  
    }  
    free(sl);  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;skiplist复杂度分析&lt;/p&gt;

&lt;p&gt;skiplist分析如下图
  &lt;img src=&quot;/images/images/githubpages/skiplist6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;p&gt;https://www.cs.auckland.ac.nz/software/AlgAnim/niemann/s_skl.htm&lt;/p&gt;

&lt;p&gt;http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>计算机算法--图算法介绍</title>
   <link href="http://http://coolshell.info/blog/2014/11/graph.html"/>
   <updated>2014-11-29T00:00:00+00:00</updated>
   <id>/blog/2014/11/graph</id>
   <content type="html">&lt;p&gt;##图的定义：&lt;/p&gt;

&lt;p&gt;图（graph）由顶点（vertex）和边（edge）的集合组成，每一条边就是一个点对（v,w)。&lt;/p&gt;

&lt;p&gt;图的种类：地图，电路图，调度图，事物，网络，程序结构&lt;/p&gt;

&lt;p&gt;图的属性：有V个顶点的图最多有V*（V-1）/2条边
&lt;img src=&quot;/images/images/githubpages/graph/graph1.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/images/images/githubpages/graph/graph2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###邻接矩阵：&lt;/p&gt;

&lt;p&gt;邻接矩阵是一个元素为bool值的V&lt;em&gt;V矩阵，若图中存在一条连接顶点V和W的边，折矩阵adj[v][w]=1,否则为0。占用的空间为V&lt;/em&gt;V，当图是稠密时，邻接矩阵是比较合适的表达方法。
&lt;img src=&quot;/images/images/githubpages/graph/graph3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###邻接表的表示&lt;/p&gt;

&lt;p&gt;对于非稠密的图，使用邻接矩阵有点浪费存储空间，可以使用邻接表，我们维护一个链表向量，给定一个顶点时，可以立即访问其链表,占用的空间为O(V+E)。
&lt;img src=&quot;/images/images/githubpages/graph/graph4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##深度优先搜索&lt;/p&gt;

&lt;p&gt;###深度优先搜索介绍&lt;/p&gt;

&lt;p&gt;图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。&lt;/p&gt;

&lt;p&gt;它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。&lt;/p&gt;

&lt;p&gt;显然，深度优先搜索是一个递归的过程。&lt;/p&gt;

&lt;p&gt;###深度优先搜索图解&lt;/p&gt;

&lt;p&gt;####无向图的深度优先搜索&lt;/p&gt;

&lt;p&gt;下面以”无向图”为例，来对深度优先搜索进行演示。
&lt;img src=&quot;/images/images/githubpages/graph/graph5.jpg&quot; alt=&quot;&quot; /&gt;
对上面的图G1进行深度优先遍历，从顶点A开始。
&lt;img src=&quot;/images/images/githubpages/graph/graph6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第1步：访问A。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第2步：访问(A的邻接点)C。&lt;/p&gt;

    &lt;p&gt;在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第3步：访问(C的邻接点)B。&lt;/p&gt;

    &lt;p&gt;在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第4步：访问(C的邻接点)D。&lt;/p&gt;

    &lt;p&gt;在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第5步：访问(A的邻接点)F。&lt;/p&gt;

    &lt;p&gt;前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第6步：访问(F的邻接点)G。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;第7步：访问(G的邻接点)E。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此访问顺序是：A -&amp;gt; C -&amp;gt; B -&amp;gt; D -&amp;gt; F -&amp;gt; G -&amp;gt; E&lt;/p&gt;

&lt;p&gt;####有向图的深度优先搜索&lt;/p&gt;

&lt;p&gt;下面以”有向图”为例，来对深度优先搜索进行演示。
&lt;img src=&quot;/images/images/githubpages/graph/graph7.jpg&quot; alt=&quot;&quot; /&gt;
对上面的图G2进行深度优先遍历，从顶点A开始。
&lt;img src=&quot;/images/images/githubpages/graph/graph8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第1步：访问A。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第2步：访问B。&lt;/p&gt;

    &lt;p&gt;在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第3步：访问C。&lt;/p&gt;

    &lt;p&gt;在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第4步：访问E。&lt;/p&gt;

    &lt;p&gt;接下来访问C的出边的另一个顶点，即顶点E。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第5步：访问D。&lt;/p&gt;

    &lt;p&gt;接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第6步：访问F。&lt;/p&gt;

    &lt;p&gt;接下应该回溯”访问A的出边的另一个顶点F”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;第7步：访问G。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此访问顺序是：A -&amp;gt; B -&amp;gt; C -&amp;gt; E -&amp;gt; D -&amp;gt; F -&amp;gt; G&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##广度优先搜索&lt;/p&gt;

&lt;p&gt;###广度优先搜索介绍&lt;/p&gt;

&lt;p&gt;广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。&lt;/p&gt;

&lt;p&gt;它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。&lt;/p&gt;

&lt;p&gt;换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;广度优先搜索图解&lt;/h3&gt;

&lt;p&gt;####无向图的广度优先搜索&lt;/p&gt;

&lt;p&gt;下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。
&lt;img src=&quot;/images/images/githubpages/graph/graph9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第1步：访问A。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第2步：依次访问C,D,F。&lt;/p&gt;

    &lt;p&gt;在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第3步：依次访问B,G。&lt;/p&gt;

    &lt;p&gt;在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第4步：访问E。&lt;/p&gt;

    &lt;p&gt;在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此访问顺序是：A -&amp;gt; C -&amp;gt; D -&amp;gt; F -&amp;gt; B -&amp;gt; G -&amp;gt; E&lt;/p&gt;

&lt;p&gt;####有向图的广度优先搜索&lt;/p&gt;

&lt;p&gt;下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。
&lt;img src=&quot;/images/images/githubpages/graph/graph10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第1步：访问A。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;第2步：访问B。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第3步：依次访问C,E,F。&lt;/p&gt;

    &lt;p&gt;在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第4步：依次访问D,G。&lt;/p&gt;

    &lt;p&gt;在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此访问顺序是：A -&amp;gt; B -&amp;gt; C -&amp;gt; E -&amp;gt; F -&amp;gt; D -&amp;gt; G&lt;/p&gt;

&lt;p&gt;##搜索算法的源码&lt;/p&gt;

&lt;p&gt;1.邻接矩阵表示的”无向图&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /**
    * C++: 邻接矩阵表示的&quot;无向图(Matrix Undirected Graph)&quot;
    *
    * @author LippiOuYang
    * @date 2013/04/19
    */
        
        #include &amp;lt;iomanip&amp;gt;
        #include &amp;lt;iostream&amp;gt;
        #include &amp;lt;vector&amp;gt;
        using namespace std;
        
    #define MAX 100
    class MatrixUDG {
	private:
        char mVexs[MAX];    // 顶点集合
        int mVexNum;             // 顶点数
        int mEdgNum;             // 边数
        int mMatrix[MAX][MAX];   // 邻接矩阵

    public:
        // 创建图(自己输入数据)
		MatrixUDG();
        // 创建图(用已提供的矩阵)
        MatrixUDG(char vexs[], int vlen, char edges[][2], int elen);
		~MatrixUDG();

        // 深度优先搜索遍历图
        void DFS();
        // 广度优先搜索（类似于树的层次遍历）
        void BFS();
        // 打印矩阵队列图
        void print();

	private:
        // 读取一个输入字符
        char readChar();
        // 返回ch在mMatrix矩阵中的位置
        int getPosition(char ch);
        // 返回顶点v的第一个邻接顶点的索引，失败则返回-1
        int firstVertex(int v);
        // 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1
        int nextVertex(int v, int w);
        // 深度优先搜索遍历图的递归实现
        void DFS(int i, int *visited);

};

/* 
 * 创建图(自己输入数据)
 */
MatrixUDG::MatrixUDG()
{
    char c1, c2;
    int i, p1, p2;
    
    // 输入&quot;顶点数&quot;和&quot;边数&quot;
    cout &amp;lt;&amp;lt; &quot;input vertex number: &quot;;
    cin &amp;gt;&amp;gt; mVexNum;
    cout &amp;lt;&amp;lt; &quot;input edge number: &quot;;
    cin &amp;gt;&amp;gt; mEdgNum;
    if ( mVexNum &amp;lt; 1 || mEdgNum &amp;lt; 1 || (mEdgNum &amp;gt; (mVexNum * (mVexNum-1))))
    {
        cout &amp;lt;&amp;lt; &quot;input error: invalid parameters!&quot; &amp;lt;&amp;lt; endl;
        return ;
    }
    
    // 初始化&quot;顶点&quot;
    for (i = 0; i &amp;lt; mVexNum; i++)
    {
        cout &amp;lt;&amp;lt; &quot;vertex(&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;): &quot;;
        mVexs[i] = readChar();
    }

    // 初始化&quot;边&quot;
    for (i = 0; i &amp;lt; mEdgNum; i++)
    {
        // 读取边的起始顶点和结束顶点
        cout &amp;lt;&amp;lt; &quot;edge(&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;): &quot;;
        c1 = readChar();
        c2 = readChar();

        p1 = getPosition(c1);
        p2 = getPosition(c2);
        if (p1==-1 || p2==-1)
        {
            cout &amp;lt;&amp;lt; &quot;input error: invalid edge!&quot; &amp;lt;&amp;lt; endl;
            return ;
        }

        mMatrix[p1][p2] = 1;
        mMatrix[p2][p1] = 1;
    }
}

/*
 * 创建图(用已提供的矩阵)
 *
 * 参数说明：
 *     vexs  -- 顶点数组
 *     vlen  -- 顶点数组的长度
 *     edges -- 边数组
 *     elen  -- 边数组的长度
 */
MatrixUDG::MatrixUDG(char vexs[], int vlen, char edges[][2], int elen)
{
    int i, p1, p2;
    
    // 初始化&quot;顶点数&quot;和&quot;边数&quot;
    mVexNum = vlen;
    mEdgNum = elen;
    // 初始化&quot;顶点&quot;
    for (i = 0; i &amp;lt; mVexNum; i++)
        mVexs[i] = vexs[i];

    // 初始化&quot;边&quot;
    for (i = 0; i &amp;lt; mEdgNum; i++)
    {
        // 读取边的起始顶点和结束顶点
        p1 = getPosition(edges[i][0]);
        p2 = getPosition(edges[i][1]);

        mMatrix[p1][p2] = 1;
        mMatrix[p2][p1] = 1;
    }
}

/* 
 * 析构函数
 */
MatrixUDG::~MatrixUDG() 
{
}

/*
 * 返回ch在mMatrix矩阵中的位置
 */
int MatrixUDG::getPosition(char ch)
{
    int i;
    for(i=0; i&amp;lt;mVexNum; i++)
        if(mVexs[i]==ch)
            return i;
    return -1;
}

/*
 * 读取一个输入字符
 */
char MatrixUDG::readChar()
{
    char ch;

    do {
        cin &amp;gt;&amp;gt; ch;
    } while(!((ch&amp;gt;=&#39;a&#39;&amp;amp;&amp;amp;ch&amp;lt;=&#39;z&#39;) || (ch&amp;gt;=&#39;A&#39;&amp;amp;&amp;amp;ch&amp;lt;=&#39;Z&#39;)));

    return ch;
}


/*
 * 返回顶点v的第一个邻接顶点的索引，失败则返回-1
 */
int MatrixUDG::firstVertex(int v)
{
    int i;

    if (v&amp;lt;0 || v&amp;gt;(mVexNum-1))
        return -1;

    for (i = 0; i &amp;lt; mVexNum; i++)
        if (mMatrix[v][i] == 1)
            return i;

    return -1;
}

/*
 * 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1
 */
int MatrixUDG::nextVertex(int v, int w)
{
    int i;

    if (v&amp;lt;0 || v&amp;gt;(mVexNum-1) || w&amp;lt;0 || w&amp;gt;(mVexNum-1))
        return -1;

    for (i = w + 1; i &amp;lt; mVexNum; i++)
        if (mMatrix[v][i] == 1)
            return i;

    return -1;
}

/*
 * 深度优先搜索遍历图的递归实现
 */
void MatrixUDG::DFS(int i, int *visited)
{
    int w;

    visited[i] = 1;
    cout &amp;lt;&amp;lt; mVexs[i] &amp;lt;&amp;lt; &quot; &quot;;
    // 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走
    for (w = firstVertex(i); w &amp;gt;= 0; w = nextVertex(i, w))
    {
        if (!visited[w])
            DFS(w, visited);
    }
       
}

/*
 * 深度优先搜索遍历图
 */
void MatrixUDG::DFS()
{
    int i;
    int visited[MAX];       // 顶点访问标记

    // 初始化所有顶点都没有被访问
    for (i = 0; i &amp;lt; mVexNum; i++)
        visited[i] = 0;

    cout &amp;lt;&amp;lt; &quot;DFS: &quot;;
    for (i = 0; i &amp;lt; mVexNum; i++)
    {
        //printf(&quot;\n== LOOP(%d)\n&quot;, i);
        if (!visited[i])
            DFS(i, visited);
    }
    cout &amp;lt;&amp;lt; endl;
}

/*
 * 广度优先搜索（类似于树的层次遍历）
 */
void MatrixUDG::BFS()
{
    int head = 0;
    int rear = 0;
    int queue[MAX];     // 辅组队列
    int visited[MAX];   // 顶点访问标记
    int i, j, k;

    for (i = 0; i &amp;lt; mVexNum; i++)
        visited[i] = 0;

    cout &amp;lt;&amp;lt; &quot;BFS: &quot;;
    for (i = 0; i &amp;lt; mVexNum; i++)
    {
        if (!visited[i])
        {
            visited[i] = 1;
            cout &amp;lt;&amp;lt; mVexs[i] &amp;lt;&amp;lt; &quot; &quot;;
            queue[rear++] = i;  // 入队列
        }
        while (head != rear) 
        {
            j = queue[head++];  // 出队列
            for (k = firstVertex(j); k &amp;gt;= 0; k = nextVertex(j, k)) //k是为访问的邻接顶点
            {
                if (!visited[k])
                {
                    visited[k] = 1;
                    cout &amp;lt;&amp;lt; mVexs[k] &amp;lt;&amp;lt; &quot; &quot;;
                    queue[rear++] = k;
                }
            }
        }
    }
    cout &amp;lt;&amp;lt; endl;
}

/*
 * 打印矩阵队列图
 */
void MatrixUDG::print()
{
    int i,j;

    cout &amp;lt;&amp;lt; &quot;Martix Graph:&quot; &amp;lt;&amp;lt; endl;
    for (i = 0; i &amp;lt; mVexNum; i++)
    {
        for (j = 0; j &amp;lt; mVexNum; j++)
            cout &amp;lt;&amp;lt; mMatrix[i][j] &amp;lt;&amp;lt; &quot; &quot;;
        cout &amp;lt;&amp;lt; endl;
    }
}


int main()
{
    char vexs[] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;};
    char edges[][2] = {
        {&#39;A&#39;, &#39;C&#39;}, 
        {&#39;A&#39;, &#39;D&#39;}, 
        {&#39;A&#39;, &#39;F&#39;}, 
        {&#39;B&#39;, &#39;C&#39;}, 
        {&#39;C&#39;, &#39;D&#39;}, 
        {&#39;E&#39;, &#39;G&#39;}, 
        {&#39;F&#39;, &#39;G&#39;}};
    int vlen = sizeof(vexs)/sizeof(vexs[0]);
    int elen = sizeof(edges)/sizeof(edges[0]);
    MatrixUDG* pG;

    // 自定义&quot;图&quot;(输入矩阵队列)
    //pG = new MatrixUDG();
    // 采用已有的&quot;图&quot;
    pG = new MatrixUDG(vexs, vlen, edges, elen);

    pG-&amp;gt;print();   // 打印图
    pG-&amp;gt;DFS();     // 深度优先遍历
    pG-&amp;gt;BFS();     // 广度优先遍历

    return 0;
} 2.邻接表表示的&quot;无向图

/**
 * C++: 邻接表表示的&quot;无向图(List Undirected Graph)&quot;
 *
 * @author LippiOuYang
 * @date 2013/04/19
 */

    #include &amp;lt;iomanip&amp;gt;
    #include &amp;lt;iostream&amp;gt;
    #include &amp;lt;vector&amp;gt;
    using namespace std;

#define MAX 100
// 邻接表
class ListUDG
{
    private: // 内部类
        // 邻接表中表对应的链表的顶点
        class ENode
        {
            public:
                int ivex;           // 该边所指向的顶点的位置
                ENode *nextEdge;    // 指向下一条弧的指针
        };

        // 邻接表中表的顶点
        class VNode
        {
            public:
                char data;          // 顶点信息
                ENode *firstEdge;   // 指向第一条依附该顶点的弧
        };

	private: // 私有成员
        int mVexNum;             // 图的顶点的数目
        int mEdgNum;             // 图的边的数目
        VNode mVexs[MAX];

    public:
        // 创建邻接表对应的图(自己输入)
		ListUDG();
        // 创建邻接表对应的图(用已提供的数据)
        ListUDG(char vexs[], int vlen, char edges[][2], int elen);
		~ListUDG();

        // 深度优先搜索遍历图
        void DFS();
        // 广度优先搜索（类似于树的层次遍历）
        void BFS();
        // 打印邻接表图
        void print();

	private:
        // 读取一个输入字符
        char readChar();
        // 返回ch的位置
        int getPosition(char ch);
        // 深度优先搜索遍历图的递归实现
        void DFS(int i, int *visited);
        // 将node节点链接到list的最后
        void linkLast(ENode *list, ENode *node);
};

/*
 * 创建邻接表对应的图(自己输入)
 */
ListUDG::ListUDG()
{
    char c1, c2;
    int v, e;
    int i, p1, p2;
    ENode *node1, *node2;

    // 输入&quot;顶点数&quot;和&quot;边数&quot;
    cout &amp;lt;&amp;lt; &quot;input vertex number: &quot;;
    cin &amp;gt;&amp;gt; mVexNum;
    cout &amp;lt;&amp;lt; &quot;input edge number: &quot;;
    cin &amp;gt;&amp;gt; mEdgNum;
    if ( mVexNum &amp;lt; 1 || mEdgNum &amp;lt; 1 || (mEdgNum &amp;gt; (mVexNum * (mVexNum-1))))
    {
        cout &amp;lt;&amp;lt; &quot;input error: invalid parameters!&quot; &amp;lt;&amp;lt; endl;
        return ;
    }
 
    // 初始化&quot;邻接表&quot;的顶点
    for(i=0; i&amp;lt;mVexNum; i++)
    {
        cout &amp;lt;&amp;lt; &quot;vertex(&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;): &quot;;
        mVexs[i].data = readChar();
        mVexs[i].firstEdge = NULL;
    }

    // 初始化&quot;邻接表&quot;的边
    for(i=0; i&amp;lt;mEdgNum; i++)
    {
        // 读取边的起始顶点和结束顶点
        cout &amp;lt;&amp;lt; &quot;edge(&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;): &quot;;
        c1 = readChar();
        c2 = readChar();

        p1 = getPosition(c1);
        p2 = getPosition(c2);
        // 初始化node1
        node1 = new ENode();
        node1-&amp;gt;ivex = p2;
        // 将node1链接到&quot;p1所在链表的末尾&quot;
        if(mVexs[p1].firstEdge == NULL)
          mVexs[p1].firstEdge = node1;
        else
            linkLast(mVexs[p1].firstEdge, node1);
        // 初始化node2
        node2 = new ENode();
        node2-&amp;gt;ivex = p1;
        // 将node2链接到&quot;p2所在链表的末尾&quot;
        if(mVexs[p2].firstEdge == NULL)
          mVexs[p2].firstEdge = node2;
        else
            linkLast(mVexs[p2].firstEdge, node2);
    }
}

/*
 * 创建邻接表对应的图(用已提供的数据)
 */
ListUDG::ListUDG(char vexs[], int vlen, char edges[][2], int elen)
{
    char c1, c2;
    int i, p1, p2;
    ENode *node1, *node2;

    // 初始化&quot;顶点数&quot;和&quot;边数&quot;
    mVexNum = vlen;
    mEdgNum = elen;
    // 初始化&quot;邻接表&quot;的顶点
    for(i=0; i&amp;lt;mVexNum; i++)
    {
        mVexs[i].data = vexs[i];
        mVexs[i].firstEdge = NULL;
    }

    // 初始化&quot;邻接表&quot;的边
    for(i=0; i&amp;lt;mEdgNum; i++)
    {
        // 读取边的起始顶点和结束顶点
        c1 = edges[i][0];
        c2 = edges[i][1];

        p1 = getPosition(c1);
        p2 = getPosition(c2);
        // 初始化node1
        node1 = new ENode();
        node1-&amp;gt;ivex = p2;
        // 将node1链接到&quot;p1所在链表的末尾&quot;
        if(mVexs[p1].firstEdge == NULL)
          mVexs[p1].firstEdge = node1;
        else
            linkLast(mVexs[p1].firstEdge, node1);
        // 初始化node2
        node2 = new ENode();
        node2-&amp;gt;ivex = p1;
        // 将node2链接到&quot;p2所在链表的末尾&quot;
        if(mVexs[p2].firstEdge == NULL)
          mVexs[p2].firstEdge = node2;
        else
            linkLast(mVexs[p2].firstEdge, node2);
    }
}

/* 
 * 析构函数
 */
ListUDG::~ListUDG() 
{
}

/*
 * 将node节点链接到list的最后
 */
void ListUDG::linkLast(ENode *list, ENode *node)
{
    ENode *p = list;

    while(p-&amp;gt;nextEdge)
        p = p-&amp;gt;nextEdge;
    p-&amp;gt;nextEdge = node;
}

/*
 * 返回ch的位置
 */
int ListUDG::getPosition(char ch)
{
    int i;
    for(i=0; i&amp;lt;mVexNum; i++)
        if(mVexs[i].data==ch)
            return i;
    return -1;
}

/*
 * 读取一个输入字符
 */
char ListUDG::readChar()
{
    char ch;

    do {
        cin &amp;gt;&amp;gt; ch;
    } while(!((ch&amp;gt;=&#39;a&#39;&amp;amp;&amp;amp;ch&amp;lt;=&#39;z&#39;) || (ch&amp;gt;=&#39;A&#39;&amp;amp;&amp;amp;ch&amp;lt;=&#39;Z&#39;)));

    return ch;
}


/*
 * 深度优先搜索遍历图的递归实现
 */
void ListUDG::DFS(int i, int *visited)
{
    ENode *node;

    visited[i] = 1;
    cout &amp;lt;&amp;lt; mVexs[i].data &amp;lt;&amp;lt; &quot; &quot;;
    node = mVexs[i].firstEdge;
    while (node != NULL)
    {
        if (!visited[node-&amp;gt;ivex])
            DFS(node-&amp;gt;ivex, visited);
        node = node-&amp;gt;nextEdge;
    }
}

/*
 * 深度优先搜索遍历图
 */
void ListUDG::DFS()
{
    int i;
    int visited[MAX];       // 顶点访问标记

    // 初始化所有顶点都没有被访问
    for (i = 0; i &amp;lt; mVexNum; i++)
        visited[i] = 0;

    cout &amp;lt;&amp;lt; &quot;DFS: &quot;;
    for (i = 0; i &amp;lt; mVexNum; i++)
    {
        if (!visited[i])
            DFS(i, visited);
    }
    cout &amp;lt;&amp;lt; endl;
}

/*
 * 广度优先搜索（类似于树的层次遍历）
 */
void ListUDG::BFS()
{
    int head = 0;
    int rear = 0;
    int queue[MAX];     // 辅组队列
    int visited[MAX];   // 顶点访问标记
    int i, j, k;
    ENode *node;

    for (i = 0; i &amp;lt; mVexNum; i++)
        visited[i] = 0;

    cout &amp;lt;&amp;lt; &quot;BFS: &quot;;
    for (i = 0; i &amp;lt; mVexNum; i++)
    {
        if (!visited[i])
        {
            visited[i] = 1;
            cout &amp;lt;&amp;lt; mVexs[i].data &amp;lt;&amp;lt; &quot; &quot;;
            queue[rear++] = i;  // 入队列
        }
        while (head != rear) 
        {
            j = queue[head++];  // 出队列
            node = mVexs[j].firstEdge;
            while (node != NULL)
            {
                k = node-&amp;gt;ivex;
                if (!visited[k])
                {
                    visited[k] = 1;
                    cout &amp;lt;&amp;lt; mVexs[k].data &amp;lt;&amp;lt; &quot; &quot;;
                    queue[rear++] = k;
                }
                node = node-&amp;gt;nextEdge;
            }
        }
    }
    cout &amp;lt;&amp;lt; endl;
}

/*
 * 打印邻接表图
 */
void ListUDG::print()
{
    int i,j;
    ENode *node;

    cout &amp;lt;&amp;lt; &quot;List Graph:&quot; &amp;lt;&amp;lt; endl;
    for (i = 0; i &amp;lt; mVexNum; i++)
    {
        cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; mVexs[i].data &amp;lt;&amp;lt; &quot;): &quot;;
        node = mVexs[i].firstEdge;
        while (node != NULL)
        {
            cout &amp;lt;&amp;lt; node-&amp;gt;ivex &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; mVexs[node-&amp;gt;ivex].data &amp;lt;&amp;lt; &quot;) &quot;;
            node = node-&amp;gt;nextEdge;
        }
        cout &amp;lt;&amp;lt; endl;
    }
}

int main()
{
    char vexs[] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;};
    char edges[][2] = {
        {&#39;A&#39;, &#39;C&#39;}, 
        {&#39;A&#39;, &#39;D&#39;}, 
        {&#39;A&#39;, &#39;F&#39;}, 
        {&#39;B&#39;, &#39;C&#39;}, 
        {&#39;C&#39;, &#39;D&#39;}, 
        {&#39;E&#39;, &#39;G&#39;}, 
        {&#39;F&#39;, &#39;G&#39;}};
    int vlen = sizeof(vexs)/sizeof(vexs[0]);
    int elen = sizeof(edges)/sizeof(edges[0]);
    ListUDG* pG;

    // 自定义&quot;图&quot;(输入矩阵队列)
    //pG = new ListUDG();
    // 采用已有的&quot;图&quot;
    pG = new ListUDG(vexs, vlen, edges, elen);

    pG-&amp;gt;print();   // 打印图
    pG-&amp;gt;DFS();     // 深度优先遍历
    pG-&amp;gt;BFS();     // 广度优先遍历

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;##迪杰斯特拉算法&lt;/p&gt;

&lt;p&gt;迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。 
它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。&lt;/p&gt;

&lt;p&gt;###基本思想&lt;/p&gt;

&lt;p&gt;通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。&lt;/p&gt;

&lt;p&gt;此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。&lt;/p&gt;

&lt;p&gt;初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。&lt;/p&gt;

&lt;p&gt;###操作步骤&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(1)
初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。&lt;/li&gt;
  &lt;li&gt;(2) 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。&lt;/li&gt;
  &lt;li&gt;(3)
更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。&lt;/li&gt;
  &lt;li&gt;(4) 重复步骤(2)和(3)，直到遍历完所有顶点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。&lt;/p&gt;

&lt;p&gt;5.3迪杰斯特拉算法图解
&lt;img src=&quot;/images/images/githubpages/graph/graph11.jpg&quot; alt=&quot;&quot; /&gt;
以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。
&lt;img src=&quot;/images/images/githubpages/graph/graph12.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第1步：将顶点D加入到S中。&lt;/p&gt;

    &lt;p&gt;此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。     注:C(3)表示C到起点D的距离是3。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第2步：将顶点C加入到S中。&lt;/p&gt;

    &lt;p&gt;上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。 
 此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第3步：将顶点E加入到S中。&lt;/p&gt;

    &lt;p&gt;上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。 
 此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第4步：将顶点F加入到S中。&lt;/p&gt;

    &lt;p&gt;此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第5步：将顶点G加入到S中。&lt;/p&gt;

    &lt;p&gt;此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第6步：将顶点B加入到S中。&lt;/p&gt;

    &lt;p&gt;此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第7步：将顶点A加入到S中。&lt;/p&gt;

    &lt;p&gt;此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;###代码&lt;/h2&gt;

&lt;p&gt;本文以”邻接矩阵”为例对迪杰斯特拉算法进行说明，
####基本定义&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 邻接矩阵
typedef struct _graph
{
    char vexs[MAX];       // 顶点集合
    int vexnum;           // 顶点数
    int edgnum;           // 边数
    int matrix[MAX][MAX]; // 邻接矩阵
}Graph, *PGraph;

// 边的结构体
typedef struct _EdgeData
{
    char start; // 边的起点
    char end;   // 边的终点
    int weight; // 边的权重
}EData;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Graph是邻接矩阵对应的结构体。 
vexs用于保存顶点，vexnum是顶点数，edgnum是边数；matrix则是用于保存矩阵信息的二维数组。例如，matrix[i][j]=1，则表示”顶点i(即vexs[i])”和”顶点j(即vexs[j])”是邻接点；matrix[i][j]=0，则表示它们不是邻接点。 
EData是邻接矩阵边对应的结构体。&lt;/p&gt;

&lt;p&gt;####迪杰斯特拉算法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * Dijkstra最短路径。
 * 即，统计图(G)中&quot;顶点vs&quot;到其它各个顶点的最短路径。
 *
 * 参数说明：
 *        G -- 图
 *       vs -- 起始顶点(start vertex)。即计算&quot;顶点vs&quot;到其它顶点的最短路径。
 *     prev -- 前驱顶点数组。即，prev[i]的值是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径所经历的全部顶点中，位于&quot;顶点i&quot;之前的那个顶点。
 *     dist -- 长度数组。即，dist[i]是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径的长度。
 */

    void dijkstra(Graph G, int vs, int prev[], int dist[])
    {
        int i,j,k;
        int min;
        int tmp;
    int flag[MAX];      // flag[i]=1表示&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径已成功获取。

    // 初始化
    for (i = 0; i &amp;lt; G.vexnum; i++)
    {
        flag[i] = 0;              // 顶点i的最短路径还没获取到。
 

           prev[i] = 0;              // 顶点i的前驱顶点为0。
            dist[i] = G.matrix[vs][i];// 顶点i的最短路径为&quot;顶点vs&quot;到&quot;顶点i&quot;的权。
        }
    
        // 对&quot;顶点vs&quot;自身进行

    初始化
    flag[vs] = 1;
    dist[vs] = 0;

    // 遍历G.vexnum-1次；每次找出一个顶点的最短路径。
    for (i = 1; i &amp;lt; G.vexnum; i++)
    {
    // 寻找当前最小的路径；
    // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。
    min = INF;
    for (j = 0; j &amp;lt; G.vexnum; j++)
    {
        if (flag[j]==0 &amp;amp;&amp;amp; dist[j]&amp;lt;min)
        {
            min = dist[j];
            k = j;
        }
    }
    // 标记&quot;顶点k&quot;为已经获取到最短路径
    flag[k] = 1;

    // 修正当前最短路径和前驱顶点
    // 即，当已经&quot;顶点k的最短路径&quot;之后，更新&quot;未获取最短路径的顶点的最短路径和前驱顶点&quot;。
    for (j = 0; j &amp;lt; G.vexnum; j++)
    {
        tmp = (G.matrix[k][j]==INF ? INF : (min + G.matrix[k][j])); // 防止溢出
        if (flag[j] == 0 &amp;amp;&amp;amp; (tmp  &amp;lt; dist[j]) )
        {
            dist[j] = tmp;
            prev[j] = k;
        }
    }
}

    // 打印dijkstra最短路径的结果
    printf(&quot;dijkstra(%c): \n&quot;, G.vexs[vs]);
    for (i = 0; i &amp;lt; G.vexnum; i++)
        printf(&quot;  shortest(%c, %c)=%d\n&quot;, G.vexs[vs], G.vexs[i], dist[i]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>leveldb原理剖析</title>
   <link href="http://http://coolshell.info/blog/2014/11/leveldb.html"/>
   <updated>2014-11-18T00:00:00+00:00</updated>
   <id>/blog/2014/11/leveldb</id>
   <content type="html">&lt;p&gt;在说LevelDb之前，先认识两位大牛，Jeff Dean和Sanjay Ghemawat，这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。&lt;/p&gt;

&lt;p&gt;　　Jeff Dean其人：&lt;a href=&quot;http://research.google.com/people/jeff/index.html&quot;&gt;http://research.google.com/people/jeff/index.html&lt;/a&gt;，Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。&lt;/p&gt;

&lt;p&gt;　　Sanjay Ghemawat其人：&lt;a href=&quot;http://research.google.com/people/sanjay/index.html&quot;&gt;http://research.google.com/people/sanjay/index.html&lt;/a&gt;，Google大规模分布式平台GFS，Bigtable和MapReduce主要设计和实现工程师。&lt;/p&gt;

&lt;p&gt;　　LevelDb就是这两位大神级别的工程师发起的开源项目，简而言之，LevelDb是能够处理十亿级别规模Key-Value型数据持久性存储的C++ 程序库。正像上面介绍的，这二位是Bigtable的设计和实现者，如果了解Bigtable的话，应该知道在这个影响深远的分布式存储系统中有两个核心的部分：Master Server和Tablet Server。其中Master Server做一些管理数据的存储以及分布式调度工作，实际的分布式数据存储以及读写操作是由Tablet Server完成的，而LevelDb则可以理解为一个简化版的Tablet Server。&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;p&gt;##LevelDb剖析之一：介绍&lt;/p&gt;

&lt;p&gt;　　LevelDb有如下一些特点：&lt;/p&gt;

&lt;p&gt;　　　　首先，LevelDb是一个持久化存储的KV系统，和Redis这种内存型的KV系统不同，LevelDb不会像Redis一样狂吃内存，而是将大部分数据存储到磁盘上。&lt;/p&gt;

&lt;p&gt;　　　　其次，LevleDb在存储数据时，是根据记录的key值有序存储的，就是说相邻的key值在存储文件中是依次顺序存储的，而应用可以自定义key大小比较函数，LevleDb会按照用户定义的比较函数依序存储这些记录。&lt;/p&gt;

&lt;p&gt;　　　　再次，像大多数KV系统一样，LevelDb的操作接口很简单，基本操作包括写记录，读记录以及删除记录。也支持针对多条操作的原子批量操作。&lt;/p&gt;

&lt;p&gt;　　　　另外，LevelDb支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。&lt;/p&gt;

&lt;p&gt;　　除此外，LevelDb还支持数据压缩等操作，这对于减小存储空间以及增快IO效率都有直接的帮助。&lt;/p&gt;

&lt;p&gt;　　LevelDb性能非常突出，官方网站报道其随机写性能达到40万条记录每秒，而随机读性能达到6万条记录每秒。总体来说，LevelDb的写操作要大大快于读操作，而顺序读写操作则大大快于随机读写操作。&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##LevelDb剖析之二：整体架构&lt;/p&gt;

&lt;p&gt;LevelDb本质上是一套存储系统以及在这套存储系统上提供的一些操作接口。为了便于理解整个系统及其处理流程，我们可以从两个不同的角度来看待LevleDb：静态角度和动态角度。从静态角度，可以假想整个系统正在运行过程中（不断插入删除读取数据），此时我们给LevelDb照相，从照片可以看到之前系统的数据在内存和磁盘中是如何分布的，处于什么状态等；从动态的角度，主要是了解系统是如何写入一条记录，读出一条记录，删除一条记录的，同时也包括除了这些接口操作外的内部操作比如compaction，系统运行时崩溃后如何恢复系统等等方面。&lt;/p&gt;

&lt;p&gt;本节所讲的整体架构主要从静态角度来描述，之后接下来的几节内容会详述静态结构涉及到的文件或者内存数据结构，LevelDb剖析后半部分主要介绍动态视角下的LevelDb，就是说整个系统是怎么运转起来的。&lt;/p&gt;

&lt;p&gt;LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么您会看到如下一番景象：
&lt;img src=&quot;/images/images/githubpages/level1.png&quot; alt=&quot;&quot; /&gt;
图1.1：LevelDb结构&lt;/p&gt;

&lt;p&gt;从图中可以看出，构成LevelDb静态结构的包括六个主要部分：内存中的MemTable和Immutable MemTable以及磁盘上的几种主要文件：Current文件，Manifest文件，log文件以及SSTable文件。当然，LevelDb除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是LevelDb的主体构成元素。&lt;/p&gt;

&lt;p&gt;LevelDb的Log文件和Memtable与Bigtable论文中介绍的是一致的，当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。&lt;/p&gt;

&lt;p&gt;Log文件在系统中的作用主要是用于系统崩溃恢复而不丢失数据，假如没有Log文件，因为写入的记录刚开始是保存在内存中的，此时如果系统崩溃，内存中的数据还没有来得及Dump到磁盘，所以会丢失数据（Redis就存在这个问题）。为了避免这种情况，LevelDb在写入内存前先将操作记录到Log文件中，然后再记入内存中，这样即使系统崩溃，也可以从Log文件中恢复内存中的Memtable，不会造成数据的丢失。&lt;/p&gt;

&lt;p&gt;当Memtable插入的数据占用内存到了一个界限后，需要将内存的记录导出到外存文件中，LevleDb会生成新的Log文件和Memtable，原先的Memtable就成为Immutable Memtable，顾名思义，就是说这个Memtable的内容是不可更改的，只能读不能写入或者删除。新到来的数据被记入新的Log文件和Memtable，LevelDb后台调度会将Immutable Memtable的数据导出到磁盘，形成一个新的SSTable文件。SSTable就是由内存中的数据不断导出并进行Compaction操作后形成的，而且SSTable的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。&lt;/p&gt;

&lt;p&gt;SSTable中的文件是Key有序的，就是说在文件中小key记录排在大Key记录之前，各个Level的SSTable都是如此，但是这里需要注意的一点是：Level 0的SSTable文件（后缀为.sst）和其它Level的文件相比有特殊性：这个层级内的.sst文件，两个文件可能存在key重叠，比如有两个level 0的sst文件，文件A和文件B，文件A的key范围是：{bar, car}，文件B的Key范围是{blue,samecity}，那么很可能两个文件都存在key=”blood”的记录。对于其它Level的SSTable文件来说，则不会出现同一层级内.sst文件的key重叠现象，就是说Level L中任意两个.sst文件，那么可以保证它们的key值是不会重叠的。这点需要特别注意，后面您会看到很多操作的差异都是由于这个原因造成的。&lt;/p&gt;

&lt;p&gt;SSTable中的某个文件属于特定层级，而且其存储的记录是key有序的，那么必然有文件中的最小key和最大key，这是非常重要的信息，LevelDb应该记下这些信息。Manifest就是干这个的，它记载了SSTable各个文件的管理信息，比如属于哪个Level，文件名称叫啥，最小key和最大key各自是多少。下图是Manifest所存储内容的示意：
&lt;img src=&quot;/images/images/githubpages/level2.png&quot; alt=&quot;&quot; /&gt;
图2.1：Manifest存储示意图&lt;/p&gt;

&lt;p&gt;图中只显示了两个文件（manifest会记载所有SSTable文件的这些信息），即Level 0的test.sst1和test.sst2文件，同时记载了这些文件各自对应的key范围，比如test.sstt1&lt;/p&gt;

&lt;p&gt;的key范围是“an”到 “banana”，而文件test.sst2的key范围是“baby”到“samecity”，可以看出两者的key范围是有重叠的。&lt;/p&gt;

&lt;p&gt;Current文件是干什么的呢？这个文件的内容只有一个信息，就是记载当前的manifest文件名。因为在LevleDb的运行过程中，随着Compaction的进行，SSTable文件会发生变化，会有新的文件产生，老的文件被废弃，Manifest也会跟着反映这种变化，此时往往会新生成Manifest文件来记载这种变化，而Current则用来指出哪个Manifest文件才是我们关心的那个Manifest文件。&lt;/p&gt;

&lt;p&gt;以上介绍的内容就构成了LevelDb的整体静态结构，在LevelDb剖析接下来的内容中，我们会首先介绍重要文件或者内存数据的具体数据布局与结构。&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##LevelDb剖析之三：log文件&lt;/p&gt;

&lt;p&gt;上节内容讲到log文件在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据，在这点上LevelDb和Bigtable是一致的。&lt;/p&gt;

&lt;p&gt;下面我们带大家看看log文件的具体物理和逻辑布局是怎样的，LevelDb对于一个log文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位，下图展示的log文件由3个Block构成，所以从物理布局来讲，一个log文件就是由连续的32K大小Block构成的。
&lt;img src=&quot;/images/images/githubpages/level3.png&quot; alt=&quot;&quot; /&gt;
图3.1 log文件布局&lt;/p&gt;

&lt;p&gt;在应用的视野里是看不到这些Block的，应用看到的是一系列的Key:Value对，在LevelDb内部，会将一个Key:Value对看做一条记录的数据，另外在这个数据前增加一个记录头，用来记载一些管理信息，以方便内部处理&lt;/p&gt;

&lt;p&gt;记录头包含三个字段，ChechSum是对“类型”和“数据”字段的校验码，为了避免处理不完整或者是被破坏的数据，当LevelDb读取记录数据时候会对数据进行校验，如果发现和存储的CheckSum相同，说明数据完整无破坏，可以继续后续流程。“记录长度”记载了数据的大小，“数据”则是上面讲的Key:Value数值对，“类型”字段则指出了每条记录的逻辑结构和log文件物理分块结构之间的关系，具体而言，主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。&lt;/p&gt;

&lt;p&gt;如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。&lt;/p&gt;

&lt;p&gt;假设目前存在三条记录，Record A，Record B和Record C，其中Record A大小为10K，Record B 大小为80K，Record C大小为12K，那么其在log文件中的逻辑布局会如图3.1所示。Record A是图中蓝色区域所示，因为大小为10K&amp;lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。&lt;/p&gt;

&lt;p&gt;从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDb一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##LevelDb剖析之四：SSTable文件&lt;/p&gt;

&lt;p&gt;　　SSTable是Bigtable中至关重要的一块，对于LevelDb来说也是如此，对LevelDb的SSTable实现细节的了解也有助于了解Bigtable中一些实现细节。&lt;/p&gt;

&lt;p&gt;本节内容主要讲述SSTable的静态布局结构，我们曾在“LevelDb剖析之二：整体架构”中说过，SSTable文件形成了不同Level的层级结构，至于这个层级结构是如何形成的我们放在后面Compaction一节细说。本节主要介绍SSTable某个文件的物理布局和逻辑布局结构，这对了解LevelDb的运行过程很有帮助。&lt;/p&gt;

&lt;p&gt;　　LevelDb不同层级有很多SSTable文件（以后缀.sst为特征），所有.sst文件内部布局都是一样的。上节介绍Log文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：Log文件中的记录是Key无序的，即先后记录的key大小没有明确大小关系，而.sst文件内部则是根据记录的Key由小到大排列的，从下面介绍的SSTable布局可以体会到Key有序是为何如此设计.sst文件结构的关键。
&lt;img src=&quot;/images/images/githubpages/level4.png&quot; alt=&quot;&quot; /&gt;
图4.1 .sst文件的分块结构&lt;/p&gt;

&lt;p&gt;　　图4.1展示了一个.sst文件的物理划分结构，同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。&lt;/p&gt;

&lt;p&gt;　　以上是.sst的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。图4.2展示了.sst文件的内部逻辑解释。
&lt;img src=&quot;/images/images/githubpages/level5.png&quot; alt=&quot;&quot; /&gt;
图4.2 逻辑布局&lt;/p&gt;

&lt;p&gt;　　从图4.2可以看出，从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。&lt;/p&gt;

&lt;p&gt;　　LevelDb 1.2版对于Meta Block尚无实际使用，只是保留了一个接口，估计会在后续版本中加入内容，下面我们看看数据索引区和文件尾部Footer的内部结构。
&lt;img src=&quot;/images/images/githubpages/level6.png&quot; alt=&quot;&quot; /&gt;
图4.3 数据索引&lt;/p&gt;

&lt;p&gt;　　图4.3是数据索引的内部结构示意图。再次强调一下，Data Block内的KV记录是按照Key由小到大排列的，数据索引区的每条记录是对某个Data Block建立的索引信息，每条索引信息包含三个内容，以图4.3所示的数据块i的索引Index i来说：红色部分的第一个字段记载大于等于数据块i中最大的Key值的那个Key，第二个字段指出数据块i在.sst文件中的起始位置，第三个字段指出Data Block i的大小（有时候是有数据压缩的）。后面两个字段好理解，是用于定位数据块在文件中的位置的，第一个字段需要详细解释一下，在索引里保存的这个Key值未必一定是某条记录的Key,以图4.3的例子来说，假设数据块i 的最小Key=“samecity”，最大Key=“the best”;数据块i+1的最小Key=“the fox”,最大Key=“zoo”,那么对于数据块i的索引Index i来说，其第一个字段记载大于等于数据块i的最大Key(“the best”)同时要小于数据块i+1的最小Key(“the fox”)，所以例子中Index i的第一个字段是：“the c”，这个是满足要求的；而Index i+1的第一个字段则是“zoo”，即数据块i+1的最大Key。&lt;/p&gt;

&lt;p&gt;　　文件末尾Footer块的内部结构见图4.4，metaindex_handle指出了metaindex block的起始位置和大小；inex_handle指出了index Block的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的，后面跟着一个填充区和魔数。&lt;/p&gt;

&lt;p&gt;　　上面主要介绍的是数据管理区的内部结构，下面我们看看数据区的一个Block的数据部分内部是如何布局的（图4.1中的红色部分），图4.5是其内部布局示意图。
&lt;img src=&quot;/images/images/githubpages/level7.png&quot; alt=&quot;&quot; /&gt;
图4.5 数据Block内部结构&lt;/p&gt;

&lt;p&gt;　　从图中可以看出，其内部也分为两个部分，前面是一个个KV记录，其顺序是根据Key值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point）,其实是一些指针，指出Block内容中的一些记录位置。&lt;/p&gt;

&lt;p&gt;　　“重启点”是干什么的呢？我们一再强调，Block内容里的KV记录是按照Key大小有序的，这样的话，相邻的两条记录很可能Key部分存在重叠，比如key i=“the Car”，Key i+1=“the color”,那么两者存在重叠部分“the c”，为了减少Key的存储量，Key i+1可以只存储和上一条Key不同的部分“olor”，两者的共同部分从Key i中可以获得。记录的Key在Block内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的Key部分，而是重新记录所有的Key值，假设Key i+1是一个重启点，那么Key里面会完整存储“the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。
&lt;img src=&quot;/images/images/githubpages/level8.png&quot; alt=&quot;&quot; /&gt;
图4.6 记录格式&lt;/p&gt;

&lt;p&gt;　　在Block内容区，每个KV记录的内部结构是怎样的？图4.6给出了其详细结构，每个记录包含5个字段：key共享长度，比如上面的“olor”记录， 其key和上一条记录共享的Key部分长度是“the c”的长度，即5；key非共享长度，对于“olor”来说，是4；value长度指出Key:Value中Value的长度，在后面的Value内容字段中存储实际的Value值；而key非共享内容则实际存储“olor”这个Key字符串。&lt;/p&gt;

&lt;p&gt;　　上面讲的这些就是.sst文件的全部内部奥秘。&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##LevelDb剖析之五：MemTable详解&lt;/p&gt;

&lt;p&gt;　　LevelDb剖析前述小节大致讲述了磁盘文件相关的重要静态结构，本小节讲述内存中的数据结构Memtable，Memtable在整个体系中的重要地位也不言而喻。总体而言，所有KV数据都是存储在Memtable，Immutable Memtable和SSTable中的，Immutable Memtable从结构上讲和Memtable是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而Memtable则是允许写入和读取的。当Memtable写入的数据占用内存到达指定数量，则自动转换为Immutable Memtable，等待Dump到磁盘中，系统会自动生成新的Memtable供写操作写入新数据，理解了Memtable，那么Immutable Memtable自然不在话下。&lt;/p&gt;

&lt;p&gt;　　LevelDb的MemTable提供了将KV数据写入，删除以及读取KV记录的操作接口，但是事实上Memtable并不存在真正的删除操作,删除某个Key的Value在Memtable内是作为插入一条记录实施的，但是会打上一个Key的删除标记，真正的删除操作是Lazy的，会在以后的Compaction过程中去掉这个KV。&lt;/p&gt;

&lt;p&gt;　　需要注意的是，LevelDb的Memtable中KV对是根据Key大小有序存储的，在系统插入新的KV时，LevelDb要把这个KV插到合适的位置上以保持这种Key有序性。其实，LevelDb的Memtable类只是一个接口类，真正的操作是通过背后的SkipList来做的，包括插入操作和读取操作等，所以Memtable的核心数据结构是一个SkipList。&lt;/p&gt;

&lt;p&gt;　　SkipList是由William Pugh发明。他在Communications of the ACM June 1990, 33(6) 668-676 发表了Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。&lt;/p&gt;

&lt;p&gt;SkipList是平衡树的一种替代数据结构，但是和红黑树不相同的是，SkipList对于树的平衡的实现是基于一种随机化的算法的，这样也就是说SkipList的插入和删除的工作是比较简单的。&lt;/p&gt;

&lt;p&gt;关于SkipList的详细介绍可以参考这篇文章，&lt;a href=&quot;http://lippiouyangonline.info/skip-list/&quot;&gt;skip-list原理解析&lt;/a&gt;讲述的很清楚，LevelDb的SkipList基本上是一个具体实现，并无特殊之处。&lt;/p&gt;

&lt;p&gt;　　SkipList不仅是维护有序数据的一个简单实现，而且相比较平衡树来说，在插入数据的时候可以避免频繁的树节点调整操作，所以写入效率是很高的，LevelDb整体而言是个高写入系统，SkipList在其中应该也起到了很重要的作用。Redis为了加快插入操作，也使用了SkipList来作为内部实现数据结构。&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##LevelDb剖析之六 写入与删除记录&lt;/p&gt;

&lt;p&gt;在之前的五节LevelDb剖析中，我们介绍了LevelDb的一些静态文件及其详细布局，从本节开始，我们看看LevelDb的一些动态操作，比如读写记录，Compaction，错误恢复等操作。&lt;/p&gt;

&lt;p&gt;本节介绍levelDb的记录更新操作，即插入一条KV记录或者删除一条KV记录。levelDb的更新操作速度是非常快的，源于其内部机制决定了这种更新操作的简单性。 
&lt;img src=&quot;/images/images/githubpages/level9.png&quot; alt=&quot;&quot; /&gt;
图6.1 LevelDb写入记录&lt;/p&gt;

&lt;p&gt;图6.1是levelDb如何更新KV数据的示意图，从图中可以看出，对于一个插入操作Put(Key,Value)来说，完成插入操作包含两个具体步骤：首先是将这条KV记录以顺序写的方式追加到之前介绍过的log文件末尾，因为尽管这是一个磁盘读写操作，但是文件的顺序追加写入效率是很高的，所以并不会导致写入速度的降低；第二个步骤是:如果写入log文件成功，那么将这条KV记录插入内存中的Memtable中，前面介绍过，Memtable只是一层封装，其内部其实是一个Key有序的SkipList列表，插入一条新记录的过程也很简单，即先查找合适的插入位置，然后修改相应的链接指针将新记录插入即可。完成这一步，写入记录就算完成了，所以一个插入记录操作涉及一次磁盘文件追加写和内存SkipList插入操作，这是为何levelDb写入速度如此高效的根本原因。&lt;/p&gt;

&lt;p&gt;从上面的介绍过程中也可以看出：log文件内是key无序的，而Memtable中是key有序的。那么如果是删除一条KV记录呢？对于levelDb来说，并不存在立即删除的操作，而是与插入操作相同的，区别是，插入操作插入的是Key:Value 值，而删除操作插入的是“Key:删除标记”，并不真正去删除记录，而是后台Compaction的时候才去做真正的删除操作。&lt;/p&gt;

&lt;p&gt;levelDb的写入操作就是如此简单。真正的麻烦在后面将要介绍的读取操作中。&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##LevelDb剖析之七：读取记录&lt;/p&gt;

&lt;p&gt;　　LevelDb是针对大规模Key/Value数据的单机存储库，从应用的角度来看，LevelDb就是一个存储工具。而作为称职的存储工具，常见的调用接口无非是新增KV，删除KV，读取KV，更新Key对应的Value值这么几种操作。LevelDb的接口没有直接支持更新操作的接口，如果需要更新某个Key的Value,你可以选择直接生猛地插入新的KV，保持Key相同，这样系统内的key对应的value就会被更新；或者你可以先删除旧的KV， 之后再插入新的KV，这样比较委婉地完成KV的更新操作。&lt;/p&gt;

&lt;p&gt;假设应用提交一个Key值，下面我们看看LevelDb是如何从存储的数据中读出其对应的Value值的。图7-1是LevelDb读取过程的整体示意图。
&lt;img src=&quot;/images/images/githubpages/level10.png&quot; alt=&quot;&quot; /&gt;
图7-1  LevelDb读取记录流程&lt;/p&gt;

&lt;p&gt;　　LevelDb首先会去查看内存中的Memtable，如果Memtable中包含key及其对应的value，则返回value值即可；如果在Memtable没有读到key，则接下来到同样处于内存中的Immutable Memtable中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。因为SSTable数量较多，而且分成多个Level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于level 0的文件中查找，如果找到则返回对应的value值，如果没有找到那么到level 1中的文件中去找，如此循环往复，直到在某层SSTable文件中找到这个key对应的value为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。&lt;/p&gt;

&lt;p&gt;　　那么为什么是从Memtable到Immutable Memtable，再从Immutable Memtable到文件，而文件中为何是从低level到高level这么一个查询路径呢？道理何在？之所以选择这么个查询路径，是因为从信息的更新时间来说，很明显Memtable存储的是最新鲜的KV对；Immutable Memtable中存储的KV数据对的新鲜程度次之；而所有SSTable文件中的KV数据新鲜程度一定不如内存中的Memtable和Immutable Memtable的。对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。也就是说，上面列出的查找路径就是按照数据新鲜程度排列出来的，越新鲜的越先查找。&lt;/p&gt;

&lt;p&gt;　　为啥要优先查找新鲜的数据呢？这个道理不言而喻，举个例子。比如我们先往levelDb里面插入一条数据 {key=”www.samecity.com”  value=”我们”},过了几天，samecity网站改名为：69同城，此时我们插入数据{key=”www.samecity.com”  value=”69同城”}，同样的key,不同的value；逻辑上理解好像levelDb中只有一个存储记录，即第二个记录，但是在levelDb中很可能存在两条记录，即上面的两个记录都在levelDb中存储了，此时如果用户查询key=”www.samecity.com”,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。&lt;/p&gt;

&lt;p&gt;　　前文有讲：对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。这是一个结论，理论上需要一个证明过程，否则会招致如下的问题：为神马呢？从道理上讲呢，很明白：因为Level L+1的数据不是从石头缝里蹦出来的，也不是做梦梦到的，那它是从哪里来的？Level L+1的数据是从Level L 经过Compaction后得到的（如果您不知道什么是Compaction，那么……..也许以后会知道的），也就是说，您看到的现在的Level L+1层的SSTable数据是从原来的Level L中来的，现在的Level L比原来的Level L数据要新鲜，所以可证，现在的Level L比现在的Level L+1的数据要新鲜。&lt;/p&gt;

&lt;p&gt;　　SSTable文件很多，如何快速地找到key对应的value值？在LevelDb中，level 0一直都爱搞特殊化，在level 0和其它level中查找某个key的过程是不一样的。因为level 0下的不同文件可能key的范围有重叠，某个要查询的key有可能多个文件都包含，这样的话LevelDb的策略是先找出level 0中哪些文件包含这个key（manifest文件中记载了level和对应的文件及文件里key的范围信息，LevelDb在内存中保留这种映射表）， 之后按照文件的新鲜程度排序，新的文件排在前面，之后依次查找，读出key对应的value。而如果是非level 0的话，因为这个level的文件之间key是不重叠的，所以只从一个文件就可以找到key对应的value。&lt;/p&gt;

&lt;p&gt;　　最后一个问题,如果给定一个要查询的key和某个key range包含这个key的SSTable文件，那么levelDb是如何进行具体查找过程的呢？levelDb一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后levelDb根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的SSTable文件并不包含这个key，所以到下一级别的SSTable中去查找。&lt;/p&gt;

&lt;p&gt;　　从之前介绍的LevelDb的写操作和这里介绍的读操作可以看出，相对写操作，读操作处理起来要复杂很多，所以写的速度必然要远远高于读数据的速度，也就是说，LevelDb比较适合写操作多于读操作的应用场合。而如果应用是很多读操作类型的，那么顺序读取效率会比较高，因为这样大部分内容都会在缓存中找到，尽可能避免大量的随机读取操作。&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##LevelDb剖析之八：Compaction操作&lt;/p&gt;

&lt;p&gt;前文有述，对于LevelDb来说，写入记录操作很简单，删除记录仅仅写入一个删除标记就算完事，但是读取记录比较复杂，需要在内存以及各个层级文件中依照新鲜程度依次查找，代价很高。为了加快读取速度，levelDb采取了compaction的方式来对已有的记录进行整理压缩，通过这种方式，来删除掉一些不再有效的KV数据，减小数据规模，减少文件数量等。&lt;/p&gt;

&lt;p&gt;levelDb的compaction机制和过程与Bigtable所讲述的是基本一致的，Bigtable中讲到三种类型的compaction: minor ，major和full。所谓minor Compaction，就是把memtable中的数据导出到SSTable文件中；major compaction就是合并不同层级的SSTable文件，而full compaction就是将所有SSTable进行合并。&lt;/p&gt;

&lt;p&gt;LevelDb包含其中两种，minor和major。&lt;/p&gt;

&lt;p&gt;我将为大家详细叙述其机理。&lt;/p&gt;

&lt;p&gt;先来看看minor Compaction的过程。Minor compaction 的目的是当内存中的memtable大小到了一定值时，将内容保存到磁盘文件中，图8.1是其机理示意图。 &lt;img src=&quot;/images/images/githubpages/level11.png&quot; alt=&quot;&quot; /&gt;
图8.1 minor compaction&lt;/p&gt;

&lt;p&gt;从8.1可以看出，当memtable数量到了一定程度会转换为immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable其实是一个多层级队列SkipList，其中的记录是根据key有序排列的。所以这个minor compaction实现起来也很简单，就是按照immutable memtable中记录由小到大遍历，并依次写入一个level 0 的新建SSTable文件中，写完后建立文件的index 数据，这样就完成了一次minor compaction。从图中也可以看出，对于被删除的记录，在minor compaction过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉key记录，但是这个KV数据在哪里?那需要复杂的查找，所以在minor compaction的时候并不做删除，只是将这个key作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的compaction中会去做。&lt;/p&gt;

&lt;p&gt;当某个level下的SSTable文件数目超过一定设置值后，levelDb会从这个level的SSTable中选择一个文件（level&amp;gt;0），将其和高一层级的level+1的SSTable文件合并，这就是major compaction。&lt;/p&gt;

&lt;p&gt;我们知道在大于0的层级中，每个SSTable文件内的Key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。Level 0的SSTable文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为level 0的文件是通过minor compaction直接生成的，所以任意两个level 0下的两个sstable文件可能再key范围上有重叠。所以在做major compaction的时候，对于大于level 0的层级，选择其中一个文件就行，但是对于level 0来说，指定某个文件后，本level中很可能有其他SSTable文件的key范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和level 1的文件进行合并，即level 0在进行文件选择的时候，可能会有多个文件参与major compaction。&lt;/p&gt;

&lt;p&gt;　　levelDb在选定某个level进行compaction后，还要选择是具体哪个文件要进行compaction，levelDb在这里有个小技巧， 就是说轮流来，比如这次是文件A进行compaction，那么下次就是在key range上紧挨着文件A的文件B进行compaction，这样每个文件都会有机会轮流和高层的level 文件进行合并。&lt;/p&gt;

&lt;p&gt;如果选好了level L的文件A和level L+1层的文件进行合并，那么问题又来了，应该选择level L+1哪些文件进行合并？levelDb选择L+1层中和文件A在key range上有重叠的所有文件来和文件A进行合并。&lt;/p&gt;

&lt;p&gt;　　也就是说，选定了level L的文件A,之后在level L+1中找到了所有需要合并的文件B,C,D…..等等。剩下的问题就是具体是如何进行major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的KV 数据。&lt;/p&gt;

&lt;p&gt;图8.2说明了这一过程。
&lt;img src=&quot;/images/images/githubpages/level12.png&quot; alt=&quot;&quot; /&gt;
图8.2 SSTable Compaction&lt;/p&gt;

&lt;p&gt;　　Major compaction的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的Key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个Key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入level L+1层中新生成的一个SSTable文件中。就这样对KV数据一一处理，形成了一系列新的L+1层数据文件，之前的L层文件和L+1层参与compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了L层和L+1层文件记录的合并过程。&lt;/p&gt;

&lt;p&gt;　　那么在major compaction过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于L层中存在这个Key，那么这个KV在major compaction过程中可以抛掉。因为我们前面分析过，对于层级低于L的文件中如果存在同一Key的记录，那么说明对于Key来说，有更新鲜的Value存在，那么过去的Value就等于没有意义了，所以可以删除。&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##LevelDb剖析之九 levelDb中的Cache&lt;/p&gt;

&lt;p&gt;　　书接前文，前面讲过对于levelDb来说，读取操作如果没有在内存的memtable中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在level 0中最新的文件中找到了这个key，那么也需要读取2次磁盘，一次是将SSTable的文件中的index部分读入内存，这样根据这个index可以确定key是在哪个block中存储；第二次是读入这个block的内容，然后在内存中查找key对应的value。&lt;/p&gt;

&lt;p&gt;　　levelDb中引入了两个不同的Cache:Table Cache和Block Cache。其中Block Cache是配置可选的，即在配置文件中指定是否打开这个功能。
&lt;img src=&quot;/images/images/githubpages/level3.png&quot; alt=&quot;&quot; /&gt;
图9.1 table cache&lt;/p&gt;

&lt;p&gt;　　图9.1是table cache的结构。在Cache中，key值是SSTable的文件名称，Value部分包含两部分，一个是指向磁盘打开的SSTable文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个SSTable文件对应的Table结构指针，table结构在内存中，保存了SSTable的index内容以及用来指示block cache用的cache_id ,当然除此外还有其它一些内容。&lt;/p&gt;

&lt;p&gt;　　比如在get(key)读取操作中，如果levelDb确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，levelDb会首先查找Table Cache，看这个文件是否在缓存里，如果找到了，那么根据index部分就可以查找是哪个block包含这个key。如果没有在缓存中找到文件，那么打开SSTable文件，将其index部分读入内存，然后插入Cache里面，去index里面定位哪个block包含这个Key 。如果确定了文件哪个block包含这个key，那么需要读入block内容，这是第二次读取。&lt;/p&gt;

&lt;p&gt;　　Block Cache是为了加快这个过程的，图9.2是其结构示意图。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。&lt;/p&gt;

&lt;p&gt;　　如果levelDb发现这个block在block cache中，那么可以避免读取数据，直接在cache里的block内容里面查找key的value就行，如果没找到呢？那么读入block内容并把它插入block cache中。levelDb就是这样通过两个cache来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。&lt;/p&gt;

&lt;p&gt;##LevelDb剖析之十 Version、VersionEdit、VersionSet&lt;/p&gt;

&lt;p&gt;　　Version 保存了当前磁盘以及内存中所有的文件信息，一般只有一个Version叫做”current” version（当前版本）。Leveldb还保存了一系列的历史版本，这些历史版本有什么作用呢？&lt;/p&gt;

&lt;p&gt;当一个Iterator创建后，Iterator就引用到了current version(当前版本)，只要这个Iterator不被delete那么被Iterator引用的版本就会一直存活。这就意味着当你用完一个Iterator后，需要及时删除它。&lt;/p&gt;

&lt;p&gt;　　当一次Compaction结束后（会生成新的文件，合并前的文件需要删除），Leveldb会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。&lt;/p&gt;

&lt;p&gt;　　VersionSet 是所有Version的集合，管理着所有存活的Version。&lt;/p&gt;

&lt;p&gt;　　VersionEdit 表示Version之间的变化，相当于delta 增量，表示有增加了多少文件，删除了文件。下图表示他们之间的关系。&lt;/p&gt;

&lt;p&gt;Version0 +VersionEdit–&amp;gt;Version1&lt;/p&gt;

&lt;p&gt;　　VersionEdit会保存到MANIFEST文件中，当做数据恢复时就会从MANIFEST文件中读出来重建数据。&lt;/p&gt;

&lt;p&gt;　　leveldb的这种版本的控制，让我想到了双buffer切换，双buffer切换来自于图形学中，用于解决屏幕绘制时的闪屏问题，在服务器编程中也有用处。&lt;/p&gt;

&lt;p&gt;　　比如我们的服务器上有一个字典库，每天我们需要更新这个字典库，我们可以新开一个buffer，将新的字典库加载到这个新buffer中，等到加载完毕，将字典的指针指向新的字典库。&lt;/p&gt;

&lt;p&gt;leveldb的version管理和双buffer切换类似，但是如果原version被某个iterator引用，那么这个version会一直保持，直到没有被任何一个iterator引用，此时就可以删除这个version。&lt;/p&gt;

&lt;p&gt;注：本文参考了这篇文章：&lt;a href=&quot;http://www.samecity.com/blog/Index.asp?SortID=12&quot;&gt;http://www.samecity.com/blog/Index.asp?SortID=12&lt;/a&gt;
参考资料：1.&lt;a href=&quot;http://zh.wikipedia.org/wiki/LevelDB&quot;&gt;维基百科&lt;/a&gt;
　　　　　2.&lt;a href=&quot;http://code.google.com/p/leveldb/&quot;&gt;google code&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>如何评价『黑客与画家』</title>
   <link href="http://http://coolshell.info/blog/2014/11/how-to-evaluate-the-hackers-and-painters.html"/>
   <updated>2014-11-01T00:00:00+00:00</updated>
   <id>/blog/2014/11/how-to-evaluate-the-hackers-and-painters</id>
   <content type="html">&lt;p&gt;传送门：&lt;a href=&quot;http://t.cn/zlg4njc&quot;&gt;黑客与画家:硅谷创业之父Paul Graham文集&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一本好的书，让我们收获的不单单是某种技巧，或者某种方法论， 
&lt;strong&gt;他教给我们的是一种严密的思维方式，是一种学会把自己的眼光放得更加长远的决策习惯，他促使我们养成独立思考的习惯。&lt;/strong&gt;
他没有送给我们一条大鱼，却把捕捉大鱼的方法交给了我们， &lt;strong&gt;授人以鱼，不如授人以渔&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我一直觉得把一个我们所熟知的很普通的问题讲的非常透彻而且非常清楚是一种相当了不起的能力，
保罗·格雷尔姆 不仅把问题讲的非常透彻，而且还非常有趣，
让我们在读的时候感觉趣味盎然，这一点是非常不容易的。&lt;/p&gt;

&lt;p&gt;很多的互联网从业者想必早就听说过这本书，而且大部分人应该都已经阅读过这本书了，
所以我就简单的从其他的角度来谈一下我读完本书的一些感想，希望对大家有所帮助。&lt;/p&gt;

&lt;p&gt;在阅读「为什么书呆子不受欢迎」这章时，我想到了这么一句话，「&lt;strong&gt;你的时间在哪里，你的成就就在哪里&lt;/strong&gt;」。
生活中的我们，总是喜欢羡慕那些成功人士，我们总觉得那些成功人士与我们普通人不一样，
他们必然懂得某种通往成功的诀窍，他们生下来就与周围的人们有所不同。
我们也总是希望能从这些成功人士那里获得某些珍贵的建议，获得那些能使人最终功成名就的万用妙方。
在武侠小说里面， &lt;strong&gt;渴望成为武林高手的人，都希望得到一本有着盖世神功的武林秘籍。&lt;/strong&gt;
因为这秘籍一旦得手，只要依葫芦画瓢，就可大功告成。&lt;/p&gt;

&lt;p&gt;但是世事又怎会如此简单，也永远不会有这样或者那样的武林秘诀。
&lt;strong&gt;所谓的成功人士不过是把自己的时间投入到那些他们感兴趣的领域里面罢了。&lt;/strong&gt;
其实， &lt;strong&gt;我们每一个人也许都是我们所投入时间的那个领域的成功人士。&lt;/strong&gt;
有的同学，可能在学校里没有把时间投入学习中，但是呢，投入了很多的时间在游戏领域，每天花费大量的时间去玩游戏，
看游戏讲解视频，研究游戏的战略，思考游戏的玩法，在这个游戏里面，他就是王者；
有的人呢，可能喜欢计算机，他喜欢与程序打交道，他希望了解计算机是如何思考的，于是最终他就成了黑客。&lt;/p&gt;

&lt;p&gt;画家能够把画画的比我们更好，只是因为他把他的时间都投入到里面罢了，田径运动员跑的比我们更快，
同样只不过因为他把他的时间都投入到跑步里面罢了。
&lt;strong&gt;书呆子也并非不想让自己不受欢迎，他们只是更愿意把时间投入到让自己聪明上去罢了。&lt;/strong&gt;
我们每一个人，都可以自己去决定把自己的时间投入到哪个领域，我们所投入的时间最终也会成就我们。&lt;/p&gt;

&lt;p&gt;在阅读本书的其他章节的时候，我更加深刻的发觉，黑客们，其实与我们并没有多大的不同，
&lt;strong&gt;他们只是比我们普通人更加崇尚分享、开放和民主，他们对任何被禁止的东西都怀有特别强烈的好奇心，他们喜欢去思考那些似乎不应该被思考的问题，他们相信计算机将会深刻的改变人们的生活。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虽然这是一本讲述黑客的书，不过个人觉得每个人都应该看看。
如同译者阮一峰所言：未来的人类生活不仅是人与人的互动，而且更多的将是人与计算机的互动。
想要把握这个时代，就必须理解计算机。
理解计算机的关键，则是要理解计算机背后的人。
表面上这是一个机器的时代，但是实际上机器的设计者决定了我们的时代。
&lt;strong&gt;程序员的审美决定了你看到的软件界面，程序员的爱好决定了你有什么样的软件可以使用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你想要进一步了解作者的话，下面这两个链接可以帮助你：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;作者博客主页： &lt;a href=&quot;http://www.paulgraham.com&quot;&gt;http://www.paulgraham.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Wiki 百科上关于他的介绍： &lt;a href=&quot;http://en.wikipedia.org/wiki/Paul_Graham_(computer_programmer)&quot;&gt;http://en.wikipedia.org/wiki/Paul_Graham_(computer_programmer)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>XMPP协议分析-具体分析</title>
   <link href="http://http://coolshell.info/blog/2014/10/xmpp-analise.html"/>
   <updated>2014-10-31T00:00:00+00:00</updated>
   <id>/blog/2014/10/xmpp-analise</id>
   <content type="html">&lt;p&gt;通过WireShark抓包来具体分析XMPP协议，下面用人人桌面版演示了，XMPP客户端从登录到获取新鲜事的过程，通过分析具体的数据包能够更容易的理解协议。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step1.TCP三次握手建立连接&lt;/strong&gt;
&lt;img src=&quot;/images/images/openfire/xmpp2.jpeg&quot; alt=&quot;&quot; /&gt;
图1.xmpp客户端使用5222端口，设置SYN请求连接&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/openfire/xmpp3.jpeg&quot; alt=&quot;&quot; /&gt;
图2.服务器返回ACK，确认请求，同样设置SYN请求连接&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/openfire/xmpp4.jpeg&quot; alt=&quot;&quot; /&gt;
图3.客户端确认服务器连接请求，连接建立完毕。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step2.客户端请求，服务器响应。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/openfire/xmpp5.jpeg&quot; alt=&quot;&quot; /&gt;
图4.客户端发送Jabber/x Request请求，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;客户端初始化流给服务器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/openfire/xmpp6.jpeg&quot; alt=&quot;&quot; /&gt;
图5.服务器返回Jabber/x Response，服务器发送一个流标签给客户端作为应答&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/openfire/xmpp7.jpeg&quot; alt=&quot;&quot; /&gt;
图5.5服务器发送 STARTTLS 范围给客户端（包括验证机制和任何其他流特性）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/openfire/xmpp8.jpeg&quot; alt=&quot;&quot; /&gt;
图6.客户端发送请求，发送，请求使用传输层加密协议[TLS]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/openfire/xmpp9.jpeg&quot; alt=&quot;&quot; /&gt;
图7.服务器端响应，返回元素，确认传输加密&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/openfire/xmpp10.jpeg&quot; alt=&quot;&quot; /&gt;
图8.之后的请求，数据均已经加密&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/openfire/xmpp11.jpeg&quot; alt=&quot;&quot; /&gt;
图9.之后的响应，返回数据也是加密的&lt;/p&gt;

&lt;p&gt;这次抓包分析，可以看到，xml文档的安全性有了一定的保障，加密过的数据无法看到。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Smack开发手册</title>
   <link href="http://http://coolshell.info/blog/2014/10/how-to-use-smack.html"/>
   <updated>2014-10-30T00:00:00+00:00</updated>
   <id>/blog/2014/10/how to use smack</id>
   <content type="html">&lt;p&gt;这篇文章翻译自Smack的官方文档，&lt;a href=&quot;http://www.igniterealtime.org/builds/smack/docs/latest/documentation/&quot;&gt;http://www.igniterealtime.org/builds/smack/docs/latest/documentation/&lt;/a&gt;，转载请注明出处。&lt;/p&gt;

&lt;p&gt;Smack是一个为使用XMPP服务器聊天和发送即时消息交流而提供的库。&lt;/p&gt;

&lt;h2 id=&quot;smack&quot;&gt;Smack的主要优势：&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用简单且拥有强大的API。向用户发送一条文本消息只需用一下三行代码即可完成&lt;/p&gt;

    &lt;p&gt;XMPPConnection connection = new XMPPConnection(“jabber.org”);
 connection.login(“mtucker”, “password”);
 connection.createChat(“jsmith@jivesoftware.com”).sendMessage(“Howdy!;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;不像其它库那样，强制你在信息报级（packet level）编码。Smack提供智能的、更高级别的结构，例如：Chat和GroupChat类，这写能让你的程序效率更高。
    &lt;ul&gt;
      &lt;li&gt;你不需要熟悉XMPP  XML格式，甚至不熟XML。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供简单的机器到机器的通讯。Smack允许你对每一条消息设置任何数字的属性，包括Java对象的属性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Apache许可的开放源码，你可将其用于商业的和非商业的应用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;xmpp&quot;&gt;关于XMPP&lt;/h2&gt;
&lt;p&gt;XMPP (eXtensible Messaging and Presence Protocol)是一个开放的，&lt;/p&gt;

&lt;p&gt;如何使用本文档
本文档假定你已经熟悉XMPP即时消息的主要特征。我们推荐你在阅读该文档时打开Javadoc API作为参考。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开始Smack&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本文档将向你介绍Smack API，并大概介绍几个重要的类和概念。
必备的条件
你只需要有JDK 1.2或之后的版本1和已经内嵌在smack..jar文件中的XML分析器，不需要第三部分库。
1JDK 1.2 and 1.3的用户若想使用SSL连接必须在他的类路径下有JSSE库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;建立一个连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;XMPPConnection类是为XMPP服务器建立连接的类。若要创建SSL连接，需使用SSLXMPPConnection类，以下是创建连接的例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Create a connection to the jabber.org server.
XMPPConnection conn1 = new XMPPConnection(&quot;jabber.org&quot;);
 
// Create a connection to the jabber.org server on a specific port.
XMPPConnection conn2 = new XMPPConnection(&quot;jabber.org&quot;, 5222);
 
// Create an SSL connection to jabber.org.
XMPPConnection connection = new SSLXMPPConnection(&quot;jabber.org&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果创建了一个连接，你应该使用&lt;code class=&quot;highlighter-rouge&quot;&gt;XMPPConnection.login(String username, String password)&lt;/code&gt;方法（参数为用户名和密码）进行登陆。一旦登陆成功，你就可以通过创建一个新的Chat 或GroupChat对象与其它用户聊天。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;working-with-the-roster&quot;&gt;使用花名册（Working with the Roster）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;花名册让你很清楚的知道其它可用的用户。用户可以被分成像“朋友”、“合作者”这样的组，从而知道其它的用户在线还是离线。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以使用XMPPConnection.getRoster()方法检索花名册。你可以用花名册（roster）类查找花名册的所有条目，它们所属的组以及每个条目当前呈现的状态。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;读、写信息包（Reading and Writing Packets）&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从客户端发送到XMPP的每一条消息称为一个信息包，并作为XML发送。The org.jivesoftware.smack.packet包含封装了三个XMPP允许的、不同的基本包类型(message, presence, and IQ)的类。像Chat和GroupChat这样的类提供更高级别的结构，它可以自动的创建和发送信息包，当然你也可以直接创建和发送信息包。以下代码是一个将你的当前状态改为“隐身“，从而不被别人看到的例子：&lt;/p&gt;

    &lt;p&gt;// Create a new presence. Pass in false to indicate we’re unavailable.
 Presence presence = new Presence(Presence.Type.UNAVAILABLE);
 presence.setStatus(“Gone fishing”);
 // Send the packet (assume we have a XMPPConnection instance called “con”).
 con.sendPacket(presence);&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Smack提供以下两种方法阅读收到的信息包：PacketListener和PacketCollector。它们都使用PacketFilter的实例来决定应该处理哪个信息包。信息包监听器（packet listener）用于事件类型的设计，而信息包收集器（packet collector）有一个信息包的结果队列，你可以对其实施polling和blocking操作。所以，信息包监听器在你收到任何一个信息包，且你想对其进行操作时是有用的，而信息包收集器在你想等待某个特殊的信息包时是有用的。信息包收集器和监听器可以通过XMPPConnection的实例来创建。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;messaging-basics&quot;&gt;Messaging Basics&lt;/h1&gt;
&lt;p&gt;## Messaging using Chat and GroupChat ##
互相发送消息是即时通讯的核心，以下是两个在收发消息是用的类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;org.jivesoftware.smack.Chat – 用于两个人之间发送消息&lt;/li&gt;
  &lt;li&gt;org.jivesoftware.smack.GroupChat –用于加入聊天室，很多人之间相互发送消息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Chat和GroupChat类都用org.jivesoftware.smack.packet .Message信息包类发送消息。在某些情况下，也许你希望绕过更高级别的Chat和GroupChat类直接发送和接受消息。
聊天（Chat）
聊天时在两个用户间创建了一个新的线程（使用一个线程ID）。以下程序片示例了如何如何与一个用户进行开始聊天并发送一段文本消息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Assume we&#39;ve created an XMPPConnection name &quot;connection&quot;.
Chat newChat = connection.createChat(&quot;jsmith@jivesoftware.com&quot;);
newChat.sendMessage(&quot;Howdy!&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Chat.sendMessage(String)方法可以很方便的创建一个消息对象，方法体使用字符串类型的参数，然后发送消息。如果想在发送消息前对消息设置额外的只，可以使用Chat.createMessage() and Chat.sendMessage(Message)方法，如下例所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Assume we&#39;ve created an XMPPConnection name &quot;connection&quot;.
Chat newChat = connection.createChat(&quot;jsmith@jivesoftware.com&quot;);
Message newMessage = newChat.createMessage();
newMessage.setBody(&quot;Howdy!&quot;);
message.setProperty(&quot;favoriteColor&quot;, &quot;red&quot;);
newChat.sendMessage(newMessage);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用Chat对象可以轻松的收听其它聊天者的回复。以下程序片是parrot-bot，它映射会其它用户类型的所有事情：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Assume we&#39;ve created an XMPPConnection name &quot;connection&quot;.
Chat newChat = connection.createChat(&quot;jsmith@jivesoftware.com&quot;);
newMessage.setBody(&quot;Hi, I&#39;m an annoying parrot-bot! Type something back to me.&quot;);
while (true) {
// Wait for the next message the user types to us.
Message message = newChat.nextMessage();
// Send back the same text the other user sent us.
newChat.sendMessage(message.getBody());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上代码使用Chat.nextMessage()方法获得下一条消息，它必需一直等待直到收到下一条消息。也有其它的方法可以等待特定的时间来接受下一条消息，或者你也可以增加一个监听器，它可以在每次收到消息时通知你。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;群聊（GroupChat）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;群聊在通过一个服务器连接到聊天室，你可以向一组人发送消息或接收他们的消息。在你能接收和发送消息前，你必须使用一个昵称登陆到聊天室。以下程序段可以连接到一个聊天室并发送消息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Assume we&#39;ve created an XMPPConnection name &quot;connection&quot;.
GroupChat newGroupChat = connection.createGroupChat(&quot;test@jivesoftware.com&quot;);
// Join the group chat using the nickname &quot;jsmith&quot;.
newGroupChat.join(&quot;jsmith&quot;);
// Send a message to all the other people in the chat room.
newGroupChat.sendMessage(&quot;Howdy!&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;群聊时收发消息和私聊时工作原理大体一致。同样，也有方法可以获得聊天室里其它用户的列表。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;roster-and--presence&quot;&gt;Roster and  Presence&lt;/h2&gt;
&lt;p&gt;花名册让你很清楚的知道其它可用的用户。用户可以被分成像“朋友”、“合作者”这样的组。其它的即使通讯系统将花名册作为好友列表、联系列表等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   **当你成功登陆服务器后，可以使用XMPPConnection.getRoster()获得Roster类的实例。**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;花名册条目（Roster Entries）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;花名册里的每一个用户都以一条花名册条目的形式呈现，包括以下几部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个XMPP地址(例如：jsmith@example.com).&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分配给你的用户名 (例如： “Joe”).
该条目在花名册中所属组的列表。如果该条目不属于任何一个组，将被称为“尚未分类的条目。
以下程序段可以打印出花名册中的所有条目：&lt;/p&gt;

    &lt;p&gt;Roster roster = con.getRoster();
 for (Iterator i=roster.getEntries(); i.hasNext(); ) {
 System.out.println(i.next());
 }&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也有获得个人条目、尚未分类条目的列表、一个或者所有组的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;呈现（Presence）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;花名册中的每一个条目都有相关的呈现方式。Roster.getPresence(String user)方法将通过用户的状态或当用户不在线或不同意将其在线状态显示出来时使用空对象（null）返回一个Presence对象。&lt;/p&gt;

&lt;p&gt;注意：一般情况下，用户是否同意显示其状态依赖于用户所在的花名册，但这不是在所有情况下都成立的。&lt;/p&gt;

&lt;p&gt;用户也有一个在线或离线的状态，如果用户在线，他们的显示信息中将会有一些扩展的信息，例如他当前正在做什么，是否希望被打扰等等，详细内容可以参看Presence类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Listening for Roster and Presence Changes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Roster类的典型用途是用树状形式显示组和每一个条目以及它的当前状态。如下图所示是 Exodus XMPP客户端的花名册。&lt;/p&gt;

&lt;p&gt;显示的信息很可能会经常改变，也有可能是花名册的条目被改变甚至被删除。为了监视花名册的改变和显示的信息，应该使用一个花名册监听器（RosterListener）。以下代码使用Roster（它可以打印出花名册中的任何变化）注册了一个RosterListener。标准的客户端应该使用相似的代码更新花名册的用户信息（roster UI）以正确显示变化的信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final Roster roster = con.getRoster();
roster.addRosterListener(new RosterListener() {
public void rosterModified() {
// Ignore event for this example.
}
 
public void presenceChanged(String user) {
// If the presence is unavailable then &quot;null&quot; will be printed,
// which is fine for this example.
System.out.println(&quot;Presence changed: &quot; + roster.getPresence(user));
}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;向花名册中添加条目（Adding Entries to the Roster）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;花名册和显示使用基于许可的模型，这要求用户在加入别人的花名册前必须得到允许。这样，确保只有被允许的人才可以看到自己所显示的信息，从而保护了用户的隐私。因此，在你想添加一个新的条目，且对方没有接受你的请求前，该条目将处于等待状态。&lt;/p&gt;

&lt;p&gt;如果另一个用户请求同意显示，从而你他们可以将你加入他们的花名册，你必须接受或拒绝请求。Smack通过以下三种方式之一操作同意显示请求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;自动接受所有的同意显示请求。&lt;/li&gt;
  &lt;li&gt;自动拒绝所有的同意显示请求。&lt;/li&gt;
  &lt;li&gt;手动处理同意显示请求。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以使用Roster.setSubscriptionMode(int subscriptionMode)方法设置模式。简单的客户通常使用一个自动接受或拒绝同意显示请求的模式，而用更多特征的用户应该使用手动处理同意显示请求的模式，并让终端用户接受或拒绝每一个请求。如果使用手动模式，应该声明一个信息包监听器（PacketListener）来监听有Presence.Type.SUBSCRIBE类型的显示信息包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;处理收到的信息包(Processing Incoming Packets)&lt;/strong&gt;
Smack提供一个使用以下两个结构的灵活框架来处理收到的信息包：&lt;/p&gt;

&lt;p&gt;org.jivesoftware.smack.PacketCollector – 一个允许你同步的等待新的信息包的类&lt;/p&gt;

&lt;p&gt;org.jivesoftware.smack.PacketListener – 一个异步的通知你收到信息包的接口&lt;/p&gt;

&lt;p&gt;信息包监听器（packet listener）用于事件类型的设计，而信息包收集器（packet collector）有一个信息包的结果队列，你可以对其实施polling和blocking操作。所以，信息包监听器在你收到任何一个信息包，且你想对其进行操作时是有用的，而信息包收集器在你想等待某个特殊的信息包时是有用的。信息包收集器和监听器可以通过
XMPPConnection的实例来创建。&lt;/p&gt;

&lt;p&gt;由org.jivesoftware.smack.filter.PacketFilter接口来决定哪个特殊的信息包将被转交给信息包收集器（PacketCollector）或信息包监听器（PacketListener）。可以在org.jivesoftware.smack.filter包中找到许多预先定义的过滤器。
以下代码阐释了如何注册一个信息包收集器（packet collector）和信息包监听器（packet listener）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Create a packet filter to listen for new messages from a particular
// user. We use an AndFilter to combine two other filters.
PacketFilter filter = new AndFilter(new PacketTypeFilter(Message.class),
new FromContainsFilter(&quot;mary@jivesoftware.com&quot;));
// Assume we&#39;ve created an XMPPConnection name &quot;connection&quot;.
 
// First, register a packet collector using the filter we created.
PacketCollector myCollector = connection.createPacketCollector(filter);
// Normally, you&#39;d do something with the collector, like wait for new packets.
 
// Next, create a packet listener. We use an anonymous inner class for brevity.
PacketListener myListener = new PacketListener() {
public void processPacket(Packet packet) {
// Do something with the incoming packet here.
}
};
// Register the listener.
connection.addPacketListener(myListener, filter);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;标准信息包过滤器（Standard Packet Filters）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Smack包含一套丰富的信息包过滤器，你也可以通过信息包过滤器接口（PacketFilter interface）编写程序来创建自己的过滤器。缺省的过滤器集包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PacketTypeFilter – 某个特殊的类类型的信息包过滤器&lt;/li&gt;
  &lt;li&gt;PacketIDFilter – 拥有特殊的信息包ID（packet ID）的过滤器&lt;/li&gt;
  &lt;li&gt;ThreadFilter – 拥有特殊线程ID（thread ID）的信息包的过滤器&lt;/li&gt;
  &lt;li&gt;ToContainsFilter –发送到某个特殊地址的信息包的过滤器&lt;/li&gt;
  &lt;li&gt;FromContainsFilter –发送到某个特殊地址的信息包的过滤器&lt;/li&gt;
  &lt;li&gt;PacketExtensionFilter – 拥有特殊的信息包扩展的信息包的过滤器&lt;/li&gt;
  &lt;li&gt;AndFilter –对两个过滤器实施逻辑与操作的过滤器&lt;/li&gt;
  &lt;li&gt;OrFilter –对两个过滤器实施逻辑或操作的过滤器&lt;/li&gt;
  &lt;li&gt;NotFilter –对一个过滤器实施逻辑非操作的过滤器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Provider Architecture: Packet Extensions and Custom IQ’s
Smack提供的体系是堵塞自定义的XML信息包扩展和IQ包分析器的系统（The Smack provider architecture is a system for plugging in custom XML parsing of packet extensions and IQ packets）。标准的Smack扩展（Smack Extensions）是使用提供者的体系结构搭建的。存在以下两种类型的提供者：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IQProvider –将IQ请求（ IQ requests）解析成Java对象（Java objects）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PacketExtension – 将附属在信息包上的XML子文档解析成信息包扩展实例（PacketExtension instances）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;IQProvider&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认情况下，Smack致知道如何处理只有类似以下几个名字空间的子信息包的IQ信息包（IQ packets）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jabber:iq:auth&lt;/li&gt;
  &lt;li&gt;jabber:iq:roster&lt;/li&gt;
  &lt;li&gt;jabber:iq:register&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为许多IQ类型是XMPP及其扩展部分的一部分，所以提供一个可插入的IQ分析机制。IQ Providers被程序自动的注册或通过创建在你的JAR 文件的META-INF目录下创建一个mack.providers文件。该文件是一个包含一个或多个iqProvider条目（iqProvider entries）的XML文档，如下例所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;smackProviders&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;iqProvider&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;elementName&amp;gt;&lt;/span&gt;query&lt;span class=&quot;nt&quot;&gt;&amp;lt;/elementName&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;namespace&amp;gt;&lt;/span&gt;jabber:iq:time&lt;span class=&quot;nt&quot;&gt;&amp;lt;/namespace&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;className&amp;gt;&lt;/span&gt;org.jivesoftware.smack.packet.Time&lt;span class=&quot;nt&quot;&gt;&amp;lt;/className&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;/iqProvider&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/smackProviders&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每一个IQ provider都和一个元素名（element name）和名字空间（ namespace）相联系。在上面的例子中，元素名是query，名字空间是abber:iq:time。如果有多重提供者条目（multiple provider entries）尝试注册并控制相同的名字空间，那么从类路径（classpath）载入的第一个条目将有优先权。&lt;/p&gt;

&lt;p&gt;IQ provider类可以实现IQProvide接口，或者继承IQ类。在前面的例子中，每一个IQProvider负责解析原始的XML流从而创建一个IQ实例。在下面的例子中，bean introspection将被用于尝试自动使用在IQ packet XML中发现的值设置IQ实例的属性。一个XMPP时间信息包如下所示：
    &lt;iq type=&quot;result&quot; to=&quot;joe@example.com&quot; from=&quot;mary@example.com&quot; id=&quot;time_1&quot;&gt;
    &lt;query xmlns=&quot;jabber:iq:time&quot;&gt;
    &lt;utc&gt;20020910T17:58:35&lt;/utc&gt;
    &lt;tz&gt;MDT&lt;/tz&gt;
    &lt;display&gt;Tue Sep 10 12:58:35 2002&lt;/display&gt;
    &lt;/query&gt;
    &lt;/iq&gt;&lt;/p&gt;

&lt;p&gt;为了让这个信息包自动的映射成上面的providers file中所列的时间对象（Time object），它必须有以下几个方法：setUtc(String), setTz(String), 和 setDisplay(String)。自动检查（introspection）的服务将试着自动的将字符串值转化成a boolean, int, long, float, double,或 Class 类型。转化成何种类型由IQ实例的需要来决定。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PacketExtensionProvider&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;信息包插件提供者（Packet extension providers）为信息包提供一个可插入的系统，这些信息包是一个IQ, message和presence packets的自定义名字空间的子元素。每一个插件提供者（extension provider）使用一个元素名（element name）和名字空间（namespace）在smack.providers文件中注册，如下例所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;smackProviders&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;extensionProvider&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;elementName&amp;gt;&lt;/span&gt;x&lt;span class=&quot;nt&quot;&gt;&amp;lt;/elementName&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;namespace&amp;gt;&lt;/span&gt;jabber:iq:event&lt;span class=&quot;nt&quot;&gt;&amp;lt;/namespace&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;className&amp;gt;&lt;/span&gt;org.jivesoftware.smack.packet.MessageEvent&lt;span class=&quot;nt&quot;&gt;&amp;lt;/className&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/extensionProvider&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/smackProviders&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果有多重提供者条目（multiple provider entries）尝试注册并控制相同的名字空间，那么从类路径（classpath）载入的第一个条目将有优先权。&lt;/p&gt;

&lt;p&gt;一旦在一个信息包中发现信息包插件，解析器将传递到正确的提供者。每一个提供者可以实现PacketExtensionProvider接口或者是一个标准的Java Bean。在前面的例子中，每一个插件提供者（extension provider）负责解析原始的XML流去构造一个实例。在下面的例子中，bean introspection将被用于尝试自动使用在信息包插件子元素（packet extension sub-element）中的值设置类的属性。&lt;/p&gt;

&lt;p&gt;当一个插件提供者（extension provider）没有用元素名（element name）和名字空间（namespace）对注册是，Smack将存储所有在缺省信息包插件（DefaultPacketExtension）对象中的最高级别元素（top-level elements），并匹配到信息包上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信息包属性（Packet Properties）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Smack提供简单的机制来将任意的属性附加到信息包上。每一个属性有个字符串类型的名字和一个值，这个值或者是Java原始数据类型（int, long, float, double, boolean）的，或者是任何可序列化的对象（Serializable object）（当一个java对象实现了Serializable接口时，它就是可序列化的）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用API（Using the API）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所有主要对象都有属性支持，例如消息对象（Message objects）。以下代码阐释了如何设置属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Message message = chat.createMessage();
// Add a Color object as a property.
message.setProperty(&quot;favoriteColor&quot;, new Color(0, 0, 255));
// Add an int as a property.
message.setProperty(&quot;favoriteNumber&quot;, 4);
chat.sendMessage(message);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获得这些相同的属性要用到以下的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Message message = chat.nextMessage();
// Get a Color object property.
Color favoriteColor = (Color)message.getProperty(&quot;favoriteColor&quot;);
// Get an int property. Note that properties are always returned as
// Objects, so we must cast the value to an Integer, then convert
// it to an int.
int favoriteNumber = ((Integer)message.getProperty(&quot;favoriteNumber&quot;)).intValue();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;将对象作为属性（Objects as Properties）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将对象作为属性值是改变数据的一个非常有力和简单的方法。但是，你应该记住以下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;信息包插件（Packet extensions）是向XMPP增加额外数据的更权威的方式。使用属性在某种情况下也许会比较方便，但是，Smack将会控制XML。&lt;/li&gt;
  &lt;li&gt;当你将Java对象（Java object）作为属性发送时，只有在客户机运行的Java能够解释数据。所以，可以考虑使用一系列的原始值来传递数据。&lt;/li&gt;
  &lt;li&gt;作为属性值发送的对象必须实现序列化接口（Serialiable）。&lt;/li&gt;
  &lt;li&gt;除此之外，发送者和接受者都必须由相同版本的类，否则在反序列化（de-serializing the object）对象时将发生序列化异常。&lt;/li&gt;
  &lt;li&gt;序列化的对象将会非常大，将会占用很多的服务器资源和带宽。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;XML格式（XML Format）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当前的用于发送属性的XML格式不是标准的，所以可能不会得到使用Smack的客户的认可。XML如下所示（为了更清晰添加了注释）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- All properties are in a x block. --&amp;gt;
&amp;lt;properties xmlns=&quot;http://www.jivesoftware.com/xmlns/xmpp/properties&quot;&amp;gt;
&amp;lt;!-- First, a property named &quot;prop1&quot; that&#39;s an integer. --&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;prop1&amp;lt;/name&amp;gt;
&amp;lt;value type=&quot;integer&quot;&amp;gt;123&amp;lt;/value&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;!-- Next, a Java object that&#39;s been serialized and then converted
 from binary data to base-64 encoded text. --&amp;gt; 
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;blah2&amp;lt;/name&amp;gt;
&amp;lt;value type=&quot;java-object&quot;&amp;gt;adf612fna9nab&amp;lt;/value&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当前支持的数据类型有：integer, long, float, double, boolean, string, 和java-object。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Smack调试（Debugging with Smack）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Smack包含两个内置的调试控制台，他们允许你在服务器和客户机建跟踪XML的踪迹。简单的调试器（lite debugger）是smack.jar的一部分，加强的调试器（enhanced debugger）包含在（smackx-debug.jar）中。&lt;/p&gt;

&lt;p&gt;可以用两种不同的方法激活调试模式：&lt;/p&gt;

&lt;p&gt;1．在创建连接前加入以下一行代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;XMPPConnection.DEBUG_ENABLED = true;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2．将Java的系统属性smack.debugEnabled设置为true。这一系统属性可通过下一命令行设置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java -Dsmack.debugEnabled=true SomeApp 在你的应用程序中，如果你想明确的禁用调试模式，包括使用命令行参数，则在打开新的连接前在你的应用程序中添加以下一行代码：

XMPPConnection.DEBUG_ENABLED = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Smack使用一下的逻辑来决定使用哪个调制控制台：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;它将首先尝试使用Java系统属性smack.debuggerClass 所指定的调试类（debugger class）。如果你需要开发自己的调试器 I，可以实现SmackDebugger 接口然后使用下面的命令行设置系统属性：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java -Dsmack.debuggerClass=my.company.com.MyDebugger SomeApp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果第一步失败了，Smack就会尝试使用增强的调试器（enhanced debugger）。 文件 smackx-debug.jar 包含，因此你要把jar文件放到类路径（classpath）下。如果空间确定你只是想要配置smack.jar文件，这种情况下增强的调试器（enhanced debugger）将不可用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后一种是前面两种都失败后使用简单的调试器（ite debugger）。在你的内存很小的时候，简单的调试器（ite debugger）是一个很好的选择。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;增强的调试器（enhanced debugger）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当调试模式可用时，将出现一个包含每一个创建的连接的标签调试窗口，该窗口包含以下信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;连接标签（Connection tabs） -每一个标签显示连接相关的调试信息&lt;/li&gt;
  &lt;li&gt;Smack信息标签（Smack info tab） -显示关于Smack的信息 (例如： Smack的版本（Smack version）, 安装的组件（installed components）,等等)。&lt;/li&gt;
  &lt;li&gt;连接标签包含以下信息:&lt;/li&gt;
  &lt;li&gt;所有的信息包（All Packets） -显示由Smack解析的发送和收到的信息包的信息。&lt;/li&gt;
  &lt;li&gt;未经处理的发送信息包（Raw Sent Packets） -未经处理的XML traffic（raw XML traffic）由Smack生成并发送至服务器 。&lt;/li&gt;
  &lt;li&gt;未经处理的接收信息包（Raw Received Packets） –未经处理的XML traffic（raw XML traffic）由服务器发送给客户机。&lt;/li&gt;
  &lt;li&gt;Ad-hoc 消息（Ad-hoc message） -允许发送各种类型的ad-hoc信息包（ad-hoc packets）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;信息—显示连接状态和统计信息。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简单的调试器（Lite Debugger ）
当调试模式可用时，每创建一个连接将出现调试窗口，该窗口包含以下信息：&lt;/p&gt;

&lt;p&gt;客户端的流量（Client Traffic） (红色的文本) –未经处理的XML traffic（raw XML traffic）由Smack生成并发送至服务器 。&lt;/p&gt;

&lt;p&gt;服务器端的流量（Server Traffic）(蓝色的文本) –未经处理的XML traffic（raw XML traffic）由服务器发送给客户机。&lt;/p&gt;

&lt;p&gt;解释的信息包（Interpreted Packets）(绿色的文本) – 显示来自服务器的由Smack解析的XML信息包（XML packets）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>XMPP协议分析-原理</title>
   <link href="http://http://coolshell.info/blog/2014/10/xmpp.html"/>
   <updated>2014-10-28T00:00:00+00:00</updated>
   <id>/blog/2014/10/xmpp</id>
   <content type="html">&lt;h1 id=&quot;xmpp&quot;&gt;XMPP协议简介&lt;/h1&gt;

&lt;p&gt;XMPP协议（Extensible Messaging and PresenceProtocol，可扩展消息处理现场协议）是一种基于XML的协议，目的是为了解决及时通信标准而提出来的，最早是在Jabber上实现的。它继承了在XML环境中灵活的发展性。因此，基于XMPP的应用具有超强的可扩展性。并且XML很易穿过防火墙，所以用XMPP构建的应用不易受到防火墙的阻碍。利用XMPP作为通用的传输机制，不同组织内的不同应用都可以进行有效的通信。&lt;/p&gt;

&lt;h2 id=&quot;xmpp-1&quot;&gt;XMPP协议特点&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;所有XMPP信息都是以XML为基础的，信息交换的事实标准，扩展性强&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XMPP系统是一个分布式系统，每台服务器控制自己的资源，但是如果需要，它能与外在的系统进行通信。XMPP服务器利用开放的XML协议来进行S2S(Serverto Server)通信，就像在C2S(Client to Server)一样。相比之下，大多数的IM系统使用了只是支持C2S/S2C通信的协议，因此Jabber/XMPP服务器具有更大的灵活性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XMPP协议是公开的，程序则开放源代码。定义了客户端和服务器端的交互要经由XML流。普通消息类型（message），如改变状态(presence)，传递消息内容或查询/更新(info/quey)应用则用每个指定的命名空间(namespace)来建立。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;状态(Presence)在整个持久连接中。通过持久连接的有效维持，XMPP协议一直有在网络中维持存在和可用信息的能力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XMPP允许建立并行的TCP套接字连接对所有连接上的客户端和服务器端。一旦建立连接，则只有当状态改变，例如存在的改变，通过这个连接传输数据。既然这个连接是持久的，那么设置、认证、状态查找功能都不用每次都重复执行。这种持久的套接字的连接使得XMPP能够更有效的支持高级的具有存在能力的应用在带宽和处理资源的使用中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jabber/XMPP系统是模块化的，而且Jabber/XMPP的设计强调如何实现可伸缩性、安全性和可扩展性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;xmpp-2&quot;&gt;XMPP协议分析&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   XMPP中定义了三个角色：客户端，服务器，网关。 通信能够在这三者的任意两个之间双向发生。服务器同时承担了客户端信息记录，连接管理和信息的路由功能。网关承担着与异构即时通信系统的互联互通，异构系统可以包括SMS （短信），MSN，ICQ等。基本的网络形式是单客户端通过TCP/IP连接到单服务器，然后在之上传输XML。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;XMPP的基本网络结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C1----S1---S2---C3
|
C2----+--G1===FN1===FC1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;符号表示：C1,C2,C3=XMPP客户端；S1,S2=XMPP；服务端G1=在XMPP和使用外部消息网络（非XMPP）的协议之间转换的网；FN1=外部消息网络；FC1=外部消息网络的客户端。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）服务器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务系统是XMPP通信的智能提取层，它主要负责：管理来自其他个体的会话连接或者XML流（streams）和来自客户端、服务器、其他个体的认证发送在XML流实体之中的适当的XML地址节点。大多数XMPP服务都允许存储一些客户端数据（比如联系人列表），在这种情况下，服务直接面向这个客户端处理XML数据，而不是其他个体。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）客户端&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大多数客户端是通过TCP直接连接，并且使用XMPP获得服务器提供全部-12-第2章Jabber协议原理及其应用功能和其他服务。许多资源通过认证的客户端也许同时连接到服务器，定义在XMPP地址的每个资源是不同的（比如&lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#110;&amp;#111;&amp;#100;&amp;#101;&amp;#064;&amp;#100;&amp;#111;&amp;#109;&amp;#097;&amp;#105;&amp;#110;&amp;#047;&amp;#104;&amp;#111;&amp;#109;&amp;#101;&amp;#062;和&amp;#060;&amp;#110;&amp;#111;&amp;#100;&amp;#101;&amp;#064;&amp;#100;&amp;#111;&amp;#109;&amp;#097;&amp;#105;&amp;#110;&amp;#047;&amp;#119;&amp;#111;&amp;#114;&amp;#107;&quot;&gt;node@domain/home&amp;gt;和&amp;lt;node@domain/work&lt;/a&gt;）建议服务器和客户端采用的端中是5222。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）网关&lt;/strong&gt;
它的主要功能是将XMPP协议转换成外部消息(non-XMPP)系统使用的协议,也将返回的数据转换成XMPP。这些通信是基于网关和服务器，基于网关和外部消息系统之间的。&lt;/p&gt;

&lt;h2 id=&quot;xmpp-3&quot;&gt;XMPP消息格式&lt;/h2&gt;

&lt;p&gt;Jabber/XMPP系统使用XML流在不同实体之间相互传输数据。在两个实体的连接期间，XML流将从一个实体传送到另一个实体。在实体间，有三个顶层的XML元素:&lt;message&gt;&lt;/message&gt;，&lt;presence&gt;&lt;/presence&gt;和&lt;iq&gt;&lt;/iq&gt;。每一个都包含属性和子节点。下面将分别描述这些元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1)消息(message)元素：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个即时消息系统最基本的功能就是能够在两个用户之间实时交换消息，&lt;message&gt;&lt;/message&gt;元素就提供了这个功能。每条消息都有一个或多个属性和子元素。属性“from”和“to”分别表示了消息发送者和接收者的地址。&lt;message&gt;&lt;/message&gt;也可以包含一个“type”属性，这给接收者一个提示，这个消息是什么样的消息。表3-1给出了“type”属性的可能取值。&lt;message&gt;&lt;/message&gt;中也可以包含“id”属性，用来唯一的标识一个输出消息的响应。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2)状态(presence)元素:&lt;/strong&gt;&lt;/p&gt;

&lt;presence /&gt;
&lt;p&gt;元素用来传递一个用户的存在状态的感知信息。用户可以是“available”，要么是“unavailable”，“Hide”等。当用户连接到即时消息服务器后，好友发给他的消息就立即被传递。如果用户没有连接到服务器，好友发给他的消息将被服务器存储起来直到用户连接到服务器。用户通过即时消息客户端自己控制可用性。但是，如果用户断开了同服务器的连接，服务器将发送给订阅了这个用户的存在信息的用户通知他们用户已经不可用。&lt;presence&gt;&lt;/presence&gt;还包含了两个子元素：&lt;show&gt;&lt;/show&gt;和&lt;status&gt;&lt;/status&gt;。&lt;status&gt;包含了一个对&lt;show&gt;&lt;/show&gt;的文本描述。&lt;/status&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3)IQ(Info&amp;lt;Query)元素&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IQ元素是Jabber/XMPP消息协议的第三个顶层元素。IQ代表”Info/Query”，用来发送和获取实体之间的信息。IQ消息是通过“请求/响应”机制在实体间进行交换的。IQ元素用于不同的目的，它们之间通过不同的命名空间来加以区分。在Jabber/XMPP消息协议里有许多的命名空间，但最常用的命名空间是：”jabber:iq:register”,”jabber:iq:auth”,”jabber:iq:roster”。&lt;/p&gt;

&lt;p&gt;上面描述了Jabber协议的三个顶层节点。通过这种格式Jabber消息不仅可以是简单的文本（text），而且可以携带复杂的数据和各种格式的文件，也就是说Jabber不仅可以用在人与人之间的交流，而且可以实现软件与软件或软件与人之间的交流。Jabber的这种功能大大扩展了即时通信的应用范围。&lt;/p&gt;

&lt;h2 id=&quot;xmpp-4&quot;&gt;XMPP工作机制&lt;/h2&gt;

&lt;p&gt;例如:一个终端名字是Remeo，通过服务器montague.lit与其他的用户相连，其他的用户通过服务器juliet@capulet.lit建立连接。&lt;/p&gt;

&lt;p&gt;第一步Romeo开始通过发送一个stream包与服务器montague.lit取得联系，这一步包含了鉴权，登录等等。&lt;/p&gt;

&lt;p&gt;第二步Romeo获取了他的联系人列表，通过向服务器montague.lit发送&lt;iq&gt;&lt;/iq&gt;字段请求，按照下面的协议。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;iq type=‘get’from=‘romeo@montague.lit/pda’&amp;gt;
&amp;lt;query xmlns=‘jabber:iq:roster’/&amp;gt;
&amp;lt;/iq&amp;gt;

&amp;lt;iq type=‘result’to=‘romeo@montague.lit/pda’&amp;gt;
&amp;lt;query xmlns=‘jabber:iq:roster’&amp;gt;
&amp;lt;item jid=‘juliet@capulet.lit’/&amp;gt;&amp;lt;item jid=‘mercutio@shakespeare.lit’/&amp;gt;
&amp;lt;item jid=‘benvolio@shakespeare.lit’/&amp;gt;
&amp;lt;/query&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第三步Romeo发送了一个presence请求到服务器montague.lit，然后会将这个信息广播到他的所有好友。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;presence from=‘romeo@montague.lit/pda’/&amp;gt;
&amp;lt;presence from=‘romeo@montague.lit/pda’to=‘juliet@capulet.lit’/&amp;gt;
&amp;lt;presence from=‘romeo@montague.lit/pda’to=‘mercutio@shakespeare.lit’
/&amp;gt;
&amp;lt;presence from=‘romeo@montague.lit/pda’to=‘benvolio@shakespeare.lit’
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第四步如果Romeo的联系人都在线，就会将presence回复给Romeo，告知自己的状态。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;presence to=‘romeo@montague.lit/pda’from=‘juliet@capulet.lit/balcony’/&amp;gt;
&amp;lt;presence to=‘romeo@montague.lit/pda’from=‘juliet@capulet.lit/chamber’/&amp;gt;
&amp;lt;presence to=‘romeo@montague.lit/pda’from=‘mercutio@shakespeare.lit/home’/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第五步Romeo和Juliet开始交换信息，进行聊天。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;message from=‘romeo@montague.lit/pda’to=‘juliet@capulet.lit’&amp;gt;
&amp;lt;body&amp;gt;hi!&amp;lt;/body&amp;gt;
&amp;lt;/message&amp;gt;

&amp;lt;message from=‘juliet@capulet.lit/balcony’to=‘romeo@montague.lit/pda’
  	&amp;gt; 
&amp;lt;body&amp;gt;hi yourself!&amp;lt;/body&amp;gt;
&amp;lt;/message&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以文档的观点来看，客户端或服务器发送的所有XML文本连缀在一起，从&lt;stream&gt;到&lt;/stream&gt;构成了一个完整的XML文档。其中的stream标签就是所谓的XML Stream。在&lt;stream&gt;与&lt;/stream&gt;中间的那些&lt;message&gt;...&lt;/message&gt;这样的XML元素就是所谓的XML Stanza（XML节）。XMPP核心协议通信的基本模式就是先建立一个stream，然后协商一堆安全之类的东西，中间通信过程就是客户端发送XML Stanza，一个接一个的。服务器根据客户端发送的信息以及程序的逻辑，发送XML Stanza给客户端。但是这个过程并不是一问一答的，任何时候都有可能从一个方发信给另外一方。通信的最后阶段是&amp;lt;/stream&amp;gt;关闭流，关闭TCP/IP连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/openfire/xmpp1.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>当我们打开网页时发生了什么</title>
   <link href="http://http://coolshell.info/blog/2014/10/how-http-works.html"/>
   <updated>2014-10-11T00:00:00+00:00</updated>
   <id>/blog/2014/10/how-http-works</id>
   <content type="html">&lt;p&gt;简单地来说，当我们在浏览器上输入URL的敲下回车的时候。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;浏览器需要查找域名[domain]的IP，从不同的缓存直至DNS服 务器。&lt;/li&gt;
  &lt;li&gt;浏览器会给web服务器发送一个HTTP请求&lt;/li&gt;
  &lt;li&gt;服务器“处理”请求&lt;/li&gt;
  &lt;li&gt;服务器发回一个HTTP响应&lt;/li&gt;
  &lt;li&gt;浏览器渲染HTML到页面。
 比如我们从&lt;a href=&quot;http://www.joes-hardware.com:80/power-tools.html&quot;&gt;http://www.joes-hardware.com:80/power-tools.html&lt;/a&gt;获取资源的时候，整个过程如下图所示：
 &lt;img src=&quot;/images/images/http/1.jpeg&quot; alt=&quot;&quot; /&gt;
开始时我们输入的是URI(统一资源标识符,Uniform Resource Identifier)，我们用的比较多的是URI的一个子集叫统一资源定位符(URL,Uniform Resource Locator)。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;url&quot;&gt;URL组成&lt;/h2&gt;
&lt;p&gt;网址算是URL的一个俗称，让我们来看看一个URL的组成，以HTTP版IOT中的URL为例。
大多数URL都建立在这个通用格式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;scheme&amp;gt;://&amp;lt;user&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;path&amp;gt;;&amp;lt;params&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;frgs&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;各个部分的介绍如下表：
&lt;img src=&quot;/images/images/http/0.jpeg&quot; alt=&quot;&quot; /&gt;
以一个实际例子来说：
当我们在浏览器中输入&lt;a href=&quot;http://b.phodal.com/athome/1&quot;&gt;http://b.phodal.com/athome/1&lt;/a&gt;按下回车&lt;/p&gt;

&lt;p&gt;开始之前，我们需要标出URL的80端口以及json文件的全称，那么上面的网址就会变成&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://b.phodal.com:80/athome/1.json&quot;&gt;http://b.phodal.com:80/athome/1.json&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么对于这个URL的就有下面几部分组成&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;http:&lt;/strong&gt;// http说的是这个URL用的是HTTP协议，至于//是一个分隔符，用法和C语言中的;一样。这样的协议还可以是coap,https,ftp等等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;b&lt;/strong&gt; 是子域名，一个域名在允许的情况下可以有不限数量的子域名。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;phodal.com&lt;/strong&gt; 代表了一个URL是phodal.com下面的域名&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;80&lt;/strong&gt; 80是指80端口，http默认的都是80，对于一个不是80端
 口的URL应该是这样的http://iot-coap.phodal.com:8896/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;athome&lt;/strong&gt; 指的是虚拟目录部分，或者文件路径&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;1.json&lt;/strong&gt;看上去就是一个文件名，然而也代表着这是一个资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对就一个稍微复杂点的例子就是
&lt;a href=&quot;http://designiot.phodal.com/#%E4%BD%A0%E6%89%80%E6%B2%A1%E6%9C%89%E6%B7%B1%E5%85%A5%E7%9A%84http&quot;&gt;http://designiot.phodal.com/#你所没有深入的http&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里的#后面是片段部分（frag），如果你打开这个URL就会发现会直接跳转到相应的片段，对就于下面这样的一个例子来说&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.phodal.com/search;sales=false/?q=iot&amp;amp;type=blog&quot;&gt;http://www.phodal.com/search;sales=false/?q=iot&amp;amp;type=blog&lt;/a&gt;
&lt;strong&gt;;&lt;/strong&gt;后面是&lt;strong&gt;参数部分&lt;/strong&gt;，以便正确的与服务器进行交互
&lt;strong&gt;?&lt;/strong&gt;后面的q=iot&amp;amp;type=blog的部分是&lt;strong&gt;查询字符串&lt;/strong&gt;，通常用于查询或者、搜索。&lt;/p&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP报文&lt;/h2&gt;

&lt;p&gt;http客户端向http服务器发送请求报文，请求报文格式如下：
请求行
首部
空行
主体部分&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;method&amp;gt;&amp;lt;request-URL&amp;gt;&amp;lt;version&amp;gt;
&amp;lt;headers&amp;gt;

&amp;lt;entity-body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;响应报文的格式如下：
响应行
首部
空行
主体&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;version&amp;gt;&amp;lt;status&amp;gt;&amp;lt;reason-phase&amp;gt;
&amp;lt;headers&amp;gt;

&amp;lt;entity-body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方法method，常见的有get和post，是客户端希望服务器对资源执行的动作&lt;/li&gt;
  &lt;li&gt;请求URL。所请求资源的完整URL或者相对路径&lt;/li&gt;
  &lt;li&gt;版本version，报文使用的http版本，比如HTTP1.1&lt;/li&gt;
  &lt;li&gt;首部header，向请求报文和响应报文添加了一些信息，本质上都是一些名/值对的列表。&lt;/li&gt;
  &lt;li&gt;状态码（status）描述请求过程发生的情况，比如200，表示OK&lt;/li&gt;
  &lt;li&gt;原因短语(reason-phase),数字状态码的可读版本&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实体的主体部分(entity-body)
 一个可能的请求报文图下：&lt;/p&gt;

    &lt;p&gt;GET /java/2014/08/02/java-multithread.html HTTP1.1
  Accept:text/html
  Host: www.lippiouyangonline.info&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可能的响应报文如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; HTTP/1.1 200 OK
 content-type: text/plain
 content-length: 19
 
 Hi,I&#39;m a message! 下面是一个POST方法示例：    ![](/images/images/http/2.jpeg)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;连接管理&lt;/h2&gt;
&lt;p&gt;几乎所有的HTTP通信都是由TCP/IP承载的，HTTP要传送一个报文，会以流的形式将报文数据内容通过一条打开的TCP连接按序传输。TCP收到数据流后会将数据流切成小段的数据块，并将段封装在IP分组中，通道因特网进行传输，每个IP分组包括：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1. 一个IP分组首部(通常为20字节)
 2. 一个TCP段首部(通常为20字节)
 3. 一个TCP数据块(0个或者多个字节)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;IP首部包括源和目的的的IP地址，长度和其他一些标记，TCP首部包括TCP端口号和控制标记。 端口号和电话分机很类似，就像公司的总机号码能将你接到前台，分机号码帮你找到正确的联系人。IP地址可能将你链接的正确的计算机，端口号将你连接到正确的应用程序上去，端口号就是一个数字，HTTP的默认端口号为80。
TCP连接是通过4个值来识别的：
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;源IP地址、源端口号、目地IP地址、目地端口号&amp;gt;&lt;/code&gt;这4个值唯一定义了一条TCP连接。
 一个TCP分组如下：
  &lt;img src=&quot;/images/images/http/3.jpeg&quot; alt=&quot;&quot; /&gt;
一个典型的TCP客户端和服务器的通信过程如下：
 &lt;img src=&quot;/images/images/http/4.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;待续…
参考书目：HTTP权威指南&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>处理并发之二：libevent的eventbuffer</title>
   <link href="http://http://coolshell.info/blog/2014/08/libevent.html"/>
   <updated>2014-08-24T00:00:00+00:00</updated>
   <id>/blog/2014/08/libevent</id>
   <content type="html">&lt;p&gt;bufferevent这个结构体&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct bufferevent {
	struct event_base *ev_base;  
	const struct bufferevent_ops *be_ops;  
	struct event ev_read;  
	struct event ev_write;  
	struct evbuffer *input;  
	struct evbuffer *output;   																	           
	bufferevent_data_cb readcb;   	     																                                     bufferevent_data_cb writecb;      																		           bufferevent_event_cb errorcb;  
    }  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出struct bufferevent内置了两个event（读/写）和对应的缓冲区。当有数据被读入(input)的时候，readcb被调用，当output被输出完成的时候，writecb被调用，当网络I/O出现错误，如链接中断，超时或其他错误时，errorcb被调用。
使用bufferevent的过程：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 设置sock为非阻塞的&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eg:  evutil_make_socket_nonblocking(fd);  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2. 使用bufferevent_socket_new创建一个structbufferevent *bev，关联该sockfd，托管给event_base&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;函数原型为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;struct bufferevent * bufferevent_socket_new(struct event_base
*base, evutil_socket_t fd,  int options)&lt;br /&gt;
    		eg:  struct bufferevent *bev;&lt;br /&gt;
    		bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3. 设置读写对应的回调函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;函数原型为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;void bufferevent_setcb(struct bufferevent *bufev, &lt;br /&gt;
bufferevent_data_cb readcb, bufferevent_data_cb writecb,&lt;br /&gt;
bufferevent_event_cb eventcb, void *cbarg)   eg. 
bufferevent_setcb(bev, readcb, NULL, errorcb, NULL);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4. 启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;函数原型：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int bufferevent_enable(struct bufferevent *bufev, short event)   	eg. bufferevent_enable(bev, EV_READ|EV_WRITE);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5. 进入bufferevent_setcb回调函数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在readcb里面从input中读取数据，处理完毕后填充到output中； 	writecb对于服务端程序，只需要readcb就可以了，可以置为NULL； 	errorcb用于处理一些错误信息。&lt;/p&gt;

&lt;p&gt;针对这些使用过程进入源码进行分析：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. bufferevent_socket_new&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在bufferevent_init_common中调用evbuffer_new()初始化input和output&lt;/li&gt;
  &lt;li&gt;在event_assign中初始化bufferevent中的ev_read和ev_write事件。&lt;/li&gt;
  &lt;li&gt;在evbuffer_add_cb中给output添加了一个callback bufferevent_socket_outbuf_cb&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. bufferevent_setcb&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;该函数的作用主要是赋值，把该函数后面的参数，赋值给第一个参数struct bufferevent *bufev定义的变量 **3. bufferevent_enable**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用event_add将读写事件加入到事件监听队列中。&lt;/p&gt;

&lt;p&gt;对bufferevent常用的几个函数进行分析：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char *evbuffer_readln(struct evbuffer*buffer, size_t *n_read_out,enum evbuffer_eol_style eol_style);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;含义：Read a single line from an evbuffer.
	返回值：读到的一行内容&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;int evbuffer_add(struct evbuffer *buf,const void *data, size_t
datlen);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：将数据添加到evbuffer的结尾
返回值：成功返回0，失败返回-1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;int evbuffer_remove(struct evbuffer*buf, void *data, size_t datlen);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;含义：从evbuffer读取数据到data
返回值：成功返回0，失败返回-1&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;size_t evbuffer_get_length(const structevbuffer *buf);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;含义：返回evbuffer中存储的字节长度
	暂时先分析到这里，下面是代码，客户端发送消息：HTTP/1.0, Client 0 send Message:
	Request: Hello Server! over，服务端一条消息收完成后，会回复：Response ok! Hello Client!
	服务端从bufferevent中取出消息是按行取的。代码可能有不完善的地方，由于才疏学浅，研究时间短（3天），希望高手提出宝贵意见。&lt;/p&gt;

&lt;p&gt;buffer_server.c&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;netinet/in.h&amp;gt;  
#include &amp;lt;sys/socket.h&amp;gt;  
#include &amp;lt;fcntl.h&amp;gt;   		  
#include &amp;lt;event2/event.h&amp;gt;  
#include &amp;lt;event2/buffer.h&amp;gt;  
#include &amp;lt;event2/bufferevent.h&amp;gt;      		  
#include &amp;lt;assert.h&amp;gt;  
#include &amp;lt;unistd.h&amp;gt;  
#include &amp;lt;string.h&amp;gt;  
#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
#include &amp;lt;errno.h&amp;gt;  
   	void do_read(evutil_socket_t fd, short events, void *arg);  
   	//struct bufferevent内建了两个event(read/write)和对应的缓冲区(struct evbuffer *input, *output)，并提供相应的函数用来操作缓冲区(或者直接操作bufferevent)   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

   	//接收到数据后，判断是不一样一条消息的结束，结束标志为”over”字符

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void readcb(struct bufferevent *bev, void *ctx)  
{	 
    printf(&quot;called readcb!\n&quot;);   		
    struct evbuffer *input, *output;  
    char *request_line;  
    size_t len;  
    //其实就是取出bufferevent中的input  
    input = bufferevent_get_input(bev);
    //其实就是取出bufferevent中的output 
    output = bufferevent_get_output(bev);						  
    size_t input_len = evbuffer_get_length(input);  								    
    printf(&quot;input_len: %d\n&quot;, input_len);  
    size_t output_len = evbuffer_get_length(output);  										   
    printf(&quot;output_len: %d\n&quot;, output_len);  											  											   
    while(1){														    														        
    	//从evbuffer前面取出一行，用一个新分配的空字符结束		
    	//的字符串返回这一行,EVBUFFER_EOL_CRLF表示行尾是一个可选的回车，后随一个换行符
    	request_line = evbuffer_readln(input, &amp;amp;len, EVBUFFER_EOL_CRLF);
    	if(NULL == request_line){ 		
			printf(&quot;The first line has not arrived yet.\n&quot;);  																										           
			free(request_line);//之所以要进行free是因为 line = mm_malloc(n_to_copy+1))，在这里进行了malloc  																													
			break;  																																      
    	} else {																				  																				   
    			printf(&quot;Get one line date: %s\n&quot;, request_line); 																				         
    			//用于判断是不是一条消息的结束  																										             
				if(strstr(request_line, &quot;over&quot;) != NULL)					{																														    																														     
					char *response = &quot;Response ok! Hello Client!\r\n&quot;;  																																				                 
					//Adds data to an event buffer  
					evbuffer_add(output, response, strlen(response));
																																							                 
					printf(&quot;服务端接收一条数据完成，回复客户端一条消息: %s\n&quot;, response); 																																												                
					free(request_line);  																																														   
					break;  																																																		             
					}  																										       
    			}  																          
    	free(request_line);  																		     
    	}  												 
		size_t input_len1 = evbuffer_get_length(input);  													   
		printf(&quot;input_len1: %d\n&quot;, input_len1);  														   
		size_t output_len1 = evbuffer_get_length(output);  															    
		printf(&quot;output_len1: %d\n\n&quot;, output_len1);  
}         

void errorcb(struct bufferevent *bev, short error, void *ctx)  
{  
	if (error &amp;amp; BEV_EVENT_EOF) { 
		/* connection has been closed, do any clean up here */   	 
		printf(&quot;connection closed\n&quot;);  
		}else if (error &amp;amp; BEV_EVENT_ERROR){					    
			/* check errno to see what error occurred */  
			printf(&quot;some other error\n&quot;);  
			} else if (error &amp;amp; BEV_EVENT_TIMEOUT) 
				/* must be a timeout event handle, handle it */  
				printf(&quot;Timed out\n&quot;);  
	      		}  
	bufferevent_free(bev);   
}

void do_accept(evutil_socket_t listener, short event, void *arg)  
{
	struct event_base *base = arg;  
	struct sockaddr_storage ss;  
	socklen_t slen = sizeof(ss);  
	int fd = accept(listener, (struct sockaddr*)&amp;amp;ss, &amp;amp;slen);  
	if (fd &amp;lt; 0){
		perror(&quot;accept&quot;);  
	}else if (fd &amp;gt; FD_SETSIZE){  
		close(fd);  
	 }else {
		 struct bufferevent *bev;
		 evutil_make_socket_nonblocking(fd);  													    														         
		 //使用bufferevent_socket_new创建一个struct bufferevent*bev，
		 //关联该sockfd，托管给event_base  													         
		 //BEV_OPT_CLOSE_ON_FREE表示释放bufferevent时关闭底层传输端口。
		 //这将关闭底层套接字，释放底层bufferevent等。  														         
		 bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);  														    																         
		 //设置读写对应的回调函数  
		 bufferevent_setcb(bev, readcb, NULL, errorcb, NULL);  
		 bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);  																    																		        
		 //启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。
		 //正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的  																			         
		 bufferevent_enable(bev, EV_READ|EV_WRITE);  																		
	 }  
}     
	
void run(void){	  
	evutil_socket_t listener;   		
	struct sockaddr_in sin;  
	struct event_base *base;  
	struct event *listener_event;  			  
	base = event_base_new();  
	if (!base)  
	return; 
	 sin.sin_family = AF_INET;  
	 sin.sin_addr.s_addr = 0;  			
	 sin.sin_port = htons(8000); 								  									
	 listener = socket(AF_INET, SOCK_STREAM, 0);  
	 evutil_make_socket_nonblocking(listener);  		
	 
	#ifndef WIN32{    				

									 														        
int one = 1;  																      
setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, 
&amp;amp;one, sizeof(one));  
}    
#endif  
if(bind(listener, (struct sockaddr*)&amp;amp;sin, sizeof(sin)) &amp;lt; 0){																   															         
	perror(&quot;bind&quot;);  																		         
	return;  																				    
}  														
if (listen(listener, 16)&amp;lt;0){																    																         
	perror(&quot;listen&quot;);    																    																          
	return;     
}  										  
											  
listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void*)base);
event_add(listener_event, NULL);  																									     													   
event_base_dispatch(base);  
}  
int main(int argc, char **argv){    	  
	setvbuf(stdout, NULL, _IONBF, 0); 	  
	run();  
	return 0; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>处理并发之一：LINUX Epoll机制介绍</title>
   <link href="http://http://coolshell.info/blog/2014/08/linux-epoll.html"/>
   <updated>2014-08-23T00:00:00+00:00</updated>
   <id>/blog/2014/08/linux-epoll</id>
   <content type="html">&lt;p&gt;Epoll可是当前在Linux下开发大规模并发网络程序的热门人选，Epoll 在Linux2.6内核中正式引入，和select相似，其实都I/O多路复用技术而已，并没有什么神秘的。&lt;/p&gt;

&lt;p&gt;其实在Linux下设计并发网络程序，向来不缺少方法，比如典型的Apache模型（Process Per Connection，简称PPC），TPC（Thread Per Connection）模型，以及select模型和poll模型，那为何还要再引入Epoll这个东东呢？那还是有得说说的…&lt;/p&gt;

&lt;p&gt;##2. 常用模型的缺点&lt;/p&gt;

&lt;p&gt;如果不摆出来其他模型的缺点，怎么能对比出Epoll的优点呢。&lt;/p&gt;

&lt;p&gt;###2.1 PPC/TPC模型&lt;/p&gt;

&lt;p&gt;这两种模型思想类似，就是让每一个到来的连接一边自己做事去，别再来烦我。只是PPC是为它开了一个进程，而TPC开了一个线程。可是别烦我是有代价的，它要时间和空间啊，连接多了之后，那么多的进程/线程切换，这开销就上来了；因此这类模型能接受的最大连接数都不会高，一般在几百个左右。&lt;/p&gt;

&lt;p&gt;###2.2 select模型&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;最大并发数限制，因为一个进程所打开的FD（文件描述符）是有限制的，由FD_SETSIZE设置，默认值是1024/2048，因此Select模型的最大并发数就被相应限制了。自己改改这个FD_SETSIZE？想法虽好，可是先看看下面吧…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;效率问题，select每次调用都会线性扫描全部的FD集合，这样效率就会呈现线性下降，把FD_SETSIZE改大的后果就是，大家都慢慢来，什么？都超时了？？！！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内核/用户空间 内存拷贝问题，如何让内核把FD消息通知给用户空间呢？在这个问题上select采取了内存拷贝方法。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###2.3 poll模型&lt;/p&gt;

&lt;p&gt;基本上效率和select是相同的，select缺点的2和3它都没有改掉。&lt;/p&gt;

&lt;p&gt;##3.Epoll的提升&lt;/p&gt;

&lt;p&gt;把其他模型逐个批判了一下，再来看看Epoll的改进之处吧，其实把select的缺点反过来那就是Epoll的优点了。&lt;/p&gt;

&lt;p&gt;3.1. Epoll没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于2048, 一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。&lt;/p&gt;

&lt;p&gt;3.2. 效率提升，Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。&lt;/p&gt;

&lt;p&gt;3.3. 内存拷贝，Epoll在这点上使用了“共享内存”，这个内存拷贝也省略了。&lt;/p&gt;

&lt;p&gt;##4. Epoll为什么高效&lt;/p&gt;

&lt;p&gt;Epoll的高效和其数据结构的设计是密不可分的，这个下面就会提到。&lt;/p&gt;

&lt;p&gt;首先回忆一下select模型，当有I/O事件到来时，select通知应用程序有事件到了快去处理，而应用程序必须轮询所有的FD集合，测试每个FD是否有事件发生，并处理事件；代码像下面这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int res = select(maxfd+1, &amp;amp;readfds, NULL, NULL, 120);
if(res &amp;gt; 0)

{
    for(int i = 0; i &amp;lt; MAX_CONNECTION; i++)
    {
        if(FD_ISSET(allConnection[i],&amp;amp;readfds))
        {
            handleEvent(allConnection[i]);
        }
    }
}
// if(res == 0) handle timeout, res &amp;lt; 0 handle error
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Epoll不仅会告诉应用程序有I/0事件到来，还会告诉应用程序相关的信息，这些信息是应用程序填充的，因此根据这些信息应用程序就能直接定位到事件，而不必遍历整个FD集合。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;intres = epoll_wait(epfd, events, 20, 120);

for(int i = 0; i &amp;lt; res;i++)
{
    handleEvent(events[n]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##5. Epoll关键数据结构&lt;/p&gt;

&lt;p&gt;前面提到Epoll速度快和其数据结构密不可分，其关键数据结构就是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct epoll_event {

    __uint32_t events;      // Epoll events

    epoll_data_t data;      // User datavariable

};

typedef union epoll_data {

    void *ptr;

   int fd;

    __uint32_t u32;

    __uint64_t u64;

} epoll_data_t;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结构体epoll_event 被用于注册所感兴趣的事件和回传所发生待处理的事件. 
其中epoll_data 联合体用来保存触发事件的某个文件描述符相关的数据. 
例如一个client连接到服务器，服务器通过调用accept函数可以得到于这个client对应的socket文件描述符，可以把这文件描述符赋给epoll_data的fd字段以便后面的读写操作在这个文件描述符上进行。epoll_event 结构体的events字段是表示感兴趣的事件和被触发的事件可能的取值为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;EPOLLIN ：表示对应的文件描述符可以读；&lt;/li&gt;
  &lt;li&gt;EPOLLOUT：表示对应的文件描述符可以写；&lt;/li&gt;
  &lt;li&gt;EPOLLPRI：表示对应的文件描述符有紧急的数据可读&lt;/li&gt;
  &lt;li&gt;EPOLLERR：表示对应的文件描述符发生错误；&lt;/li&gt;
  &lt;li&gt;EPOLLHUP：表示对应的文件描述符被挂断；&lt;/li&gt;
  &lt;li&gt;EPOLLET：表示对应的文件描述符有事件发生；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ET和LT模式&lt;/strong&gt;
LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。&lt;/p&gt;

&lt;p&gt;ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），内核不会发送更多的通知(only once)，不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。
ET和LT的区别在于LT事件不会丢弃，而是只要读buffer里面有数据可以让用户读，则不断的通知你。而ET则只在事件发生之时通知。可以简单理解为LT是水平触发，而ET则为边缘触发。
ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样;而LT模式是只要有数据没有处理就会一直通知下去的.&lt;/p&gt;

&lt;p&gt;##6. 使用Epoll&lt;/p&gt;

&lt;p&gt;既然Epoll相比select这么好，那么用起来如何呢？会不会很繁琐啊…先看看下面的三个函数吧，就知道Epoll的易用了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int epoll_create(int size);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;生成一个Epoll专用的文件描述符，其实是申请一个内核空间，用来存放你想关注的socket fd上是否发生以及发生了什么事件。size就是你在这个Epoll fd上能关注的最大socket fd数，大小自定，只要内存足够。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;EPOLL_CTL_ADD：注册新的fd到epfd中；&lt;/li&gt;
  &lt;li&gt;EPOLL_CTL_MOD：修改已经注册的fd的监听事件；&lt;/li&gt;
  &lt;li&gt;EPOLL_CTL_DEL：从epfd中删除一个fd；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等待I/O事件的发生；参数说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;epfd:由epoll_create() 生成的Epoll专用的文件描述符；&lt;/li&gt;
  &lt;li&gt;epoll_event:用于回传代处理事件的数组；&lt;/li&gt;
  &lt;li&gt;maxevents:每次能处理的事件数；&lt;/li&gt;
  &lt;li&gt;timeout:等待I/O事件发生的超时值；&lt;/li&gt;
  &lt;li&gt;返回发生事件数。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;##测试程序
首先对服务端和客户端做下说明：
我想实现的是客户端和服务端并发的程序，客户端通过配置并发数，说明有多少个用户去连接服务端。
客户端会发送消息：”Client: i send message Hello Server!”，其中i表示哪一个客户端；收到消息：”Recv Server Msg Content:%s\n”。
例如：
发送：Client: 1 send message “Hello Server!”
接收：Recv Derver Msg Content:Hello, client fd: 6
服务端收到后给客户端回复消息：”Hello, client fd: i”，其中i表示服务端接收的fd,用户区别是哪一个客户端。接收客户端消息：”Terminal Received Msg Content:%s\n”
例如：
发送：Hello, client fd: 6
接收：Terminal Received Msg Content:Client: 1 send message “Hello Server!”
备注：这里在接收到消息后，直接打印出消息，如果需要对消息进行处理（如果消息处理比较占用时间，不能立即返回，可以将该消息放入一个队列中，然后开启一个线程从队列中取消息进行处理，这样的话不会因为消息处理而阻塞epoll）。libenent好像对这种有2中处理方式，一个就是回调，要求回调函数，不占用太多的时间，基本能立即返回，另一种好像也是一个队列实现的，这个还需要研究。
服务端代码说明：
服务端在绑定监听后，开启了一个线程，用于负责接收客户端连接，加入到epoll中，这样只要accept到客户端的连接，就将其add EPOLLIN到epoll中，然后进入循环调用epoll_wait，监听到读事件，接收数据，并将事件修改为EPOLLOUT；反之监听到写事件，发送数据，并将事件修改为EPOLLIN。
&lt;strong&gt;服务器代码：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//cepollserver.h  
#ifndef  C_EPOLL_SERVER_H  
#define  C_EPOLL_SERVER_H  
  
#include &amp;lt;sys/epoll.h&amp;gt;  
#include &amp;lt;sys/socket.h&amp;gt;  
#include &amp;lt;netinet/in.h&amp;gt;  
#include &amp;lt;fcntl.h&amp;gt;  
#include &amp;lt;arpa/inet.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;iostream&amp;gt;  
#include &amp;lt;pthread.h&amp;gt;  
  
#define _MAX_SOCKFD_COUNT 65535  
  
class CEpollServer  
{  
        public:  
                CEpollServer();  
                ~CEpollServer();  
  
                bool InitServer(const char* chIp, int iPort);  
                void Listen();  
                static void ListenThread( void* lpVoid );  
                void Run();  
  
        private:  
                int        m_iEpollFd;  
                int        m_isock;  
                pthread_t       m_ListenThreadId;// 监听线程句柄  
  
};  
  
#endif  

   #include &quot;cepollserver.h&quot;  
  
using namespace std;  
  
CEpollServer::CEpollServer()  
{  
}  
  
CEpollServer::~CEpollServer()  
{  
    close(m_isock);  
}  
  
bool CEpollServer::InitServer(const char* pIp, int iPort)  
{  
    m_iEpollFd = epoll_create(_MAX_SOCKFD_COUNT);  
  
    //设置非阻塞模式  
    int opts = O_NONBLOCK;  
    if(fcntl(m_iEpollFd,F_SETFL,opts)&amp;lt;0)  
    {  
        printf(&quot;设置非阻塞模式失败!\n&quot;);  
        return false;  
    }  
  
    m_isock = socket(AF_INET,SOCK_STREAM,0);  
    if ( 0 &amp;gt; m_isock )  
    {  
        printf(&quot;socket error!\n&quot;);  
        return false;  
　　}  
　　  
　　sockaddr_in listen_addr;  
　　    listen_addr.sin_family=AF_INET;  
　　    listen_addr.sin_port=htons ( iPort );  
　　    listen_addr.sin_addr.s_addr=htonl(INADDR_ANY);  
　　    listen_addr.sin_addr.s_addr=inet_addr(pIp);  
　　  
　　    int ireuseadd_on = 1;//支持端口复用  
　　    setsockopt(m_isock, SOL_SOCKET, SO_REUSEADDR, &amp;amp;ireuseadd_on, sizeof(ireuseadd_on) );  
　　  
　　    if ( bind ( m_isock, ( sockaddr * ) &amp;amp;listen_addr,sizeof ( listen_addr ) ) !=0 )  
　　    {  
　　        printf(&quot;bind error\n&quot;);  
　　        return false;  
　　    }  
　　  
　　    if ( listen ( m_isock, 20) &amp;lt;0 )  
　　    {  
　　        printf(&quot;listen error!\n&quot;);  
　　        return false;  
　　    }  
　　    else  
　　    {  
　　        printf(&quot;服务端监听中...\n&quot;);  
　　    }  
　　  
　　    // 监听线程，此线程负责接收客户端连接，加入到epoll中  
　　    if ( pthread_create( &amp;amp;m_ListenThreadId, 0, ( void * ( * ) ( void * ) ) ListenThread, this ) != 0 )  
　　    {  
　　        printf(&quot;Server 监听线程创建失败!!!&quot;);  
　　        return false;  
　　    }  
　　}  
　　// 监听线程  
　　void CEpollServer::ListenThread( void* lpVoid )  
　　{  
　　    CEpollServer *pTerminalServer = (CEpollServer*)lpVoid;  
　　    sockaddr_in remote_addr;  
　　    int len = sizeof (remote_addr);  
　　    while ( true )  
　　    {  
　　        int client_socket = accept (pTerminalServer-&amp;gt;m_isock, ( sockaddr * ) &amp;amp;remote_addr,(socklen_t*)&amp;amp;len );  
　　        if ( client_socket &amp;lt; 0 )  
　　        {  
　　            printf(&quot;Server Accept失败!, client_socket: %d\n&quot;, client_socket);  
　　            continue;  
　　        }  
　　        else  
　　        {  
　　            struct epoll_event    ev;  
　　            ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;  
　　            ev.data.fd = client_socket;     //记录socket句柄  
　　            epoll_ctl(pTerminalServer-&amp;gt;m_iEpollFd, EPOLL_CTL_ADD, client_socket, &amp;amp;ev);  
　　        }  
　　    }  
　　}  
　　  
　　void CEpollServer::Run()  
　　{  
　　    while ( true )  
　　    {  
　　        struct epoll_event    events[_MAX_SOCKFD_COUNT];  
　　        int nfds = epoll_wait( m_iEpollFd, events,  _MAX_SOCKFD_COUNT, -1 );  
　　        for (int i = 0; i &amp;lt; nfds; i++)  
　　        {  
　　            int client_socket = events[i].data.fd;  
　　            char buffer[1024];//每次收发的字节数小于1024字节  
　　            memset(buffer, 0, 1024);  
　　            if (events[i].events &amp;amp; EPOLLIN)//监听到读事件，接收数据  
　　            {  
　　                int rev_size = recv(events[i].data.fd,buffer, 1024,0);  
　　                if( rev_size &amp;lt;= 0 )  
　　                {  
　　                    cout &amp;lt;&amp;lt; &quot;recv error: recv size: &quot; &amp;lt;&amp;lt; rev_size &amp;lt;&amp;lt; endl;  
　　                    struct epoll_event event_del;  
　　                    event_del.data.fd = events[i].data.fd;  
　　                    event_del.events = 0;  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;amp;event_del);  
　　                }  
　　                else  
　　                {  
　　                    printf(&quot;Terminal Received Msg Content:%s\n&quot;,buffer);  
　　                    struct epoll_event    ev;  
　　                    ev.events = EPOLLOUT | EPOLLERR | EPOLLHUP;  
　　                    ev.data.fd = client_socket;     //记录socket句柄  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, client_socket, &amp;amp;ev);  
　　                }  
　　            }  
　　else if(events[i].events &amp;amp; EPOLLOUT)//监听到写事件，发送数据  
　　            {  
　　                char sendbuff[1024];  
　　                sprintf(sendbuff, &quot;Hello, client fd: %d\n&quot;, client_socket);  
　　                int sendsize = send(client_socket, sendbuff, strlen(sendbuff)+1, MSG_NOSIGNAL);  
　　                if(sendsize &amp;lt;= 0)  
　　                {  
　　                    struct epoll_event event_del;  
　　                    event_del.data.fd = events[i].data.fd;  
　　                    event_del.events = 0;  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;amp;event_del);  
　　                }  
　　                else  
　　                {  
　　                    printf(&quot;Server reply msg ok! buffer: %s\n&quot;, sendbuff);  
　　                    struct epoll_event    ev;  
　　                    ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;  
　　                    ev.data.fd = client_socket;     //记录socket句柄  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, client_socket, &amp;amp;ev);  
　　                }  
　　            }  
　　            else  
　　            {  
　　                cout &amp;lt;&amp;lt; &quot;EPOLL ERROR\n&quot; &amp;lt;&amp;lt;endl;  
　　                epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, events[i].data.fd, &amp;amp;events[i]);  
　　            }  
　　        }  
　　    }  
　　}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;客户端代码：&lt;/strong&gt;
说明：测试是两个并发进行测试，每一个客户端都是一个长连接。代码中在连接服务器（ConnectToServer）时将用户ID和socketid关联起来。用户ID和socketid是一一对应的关系。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #ifndef _DEFINE_EPOLLCLIENT_H_  
    #define _DEFINE_EPOLLCLIENT_H_  
    #define _MAX_SOCKFD_COUNT 65535  
      
    #include&amp;lt;iostream&amp;gt;  
    #include &amp;lt;sys/epoll.h&amp;gt;  
    #include &amp;lt;sys/socket.h&amp;gt;  
    #include &amp;lt;netinet/in.h&amp;gt;  
    #include &amp;lt;fcntl.h&amp;gt;  
    #include &amp;lt;arpa/inet.h&amp;gt;  
    #include &amp;lt;errno.h&amp;gt;  
    #include &amp;lt;sys/ioctl.h&amp;gt;  
    #include &amp;lt;sys/time.h&amp;gt;  
    #include &amp;lt;string&amp;gt;  
      
    using namespace std;  
      
    /** 
     * @brief 用户状态 
     */  
    typedef enum _EPOLL_USER_STATUS_EM  
    {  
            FREE = 0,  
            CONNECT_OK = 1,//连接成功  
            SEND_OK = 2,//发送成功  
            RECV_OK = 3,//接收成功  
    }EPOLL_USER_STATUS_EM;  
      
    /*@brief 
     *@CEpollClient class 用户状态结构体 
     */  
    struct UserStatus  
    {  
            EPOLL_USER_STATUS_EM iUserStatus;//用户状态  
            int iSockFd;//用户状态关联的socketfd  
            char cSendbuff[1024];//发送的数据内容  
            int iBuffLen;//发送数据内容的长度  
            unsigned int uEpollEvents;//Epoll events  
    };  
      
    class CEpollClient  
    {  
            public:  
      
                    /** 
                     * @brief 
                     * 函数名:CEpollClient 
                     * 描述:构造函数 
                     * @param [in] iUserCount  
                     * @param [in] pIP IP地址 
                     * @param [in] iPort 端口号 
                     * @return 无返回 
                     */  
                    CEpollClient(int iUserCount, const char* pIP, int iPort);  
      
    /** 
                     * @brief 
                     * 函数名:CEpollClient 
                     * 描述:析构函数 
                     * @return 无返回 
                     */  
                    ~CEpollClient();  
      
                    /** 
                     * @brief 
                     * 函数名:RunFun 
                     * 描述:对外提供的接口，运行epoll类 
                     * @return 无返回值 
                     */  
                    int RunFun();  
      
            private:  
      
                    /** 
                     * @brief 
                     * 函数名:ConnectToServer 
                     * 描述:连接到服务器 
                     * @param [in] iUserId 用户ID 
                     * @param [in] pServerIp 连接的服务器IP 
                     * @param [in] uServerPort 连接的服务器端口号 
                     * @return 成功返回socketfd,失败返回的socketfd为-1 
                     */  
                    int ConnectToServer(int iUserId,const char *pServerIp,unsigned short uServerPort);  
      
    /** 
                     * @brief 
                     * 函数名:SendToServerData 
                     * 描述:给服务器发送用户(iUserId)的数据 
                     * @param [in] iUserId 用户ID 
                     * @return 成功返回发送数据长度 
                     */  
                    int SendToServerData(int iUserId);  
      
                    /** 
                     * @brief 
                     * 函数名:RecvFromServer 
                     * 描述:接收用户回复消息 
                     * @param [in] iUserId 用户ID 
                     * @param [in] pRecvBuff 接收的数据内容 
                     * @param [in] iBuffLen 接收的数据长度 
                     * @return 成功返回接收的数据长度，失败返回长度为-1 
                     */  
                    int RecvFromServer(int iUserid,char *pRecvBuff,int iBuffLen);  
      
                    /** 
                     * @brief 
                     * 函数名:CloseUser 
                     * 描述:关闭用户 
                     * @param [in] iUserId 用户ID 
                     * @return 成功返回true 
                     */  
                    bool CloseUser(int iUserId);  
      
    /** 
                     * @brief 
                     * 函数名:DelEpoll 
                     * 描述:删除epoll事件 
                     * @param [in] iSockFd socket FD 
                     * @return 成功返回true 
                     */  
                    bool DelEpoll(int iSockFd);  
            private:  
      
                    int    m_iUserCount;//用户数量；  
                    struct UserStatus *m_pAllUserStatus;//用户状态数组  
                    int    m_iEpollFd;//需要创建epollfd  
                    int    m_iSockFd_UserId[_MAX_SOCKFD_COUNT];//将用户ID和socketid关联起来  
                    int    m_iPort;//端口号  
                    char   m_ip[100];//IP地址  
    };  
      
    #endif  
    #include &quot;cepollclient.h&quot;  
  
CEpollClient::CEpollClient(int iUserCount, const char* pIP, int iPort)  
{  
    strcpy(m_ip, pIP);  
    m_iPort = iPort;  
    m_iUserCount = iUserCount;  
    m_iEpollFd = epoll_create(_MAX_SOCKFD_COUNT);  
    m_pAllUserStatus = (struct UserStatus*)malloc(iUserCount*sizeof(struct UserStatus));  
    for(int iuserid=0; iuserid&amp;lt;iUserCount ; iuserid++)  
    {  
        m_pAllUserStatus[iuserid].iUserStatus = FREE;  
        sprintf(m_pAllUserStatus[iuserid].cSendbuff, &quot;Client: %d send message \&quot;Hello Server!\&quot;\r\n&quot;, iuserid);  
        m_pAllUserStatus[iuserid].iBuffLen = strlen(m_pAllUserStatus[iuserid].cSendbuff) + 1;  
        m_pAllUserStatus[iuserid].iSockFd = -1;  
    }  
    memset(m_iSockFd_UserId, 0xFF, sizeof(m_iSockFd_UserId));  
}  
  
CEpollClient::~CEpollClient()  
{  
    free(m_pAllUserStatus);  
}  
int CEpollClient::ConnectToServer(int iUserId,const char *pServerIp,unsigned short uServerPort)  
{  
    if( (m_pAllUserStatus[iUserId].iSockFd = socket(AF_INET,SOCK_STREAM,0) ) &amp;lt; 0 )  
    {  
        cout &amp;lt;&amp;lt;&quot;[CEpollClient error]: init socket fail, reason is:&quot;&amp;lt;&amp;lt;strerror(errno)&amp;lt;&amp;lt;&quot;,errno is:&quot;&amp;lt;&amp;lt;errno&amp;lt;&amp;lt;endl;  
        m_pAllUserStatus[iUserId].iSockFd = -1;  
        return  m_pAllUserStatus[iUserId].iSockFd;  
    }  
  
    struct sockaddr_in addr;  
    bzero(&amp;amp;addr, sizeof(addr));  
    addr.sin_family = AF_INET;  
    addr.sin_port = htons(uServerPort);  
    addr.sin_addr.s_addr = inet_addr(pServerIp);  
  
    int ireuseadd_on = 1;//支持端口复用  
    setsockopt(m_pAllUserStatus[iUserId].iSockFd, SOL_SOCKET, SO_REUSEADDR, &amp;amp;ireuseadd_on, sizeof(ireuseadd_on));  
  
    unsigned long ul = 1;  
    ioctl(m_pAllUserStatus[iUserId].iSockFd, FIONBIO, &amp;amp;ul); //设置为非阻塞模式  
  
    connect(m_pAllUserStatus[iUserId].iSockFd, (const sockaddr*)&amp;amp;addr, sizeof(addr));  
    m_pAllUserStatus[iUserId].iUserStatus = CONNECT_OK;  
    m_pAllUserStatus[iUserId].iSockFd = m_pAllUserStatus[iUserId].iSockFd;  
  
    return m_pAllUserStatus[iUserId].iSockFd;  
}  
int CEpollClient::SendToServerData(int iUserId)  
{  
    sleep(1);//此处控制发送频率，避免狂打日志，正常使用中需要去掉  
    int isendsize = -1;  
    if( CONNECT_OK == m_pAllUserStatus[iUserId].iUserStatus || RECV_OK == m_pAllUserStatus[iUserId].iUserStatus)  
    {  
        isendsize = send(m_pAllUserStatus[iUserId].iSockFd, m_pAllUserStatus[iUserId].cSendbuff, m_pAllUserStatus[iUserId  
].iBuffLen, MSG_NOSIGNAL);  
        if(isendsize &amp;lt; 0)  
        {  
            cout &amp;lt;&amp;lt;&quot;[CEpollClient error]: SendToServerData, send fail, reason is:&quot;&amp;lt;&amp;lt;strerror(errno)&amp;lt;&amp;lt;&quot;,errno is:&quot;&amp;lt;&amp;lt;errno&amp;lt;  
&amp;lt;endl;  
        }  
        else  
        {  
            printf(&quot;[CEpollClient info]: iUserId: %d Send Msg Content:%s\n&quot;, iUserId, m_pAllUserStatus[iUserId].cSendbuff  
);  
            m_pAllUserStatus[iUserId].iUserStatus = SEND_OK;  
        }  
    }  
    return isendsize;  
}  
int CEpollClient::RecvFromServer(int iUserId,char *pRecvBuff,int iBuffLen)  
{  
    int irecvsize = -1;  
    if(SEND_OK == m_pAllUserStatus[iUserId].iUserStatus)  
    {  
        irecvsize = recv(m_pAllUserStatus[iUserId].iSockFd, pRecvBuff, iBuffLen, 0);  
        if(0 &amp;gt; irecvsize)  
        {  
            cout &amp;lt;&amp;lt;&quot;[CEpollClient error]: iUserId: &quot; &amp;lt;&amp;lt; iUserId &amp;lt;&amp;lt; &quot;RecvFromServer, recv fail, reason is:&quot;&amp;lt;&amp;lt;strerror(errn  
o)&amp;lt;&amp;lt;&quot;,errno is:&quot;&amp;lt;&amp;lt;errno&amp;lt;&amp;lt;endl;  
        }  
        else if(0 == irecvsize)  
        {  
            cout &amp;lt;&amp;lt;&quot;[warning:] iUserId: &quot;&amp;lt;&amp;lt; iUserId &amp;lt;&amp;lt; &quot;RecvFromServer, STB收到数据为0，表示对方断开连接,irecvsize:&quot;&amp;lt;&amp;lt;ire  
cvsize&amp;lt;&amp;lt;&quot;,iSockFd:&quot;&amp;lt;&amp;lt; m_pAllUserStatus[iUserId].iSockFd &amp;lt;&amp;lt; endl;  
        }  
        else  
        {  
            printf(&quot;Recv Server Msg Content:%s\n&quot;, pRecvBuff);  
            m_pAllUserStatus[iUserId].iUserStatus = RECV_OK;  
        }  
    }  
    return irecvsize;  
}  
  
bool CEpollClient::CloseUser(int iUserId)  
{  
    close(m_pAllUserStatus[iUserId].iSockFd);  
    m_pAllUserStatus[iUserId].iUserStatus = FREE;  
    m_pAllUserStatus[iUserId].iSockFd = -1;  
    return true;  
}  
      
int CEpollClient::RunFun()  
{  
    int isocketfd = -1;  
    for(int iuserid=0; iuserid&amp;lt;m_iUserCount; iuserid++)  
    {  
        struct epoll_event event;  
        isocketfd = ConnectToServer(iuserid, m_ip, m_iPort);  
        if(isocketfd &amp;lt; 0)  
            cout &amp;lt;&amp;lt;&quot;[CEpollClient error]: RunFun, connect fail&quot; &amp;lt;&amp;lt;endl;  
        m_iSockFd_UserId[isocketfd] = iuserid;//将用户ID和socketid关联起来  
  
        event.data.fd = isocketfd;  
        event.events = EPOLLIN|EPOLLOUT|EPOLLERR|EPOLLHUP;  
  
        m_pAllUserStatus[iuserid].uEpollEvents = event.events;  
        epoll_ctl(m_iEpollFd, EPOLL_CTL_ADD, event.data.fd, &amp;amp;event);  
　　}  
　　while(1)  
　　    {  
　　        struct epoll_event events[_MAX_SOCKFD_COUNT];  
　　        char buffer[1024];  
　　        memset(buffer,0,1024);  
　　        int nfds = epoll_wait(m_iEpollFd, events, _MAX_SOCKFD_COUNT, 100 );//等待epoll事件的产生  
　　        for (int ifd=0; ifd&amp;lt;nfds; ifd++)//处理所发生的所有事件  
　　        {  
　　            struct epoll_event event_nfds;  
　　            int iclientsockfd = events[ifd].data.fd;  
　　            cout &amp;lt;&amp;lt; &quot;events[ifd].data.fd: &quot; &amp;lt;&amp;lt; events[ifd].data.fd &amp;lt;&amp;lt; endl;  
　　            int iuserid = m_iSockFd_UserId[iclientsockfd];//根据socketfd得到用户ID  
　　            if( events[ifd].events &amp;amp; EPOLLOUT )  
　　            {  
　　                int iret = SendToServerData(iuserid);  
　　                if( 0 &amp;lt; iret )  
　　                {  
　　                    event_nfds.events = EPOLLIN|EPOLLERR|EPOLLHUP;  
　　                    event_nfds.data.fd = iclientsockfd;  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, event_nfds.data.fd, &amp;amp;event_nfds);  
　　                }  
　　                else  
　　                {  
　　                    cout &amp;lt;&amp;lt;&quot;[CEpollClient error:] EpollWait, SendToServerData fail, send iret:&quot;&amp;lt;&amp;lt;iret&amp;lt;&amp;lt;&quot;,iuserid:&quot;&amp;lt;&amp;lt;iuser  
　　id&amp;lt;&amp;lt;&quot;,fd:&quot;&amp;lt;&amp;lt;events[ifd].data.fd&amp;lt;&amp;lt;endl;  
　　                    DelEpoll(events[ifd].data.fd);  
　　                    CloseUser(iuserid);  
　　                }  
　　            }  
　　else if( events[ifd].events &amp;amp; EPOLLIN )//监听到读事件，接收数据  
　　            {  
　　                int ilen = RecvFromServer(iuserid, buffer, 1024);  
　　                if(0 &amp;gt; ilen)  
　　                {  
　　                    cout &amp;lt;&amp;lt;&quot;[CEpollClient error]: RunFun, recv fail, reason is:&quot;&amp;lt;&amp;lt;strerror(errno)&amp;lt;&amp;lt;&quot;,errno is:&quot;&amp;lt;&amp;lt;errno&amp;lt;&amp;lt;e  
　　ndl;  
　　                    DelEpoll(events[ifd].data.fd);  
　　                    CloseUser(iuserid);  
　　                }  
　　                else if(0 == ilen)  
　　                {  
　　                    cout &amp;lt;&amp;lt;&quot;[CEpollClient warning:] server disconnect,ilen:&quot;&amp;lt;&amp;lt;ilen&amp;lt;&amp;lt;&quot;,iuserid:&quot;&amp;lt;&amp;lt;iuserid&amp;lt;&amp;lt;&quot;,fd:&quot;&amp;lt;&amp;lt;events[  
　　ifd].data.fd&amp;lt;&amp;lt;endl;  
　　                    DelEpoll(events[ifd].data.fd);  
　　                    CloseUser(iuserid);  
　　                }  
　　                else  
　　                {  
　　                    m_iSockFd_UserId[iclientsockfd] = iuserid;//将socketfd和用户ID关联起来  
　　                    event_nfds.data.fd = iclientsockfd;  
　　                    event_nfds.events = EPOLLOUT|EPOLLERR|EPOLLHUP;  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, event_nfds.data.fd, &amp;amp;event_nfds);  
　　                }  
　　            }  
　　            else  
　　            {  
　　                cout &amp;lt;&amp;lt;&quot;[CEpollClient error:] other epoll error&quot;&amp;lt;&amp;lt;endl;  
　　                DelEpoll(events[ifd].data.fd);  
　　                CloseUser(iuserid);  
　　            }  
　　        }  
　　}  
　　}  
　　  
　　bool CEpollClient::DelEpoll(int iSockFd)  
　　{  
　　    bool bret = false;  
　　    struct epoll_event event_del;  
　　    if(0 &amp;lt; iSockFd)  
　　    {  
　　        event_del.data.fd = iSockFd;  
　　        event_del.events = 0;  
　　        if( 0 == epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;amp;event_del) )  
　　        {  
　　            bret = true;  
　　        }  
　　        else  
　　        {  
　　            cout &amp;lt;&amp;lt;&quot;[SimulateStb error:] DelEpoll,epoll_ctl error,iSockFd:&quot;&amp;lt;&amp;lt;iSockFd&amp;lt;&amp;lt;endl;  
　　        }  
　　        m_iSockFd_UserId[iSockFd] = -1;  
　　    }  
　　    else  
　　    {  
　　        bret = true;  
　　  
　　    }  
　　    return bret;  
　　}  
　　 服务器主程序：

#include &amp;lt;iostream&amp;gt;  
#include &quot;cepollserver.h&quot;  
  
using namespace std;  
  
int main()  
{  
        CEpollServer  theApp;  
        theApp.InitServer(&quot;127.0.0.1&quot;, 8000);  
        theApp.Run();  
  
        return 0;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;客户端主程序：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    　#include &quot;cepollclient.h&quot;  
  
int main(int argc, char *argv[])  
{  
        CEpollClient *pCEpollClient = new CEpollClient(2, &quot;127.0.0.1&quot;, 8000);  
        if(NULL == pCEpollClient)  
        {  
                cout&amp;lt;&amp;lt;&quot;[epollclient error]:main init&quot;&amp;lt;&amp;lt;&quot;Init CEpollClient fail&quot;&amp;lt;&amp;lt;endl;  
        }  
  
        pCEpollClient-&amp;gt;RunFun();  
  
        if(NULL != pCEpollClient)  
        {  
                delete pCEpollClient;  
                pCEpollClient = NULL;  
        }  
  
        return 0;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>java编程的78条黄金法则</title>
   <link href="http://http://coolshell.info/blog/2014/08/78-golden-rules-of-the-java-programming.html"/>
   <updated>2014-08-16T00:00:00+00:00</updated>
   <id>/blog/2014/08/78-golden-rules-of-the-java-programming</id>
   <content type="html">&lt;p&gt;整理自网络，如果你知道原作者，请通知我。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;创建和销毁对象&lt;/h2&gt;

&lt;p&gt;1、考虑用静态工厂方法（返回类的实例的静态方法）代替构造器&lt;br /&gt;
2、遇到多个构造器参数时要考虑用构造器&lt;br /&gt;
3、用私有构造器或者枚举类型强化Singleton属性&lt;br /&gt;
4、通过私有构造器强化不可实例化的能力&lt;br /&gt;
5、避免创建不必要的对象&lt;br /&gt;
6、消除过期的对象引用&lt;br /&gt;
7、避免使用终结（final）方法&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;对于所有对象都通用的方法&lt;/h2&gt;

&lt;p&gt;8、覆盖equals时请遵守通用约定&lt;br /&gt;
9、覆盖equals时总要覆盖hashCode&lt;br /&gt;
10、始终要覆盖toString&lt;br /&gt;
11、谨慎地覆盖clone&lt;br /&gt;
12、考虑实现Comparable接口&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;类和接口&lt;/h2&gt;

&lt;p&gt;13、使类和成员的可访问性最小化&lt;br /&gt;
14、在公有类中使用访问方法而非公有域&lt;br /&gt;
15、使可变性最小化&lt;br /&gt;
16、复合优于继承&lt;br /&gt;
17、要么为继承为设计，并提供文档说明，要么就禁止继承&lt;br /&gt;
18、接口优于抽象类&lt;br /&gt;
19、接口只用于定义类型&lt;br /&gt;
20、类层次优于标签类&lt;br /&gt;
21、用函数对象表示策略&lt;br /&gt;
22、优先考虑静态成员类&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;泛型&lt;/h2&gt;

&lt;p&gt;23、不要在新代码中采用原生态类型&lt;br /&gt;
24、消除非受检警告&lt;br /&gt;
25、列表优先于数组&lt;br /&gt;
26、优先考虑泛型&lt;br /&gt;
27、优先考虑泛型方法&lt;br /&gt;
28、采用有限制通配符来提升API的灵活性&lt;br /&gt;
29、优先考虑类型安全的异构造器&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;枚举和注解&lt;/h2&gt;

&lt;p&gt;30、用enum带起int常量&lt;br /&gt;
31、用实例域代替序数&lt;br /&gt;
32、用EnumSet代替位域&lt;br /&gt;
33、用EnumMap代替序数索引&lt;br /&gt;
34、用接口模拟可伸缩的枚举&lt;br /&gt;
35、注解优先于命名模式&lt;br /&gt;
36、坚持使用Override注解&lt;br /&gt;
37、用标记接口定义类型&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;方法&lt;/h2&gt;

&lt;p&gt;38、检查参数的有效性&lt;br /&gt;
39、必要时进行保护性拷贝&lt;br /&gt;
40、谨慎设计方法签名&lt;br /&gt;
41、慎用重载&lt;br /&gt;
42、慎用可变参数&lt;br /&gt;
43、返回零长度的数组或者集合，而不是null&lt;br /&gt;
44、为所有导出的API元素编写文档注释&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;通用程序设计&lt;/h2&gt;

&lt;p&gt;45、将局部变量的作用域最小化&lt;br /&gt;
46、for-each循环优先于传统的for循环&lt;br /&gt;
47、了解和使用类库&lt;br /&gt;
48、如果需要精确的答案，请避免使用float和double&lt;br /&gt;
49、基本类型优先于装箱基本类型&lt;br /&gt;
50、如果其他类型更适合，则尽量避免使用字符串&lt;br /&gt;
51、当心字符串链接的性能&lt;br /&gt;
52、通过接口引用对象&lt;br /&gt;
53、接口优先于反射机制&lt;br /&gt;
54、谨慎使用本地方法&lt;br /&gt;
55、谨慎进行优化&lt;br /&gt;
56、遵守普遍接受的命名惯例&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;异常&lt;/h2&gt;

&lt;p&gt;57、只针对异常的情况才使用异常&lt;br /&gt;
58、对可恢复的情况使用受检异常，对编程错误使用运行时异常&lt;br /&gt;
59、避免不必要地使用受检的异常&lt;br /&gt;
60、优先使用标准的异常&lt;br /&gt;
61、抛出与抽象相对应的异常&lt;br /&gt;
62、每个方法抛出的异常都要有文档&lt;br /&gt;
63、在细节消息中包含捕获失败的信息&lt;br /&gt;
64、努力使失败包含原子性&lt;br /&gt;
65、不要忽略异常&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;并发&lt;/h2&gt;

&lt;p&gt;66、同步访问共享的可变数据&lt;br /&gt;
67、避免过度同步&lt;br /&gt;
68、executor和task优先于线程&lt;br /&gt;
69、并发工具优先于wait和notify&lt;br /&gt;
70、线程安全性的文档化&lt;br /&gt;
71、慎用延迟初始化&lt;br /&gt;
72、不要依赖于线程调度器&lt;br /&gt;
73、避免使用线程组&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;序列化&lt;/h2&gt;

&lt;p&gt;74、谨慎的实现Seriallizable接口&lt;br /&gt;
75、考虑使用自定义的序列化形式&lt;br /&gt;
76、保护性的编写readObject方法&lt;br /&gt;
77、对于实例控制，枚举类型优先于readResolve&lt;br /&gt;
78、考虑用序列化代理代替序列化实例&lt;br /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>使用jekyll在Github上搭建博客</title>
   <link href="http://http://coolshell.info/blog/2014/07/use-jekyll-build-blog-on-github.html"/>
   <updated>2014-07-15T00:00:00+00:00</updated>
   <id>/blog/2014/07/use-jekyll-build-blog-on-github</id>
   <content type="html">&lt;p&gt;jekyll是一个使用Ruby编写的静态站点生成工具，使用Liquid模板渲染引擎，支持Markdown和Textile标记语言，并且可以为所有以 .html、.markdown、.textile扩展名结尾的文件使用YAML配置，内置语法高亮功能。&lt;/p&gt;

&lt;p&gt;而Github的Pages服务可以为每个Github主机上的仓库提供静态页面服务，并且Pages服务支持jekyll。因为Github Pages有两种Pages，分别是用户页面和项目页面，所以我们可以使用用户页面来创建自己的Blog。&lt;/p&gt;

&lt;p&gt;在开始前，请确保你已经有了Github账号一枚和Git的正确配置。没有的朋友可以先移步Github注册并安装配置Git。&lt;/p&gt;

&lt;p&gt;首先，创建你的 Blog 仓库 &lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.com&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir username.github.com
$ cd username.github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;新建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 文件，像下面这样:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Hello&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Hello!&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;初始化仓库、提交并push到Github:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git init
$ git add .
$ git commit -a -m &#39;init commit.&#39;
$ git remote add origin
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在你打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.com&lt;/code&gt; 就可以看到刚才新建的页面了，就是这么简单。当然也可以为你的Blog仓库绑定独立域名，具体做法就是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在你的仓库中新建内容为 www.youdomain.com 的 CNAME 文件；&lt;/li&gt;
  &lt;li&gt;在你的域名管理页或者是DNS解析的地方，增加一个记录，记录类别为CNAME(Alias)类型.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt; 如果你在CNAME中填写的是顶级域名，就得设置DNS的记录类别为A(Host)型，并设置主机为 &lt;code class=&quot;highlighter-rouge&quot;&gt;207.97.227.245&lt;/code&gt;。详细介绍请移步Github的Pages页面。&lt;/p&gt;

&lt;p&gt;接下来我们只需要按照自己的喜好设计页面。首先认识下jekyll的文件及目录配置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  .
  |-- _includes
  |-- _plugins 
  |-- _layout 
  |   |-- default.html
  |   `-- post.html
  |-- _post
  |   |-- yyyy-mm-dd-title.markdown
  |   `-- yyyy-mm-dd-title.markdown
  |-- _site
  |-- _config.yml
  `-- index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;存放你需要在模板文件中包含的文件，你可以使用Liquid标签 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;‰&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;file.ext&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;‰&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;/code&gt;来引用相应的文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_plugins&lt;/strong&gt;可以增加你自己的插件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_layout&lt;/strong&gt;存放布局模板，请参考&lt;a href=&quot;https://github.com/taberhuang/taberhuang.github.com/tree/master/_layouts&quot;&gt;https://github.com/taberhuang/taberhuang.github.com/tree/master/_layouts&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;_post&lt;/strong&gt;存放文章列表，文件命名一定要遵循 yyyy-mm-dd-title.html&lt;/td&gt;
      &lt;td&gt;markdown&lt;/td&gt;
      &lt;td&gt;textile 规则，请参考&lt;a href=&quot;https://github.com/taberhuang/taberhuang.github.com/tree/master/_posts&quot;&gt;https://github.com/taberhuang/taberhuang.github.com/tree/master/_posts&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;_sitejekyll&lt;/strong&gt;自动生成的，所以可以忽略，如果你有在本地安装jekyll并预览了的话，可以使用.gitignore设置Git停止对本目录的跟踪。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;设置经常使用的配置选项，这样在本地启动预览时就不用每次都手动输入了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.html 和所有的 HTML/Markdown/Textile 文件&lt;/strong&gt; 所有的HTML/Markdown/Textile文件都可以包含 YAML 配置，这类文件都会被jekyll解析。&lt;/p&gt;

&lt;p&gt;现在你可以在自己的仓库中配置好你自己的目录及文件，也可以&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;我的仓库，然后修改。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/taberhuang/taberhuang.github.com.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改完后就可以&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;你的代码到Github上，看到结果了。刚才有说到本地预览，如果你想在本地预览后，确保没错误再&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;的话，就需要在本地安装jekyll，下面介绍下jekyll的安装方法。&lt;/p&gt;

&lt;p&gt;一、安装Ruby运行环境和RubyGem:Windows用户只要下载 RubyInstaller。下载安装后请手动升级gem.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem update --system
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;二、安装DevKit。DevKit是windows平台编译和使用本地C/C++扩展包工具。用来模拟Linux平台下的 make,gcc,sh 进行编译。下载文件后，解压到 `C:\DevKit’，再通过命令行安装:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd C:\DevKit
$ ruby dk.rb init
$ ruby dk.rb install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;三、安装并检查刚才的DevKit安装是否成功。如果成功安装，则DevKit也就安装成功，如果不成功，请重新安装DevKit。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;四、安装Rdiscount，这个是用来解析Markdown标记的解析包。如果你使用Textile的话，就是安装Kramdown。&lt;/p&gt;

&lt;p&gt;$ gem install rdiscount&lt;/p&gt;

&lt;p&gt;所有的环境和依赖包都安装成功后，进入你的仓库目录，用下面的命令便可启动jekyll，并在本地预览了，预览地址默认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1:4000&lt;/code&gt;，当然你也可以通过 _config.yml 配置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll --server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是很爽?&lt;/p&gt;

&lt;p&gt;参考及相关资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://pages.github.com/&quot;&gt;http://pages.github.com/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki&quot;&gt;https://github.com/mojombo/jekyll/wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.envylabs.com/2009/08/publishing-a-blog-with-github-pages-and-jekyll/&quot;&gt;http://blog.envylabs.com/2009/08/publishing-a-blog-with-github-pages-and-jekyll/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;http://daringfireball.net/projects/markdown/syntax&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>一个合格的程序员应该读过哪些书</title>
   <link href="http://http://coolshell.info/blog/2014/07/qualified-programmer-should-read-what-books.html"/>
   <updated>2014-07-15T00:00:00+00:00</updated>
   <id>/blog/2014/07/qualified-programmer-should-read-what-books</id>
   <content type="html">&lt;p&gt;编者按：2008年8月4日，StackOverflow 网友 Bert F 发帖提问：哪本最具影响力的书，是每个程序员都应该读的？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“如果能时光倒流，回到过去，作为一个开发人员，你可以告诉自己在职业生涯初期应该读一本，
你会选择哪本书呢？我希望这个书单列表内容丰富，可以涵盖很多东西。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很多&lt;a href=&quot;http://coolshell.info&quot;&gt;程序员&lt;/a&gt;响应，他们在推荐时也写下自己的评语。
以前就有国内网友介绍这个程序员书单，不过都是推荐数 Top 10的书。&lt;/p&gt;

&lt;p&gt;其实除了前10本之外，推荐数前30左右的书籍都算经典，笔者整理编译这个问答贴，同时摘译部分推荐人的评语。&lt;/p&gt;

&lt;p&gt;下面就按照各本书的推荐数排列。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoes03n-&quot;&gt;1、《&lt;a href=&quot;http://t.cn/zOEs03N&quot;&gt;代码大全&lt;/a&gt;》 史蒂夫·迈克康奈尔&lt;/h2&gt;

&lt;p&gt;推荐数：1684&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“优秀的编程实践的百科全书，《&lt;a href=&quot;http://t.cn/zOEs03N&quot;&gt;代码大全&lt;/a&gt;》注重个人技术，其中所有东西加起来，
就是我们本能所说的“编写整洁的代码”。这本书有50页在谈论代码布局。” —— Joel Spolsky&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于新手来说，这本书中的观念有点高阶了。到你准备阅读此书时，你应该已经知道并实践过书中99%的观念。– esac&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Steve McConnell的原作《代码大全》(第1版)是公认的关于编程的最佳实践指南之一，
在过去的十多年间，本书一直在帮助开发人员编写更好的软件。&lt;/p&gt;

&lt;p&gt;现在，作者将这本经典著作全新演绎，融入了最前沿的实践技术，加入了上百个崭新的代码示例，
充分展示了软件构建的艺术性和科学性。
McConnell汇集了来自研究机构、学术界以及业界日常实践的主要知识，
把最高效的技术和最重要的原理交织融会为这本既清晰又实用的指南。&lt;/p&gt;

&lt;p&gt;无论您的经验水平如何，也不管您在怎样的开发环境中工作，也无论项目是大是小，
本书都将激发您的思维并帮助您构建高品质的代码。&lt;/p&gt;

&lt;p&gt;《&lt;a href=&quot;(http://t.cn/zOEs03N)&quot;&gt;代码大全（第2版）&lt;/a&gt;》做了全面的更新，增加了很多与时俱进的内容，包括对新语言、新的开发过程与方法论的讨论等等。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoesld9&quot;&gt;2、《&lt;a href=&quot;http://t.cn/zOEslD9&quot;&gt;程序员修炼之道&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：1504&lt;/p&gt;

&lt;p&gt;对于那些已经学习过编程机制的程序员来说，这是一本卓越的书。
或许他们还是在校生，但对要自己做什么，还感觉不是很安全。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;就像草图和架构之间的差别。虽然你在学校课堂上学到的是画图，你也可以画的很漂亮，
但如果你觉得你不太知道从哪儿下手，如果某人要你独自画一个P2P的音乐交换网络图，那这本书就适合你了。—— Joel&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;《程序员修炼之道:从小工到专家》内容简介：《程序员修炼之道》由一系列独立的部分组成，
涵盖的主题从个人责任、职业发展，知道用于使代码保持灵活、并且易于改编和复用的各种架构技术，
利用许多富有娱乐性的奇闻轶事、有思想性的例子及有趣的类比，
全面阐释了软件开发的许多不同方面的最佳实践和重大陷阱。&lt;/p&gt;

&lt;p&gt;无论你是初学者，是有经验的程序员，还是软件项目经理，《程序员修炼之道:从小工到专家》都适合你阅读。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoesycs&quot;&gt;3、《&lt;a href=&quot;http://t.cn/zOEsYcs&quot;&gt;计算机程序的构造和解释&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：916&lt;/p&gt;

&lt;p&gt;就个人而言，这本书目前为止对我影响醉倒的一本编程书。&lt;/p&gt;

&lt;p&gt;《代码大全》、《重构》和《设计模式》这些经典书会教给你高效的工作习惯和交易细节。
其他像《人件集》、《计算机编程心理学》和《人月神话》这些书会深入软件开发的心理层面。
其他书籍则处理算法。这些书都有自己所属的位置。&lt;/p&gt;

&lt;p&gt;然而《计算机程序的构造和解释》与这些不同。
这是一本会启发你的书，它会燃起你编写出色程序的热情；
它还将教会你认识并欣赏美；
它会让你有种敬畏，让你难以抑制地渴望学习更多的东西。&lt;/p&gt;

&lt;p&gt;其他书或许会让你成为一位更出色的程序员，但此书将一定会让你成为一名程序员。&lt;/p&gt;

&lt;p&gt;同时，你将会学到其他东西，函数式编程（第三章）、惰性计算、元编程、虚拟机、解释器和编译器。&lt;/p&gt;

&lt;p&gt;一些人认为此书不适合新手。
个人认为，虽然我并不完全认同要有一些编程经验才能读此书，但我还是一定推荐给初学者。
毕竟这本书是写给著名的6.001，是麻省理工学院的入门编程课程。
此书或许需要多做努力（尤其你在做练习的时候，你也应当如此），但这个价是对得起这本书的。&lt;/p&gt;

&lt;h2 id=&quot;chttptcnzoeshqb&quot;&gt;4、《&lt;a href=&quot;http://t.cn/zOEsHqb&quot;&gt;C程序设计语言&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：774&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这本书简洁易读，会教给你三件事：C 编程语言；如何像程序员一样思考；底层计算模型。
（这对理解“底层”非常重要）—— Nathan&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;《C程序设计语言》(第2版新版)讲述深入浅出，配合典型例证，通俗易懂，实用性强，
适合作为大专院校计算机专业或非计算机专业的C语言教材，也可以作为从事计算机相关软硬件开发的技术人员的参考书。&lt;/p&gt;

&lt;p&gt;《C程序设计语言》(第2版新版)原著即为C语言的设计者之一Dennis M.Ritchie和著名的计算机科学家Brian W.Kernighan合著的
一本介绍C语言的权威经典著作。
我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。
原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。&lt;/p&gt;

&lt;p&gt;人们熟知的“hello,world”程序就是由本书首次引入的，现在，这一程序已经成为所有程序设计语言入门的第一课。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoesqan&quot;&gt;5、《&lt;a href=&quot;http://t.cn/zOEsQAn&quot;&gt;算法导论&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：671&lt;/p&gt;

&lt;p&gt;《代码大全》教你如何正确编程；
《人月神话》教你如何正确管理；
《设计模式》教你如何正确设计……&lt;/p&gt;

&lt;p&gt;在我看来，代码只是一个工具，并非精髓。
开发软件的主要部分是创建新算法或重新实现现有算法。
其他部分则像重新组装乐高砖块或创建“管理”层。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我依然梦想这样的工作，我的大部分时间（&amp;gt;50%）是在写算法，其他“管理”细节则留给其他人…… —— Ran Biron&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;经典的算法书,被亚马逊网，《程序员》等评选为2006年最受读者喜爱的十大IT图书之一。&lt;/li&gt;
&lt;li&gt;算法领域的标准教材，全球多所知名大学选用&lt;/li&gt;
&lt;li&gt;MIT名师联手铸就，被誉为“计算机算法的圣经”&lt;/li&gt;
&lt;li&gt;编写上采用了“五个一”，即一章介绍一个算法、一种设计技术、一个应用领域和一个相关话题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;httptcnzoes8lu&quot;&gt;6、《&lt;a href=&quot;http://t.cn/zOEs8Lu&quot;&gt;重构：改善既有代码的设计&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：617&lt;/p&gt;

&lt;p&gt;《重构:改善既有代码的设计》清晰地揭示了重构的过程，解释了重构的原理和最佳实践方式，
并给出了何时以及何地应该开始挖掘代码以求改善。
书中给出了70多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。&lt;/p&gt;

&lt;p&gt;《重构:改善既有代码的设计》提出的重构准则将帮助你一次一小步地修改你的代码，从而减少了开发过程中的风险。&lt;/p&gt;

&lt;p&gt;《重构:改善既有代码的设计》适合软件开发人员、项目管理人员等阅读，
也可作为高等院校计算机及相关专业师生的参考读物。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我想我不得不推荐《重构》：改进现有代码的设计。—— Martin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我必须承认，我最喜欢的编程语录是出自这本书：任何一个傻瓜都能写出计算机能理解的程序，
而优秀的程序员却能写出别人能读得懂的程序。—— Martin Fowler&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoes8k1&quot;&gt;7、《&lt;a href=&quot;http://t.cn/zOEs8k1&quot;&gt;设计模式&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：617&lt;/p&gt;

&lt;p&gt;自1995年出版以来，本书一直名列Amazon和各大书店销售榜前列。
近10年后，本书仍是Addison-Wesley公司2003年最畅销的图书之一。
中文版销售逾4万册。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;就我而言，我认为四人帮编著的《设计模式》是一本极为有用的书。
虽然此书并不像其他建议一样有关“元”编程，但它强调封装诸如模式一类的优秀编程技术，
因而鼓励其他人提出新模式和反模式（antipatterns），并运用于编程对话中。—— Chris Jester-Young&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoesr1z&quot;&gt;8、《&lt;a href=&quot;http://t.cn/zOEsR1z&quot;&gt;人月神话&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：588&lt;/p&gt;

&lt;p&gt;在软件领域，很少能有像《人月神话》一样具有深远影响力并且畅销不衰的著作。&lt;/p&gt;

&lt;p&gt;Brooks博士为人们管理复杂项目提供了最具洞察力的见解。
既有很多发人深省的观点，又有大量软件工程的实践。
本书内容来自Brooks博士在IBM公司System/360家族和OS/360中的项目管理经验。&lt;/p&gt;

&lt;p&gt;该书英文原版一经面世，即引起业内人士的强烈反响，后又译为德、法、日、俄中等多种语言，全球销量数百万册。
确立了其在行业内的经典地位。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoesexr&quot;&gt;9、《&lt;a href=&quot;http://t.cn/zOEsExR&quot;&gt;计算机程序设计艺术&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：542&lt;/p&gt;

&lt;p&gt;《计算机程序设计艺术》系列著作对计算机领域产生了深远的影响。
这一系列堪称一项浩大的工程，自1962年开始编写，计划出版7卷，目前已经出版了4卷。&lt;/p&gt;

&lt;p&gt;《美国科学家》杂志曾将这套书与爱因斯坦的《相对论》等书并列称为20世纪最重要的12本物理学著作。
目前Knuth正将毕生精力投入到这部史诗性著作的撰写中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是高德纳倾注心血写的一本书。—— Peter Coulton&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoesefg&quot;&gt;10、《&lt;a href=&quot;http://t.cn/zOEsEFG&quot;&gt;编译原理&lt;/a&gt;》（龙书）&lt;/h2&gt;

&lt;p&gt;推荐数：462&lt;/p&gt;

&lt;p&gt;我很奇怪，居然没人提到龙书。（或许已有推荐，我没有看到）。
我从没忘过此书的第一版封面。
此书让我知道了编译器是多么地神奇绝妙。- DB&lt;/p&gt;

&lt;h2 id=&quot;httptcnzonvx9n&quot;&gt;11、《&lt;a href=&quot;http://t.cn/zOnvX9N&quot;&gt;深入浅出设计模式&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：445&lt;/p&gt;

&lt;p&gt;强大的写作阵容。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;《Head First设计模式》(中文版) 作者Eric Freeman；&lt;/li&gt;
  &lt;li&gt;ElElisabeth Freeman是作家、讲师和技术顾问。&lt;/li&gt;
  &lt;li&gt;Eric拥有耶鲁大学的计算机科学博士学位，E1isabath拥有耶鲁大学的计算机科学硕士学位。&lt;/li&gt;
  &lt;li&gt;Kathy Sierra(javaranch．com的创始人)FHBert Bates是畅销的HeadFirst系列书籍的创立者，也是Sun公司Java开发员认证考试的开发者。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本书的产品设计应用神经生物学、认知科学，以及学习理论，这使得这本书能够将这些知识深深地印在你的脑海里，
不容易被遗忘。&lt;/p&gt;

&lt;p&gt;本书的编写方式采用引导式教学，不直接告诉你该怎么做，而是利用故事当作引子，带领读者思考并想办法解决问题。
解决问题的过程中又会产生一些新的问题，再继续思考、继续解决问题，这样可以加深体会。&lt;/p&gt;

&lt;p&gt;作者以大量的生活化故事当背景，例如第1章是鸭子，第2章是气象站，第3章是咖啡店，
书中搭配大量的插图(几乎每一页都有图)，所以阅读起来生动有趣，不会感觉到昏昏欲睡。&lt;/p&gt;

&lt;p&gt;作者还利用歪歪斜斜的手写字体，增加“现场感”。
精心设计许多爆笑的对白，让学习过程不会太枯燥。
还有模式告白节目，将设计模式拟人化成节目来宾，畅谈其内在的一切。
每一章都有数目不等的测验题。
每章最后有一页要点整理，这也是精华所在，我都是利用这一页做复习。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我知道四人帮的《设计模式》是一本标准书，但倒不如先看看这部大部头，此书更为简易。
一旦你了解了解了基本原则，可以去看四人帮的那本圣经了。- Calanus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoesu0d&quot;&gt;12、《&lt;a href=&quot;http://t.cn/zOEsu0d&quot;&gt;哥德尔、艾舍尔、巴赫书：集异璧之大成&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：437&lt;/p&gt;

&lt;p&gt;如果下昂真正深入阅读，我推荐道格拉斯·侯世达（Douglas Hofstadter）的《哥德尔、艾舍尔、巴赫书》。
他极为深入研究了程序员每日都要面对的问题：递归、验证、证明和布尔代数。
这是一本很出色的读物，难度不大，偶尔有挑战，一旦你要鏖战到底，将是非常值得的。 – Jonik&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoes3tt&quot;&gt;13、《&lt;a href=&quot;http://t.cn/zOEs3tt&quot;&gt;代码整洁之道&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：329&lt;/p&gt;

&lt;p&gt;细节之中自有天地，整洁成就卓越代码&lt;/p&gt;

&lt;p&gt;尽管糟糕的代码也能运行，但如果代码不整洁，会使整个开发团队泥足深陷，
写得不好的代码每年都要耗费难以计数的时间和资源。
然而这种情况并非无法避免。&lt;/p&gt;

&lt;p&gt;著名软件专家RoberfC.Marlin在《代码整洁之道》中为你呈现出了革命性的视野。
Martin携同ObjectMetltor公司的同事，从他们有关整洁代码的最佳敏捷实践中提炼出软件技艺的价值观，
以飨读者，让你成为更优秀的程序员——只要你着手研读《代码整洁之道》。&lt;/p&gt;

&lt;p&gt;阅读《代码整洁之道》需要你做些什么呢？你将阅读代码——大量代码。
《代码整洁之道》促使你思考代码中何谓正确，何谓错误。
更重要的是，《代码整洁之道》将促使你重新评估自己的专业价值观，以及对自己技艺的承诺。&lt;/p&gt;

&lt;p&gt;从《代码整洁之道》中可以学到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;好代码和糟糕的代码之间的区别；&lt;/li&gt;
&lt;li&gt;如何编写好代码，如何将糟糕的代码转化为好代码；&lt;/li&gt;
&lt;li&gt;如何创建好名称、好函数、好对象和好类；&lt;/li&gt;
&lt;li&gt;如何格式化代码以实现其可读性的最大化；&lt;/li&gt;
&lt;li&gt;如何在不妨碍代码逻辑的前提下充分实现错误处理；&lt;/li&gt;
&lt;li&gt;如何进行单元测试和测试驱动开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;虽然《代码整洁之道》和《代码大全》有很多共同之处，但它有更为简洁更为实际的清晰例子。 – Craig P. Motlin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;effective-chttptcnzoes1mwmore-effective-chttptcnzoesbvc&quot;&gt;14、《&lt;a href=&quot;http://t.cn/zOEs1Mw&quot;&gt;Effective C++&lt;/a&gt;》和《&lt;a href=&quot;http://t.cn/zOEsBvc&quot;&gt;More Effective C++&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：297&lt;/p&gt;

&lt;p&gt;在我职业生涯早期，Scott Meyer的《Effective C++》和后续的《More Effective C++》都对我的编程能力有着直接影响。
正如当时的一位朋友所说，这些书缩短你培养编程技能的过程，而其他人可能要花费数年。&lt;/p&gt;

&lt;p&gt;去年对我影响最大的一本书是《大教堂与市集》，该书教会我很有关开源开发过程如何运作，和如何处理我代码中的Bug。 – John Channing&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoesbur&quot;&gt;15、《&lt;a href=&quot;http://t.cn/zOEsBur&quot;&gt;编程珠玑&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：282&lt;/p&gt;

&lt;p&gt;多年以来，当程序员们推选出最心爱的计算机图书时，《编程珠玑》总是位列前列。
正如自然界里珍珠出自细沙对牡蛎的磨砺，计算机科学大师Jon Bentley以其独有的洞察力和创造力，
从磨砺程序员的实际问题中凝结出一篇篇不朽的编程“珠玑”，
成为世界计算机界名刊《ACM通讯》历史上最受欢迎的专栏，
最终结集为两部不朽的计算机科学经典名著，影响和激励着一代又一代程序员和计算机科学工作者。&lt;/p&gt;

&lt;p&gt;本书为第一卷，主要讨论计算机科学中最本质的问题：如何正确选择和高效地实现算法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;尽管我不得不羞愧地承认，书中一半的东西我都没有理解，但我真的推荐《编程珠玑》，书中有些令人惊奇的东西。 – Matt Warren&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoesgc0by-michael-feathers&quot;&gt;16、《&lt;a href=&quot;http://t.cn/zOEsgC0&quot;&gt;修改代码的艺术&lt;/a&gt;》by Michael Feathers&lt;/h2&gt;

&lt;p&gt;本书是继《重构》和《重构与模式》之后探讨修改代码技术的又一里程碑式的著作，
而且从涵盖面和深度上都超过了前两部经典。
书中不仅讲述面向对象语言（Java、C#和C++）代码，也有专章讨论C这样的过程式语言。&lt;/p&gt;

&lt;p&gt;作者将理解、测试和修改代码的原理、技术和最新工具（自动化重构工具、单元测试框架、仿对象、集成测试框架等），
与解依赖技术和大量开发和设计优秀代码的原则、最佳实践相结合，许多内容非常深入，而且常常发前人所未发。&lt;/p&gt;

&lt;p&gt;书中处处体现出作者独到的洞察力，以及多年开发和指导软件项目所积累的丰富经验和深厚功力。
通过这部集大成之作，你不仅能掌握最顶尖的修改代码技术，还可以大大提高对代码和软件开发的领悟力。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我认为没有任何一本书能向这本书一样影响了我的编程观点。
它明确地告诉你如何处理其他人的代码，含蓄地教会你避免哪些（以及为什么要避免）。- Wolfbyte&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;同意。很多开发人员讨论用干净的石板来编写软件。
但我想几乎所有开发人员的某些时候是在吃其他开发人员的狗食。– Bernard Dy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoeseyx&quot;&gt;17、《&lt;a href=&quot;http://t.cn/zOEseyX&quot;&gt;编码：隐匿在计算机软硬件背后的语言&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;这是一本讲述计算机工作原理的书。&lt;/p&gt;

&lt;p&gt;不过，你千万不要因为“工作原理”之类的字眼就武断地认为，它是晦涩而难懂的。
作者用丰富的想象和清晰的笔墨将看似繁杂的理论阐述得通俗易懂，你丝毫不会感到枯燥和生硬。
更重要的是，你会因此而获得对计算机工作原理较深刻的理解。
这种理解不是抽象层面上的，而是具有一定深度的，这种深度甚至不逊于“电气工程师”和“程序员”的理解。&lt;/p&gt;

&lt;p&gt;不管你是计算机高手，还是对这个神奇的机器充满敬畏之心的菜鸟，
都不妨翻阅一下《编码:隐匿在计算机软硬件背后的语言》，读一读大师的经典作品，必然会有收获。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我推荐Charles Petzold的《编码》。
在这个充满工具和IDE的年代，很多复杂度已经从程序员那“抽取”走了，这本书一本开眼之作。 – hemil&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;zen-and-the-art-of-motorcycle-maintenancehttptcnzoesdwc&quot;&gt;18、《&lt;a href=&quot;http://t.cn/zOEsDwc&quot;&gt;禅与摩托车维修艺术 / Zen and the Art of Motorcycle Maintenance&lt;/a&gt;》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;对我影响最大的那本书是 Robert Pirsig 的《禅与摩托车维修艺术》。
不管你做什么事，总是要力求完美，彻底了解你手中的工具和任务，更为重要的是，
要有乐趣（因为如果你做事有乐趣，一切将自发引向更好的结果）。 – akr&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;peopleware--httptcnzoeskve&quot;&gt;19、《&lt;a href=&quot;http://t.cn/zOEskvE&quot;&gt;Peopleware / 人件集:人性化的软件开发&lt;/a&gt;》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Demarco 和 Lister 表明，软件开发中的首要问题是人，并非技术。
他们的答案并不简单，只是令人难以置信的成功。
第二版新增加了八章内容。 – Eduardo Molteni&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;coders-at-work--httptcnzoeskjt&quot;&gt;20、《&lt;a href=&quot;http://t.cn/zOEskjT&quot;&gt;Coders at Work / 编程人生&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;这是一本访谈笔录，记录了当今最具个人魅力的15位软件先驱的编程生涯。
包括DonaldKnuth、Jamie Zawinski、Joshua Bloch、Ken Thompson等在内的业界传奇人物，为我们讲述了
他们是怎么学习编程的，在编程过程中发现了什么以及他们对未来的看法，
并对诸如应该如何设计软件等长久以来一直困扰很多程序员的问题谈了自己的观点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一本非常有影响力的书，可以从中学到一些业界顶级人士的经验，了解他们如何思考并工作。 – Jahanzeb Farooq&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;surely-youre-joking-mr-feynman--&quot;&gt;21、《Surely You’re Joking, Mr. Feynman! / 别闹了，费曼先生！》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;虽然这本书可能有点偏题，但不管你信不信，这本书曾在计算机科学专业课程的阅读列表之上。
一个优秀的角色模型，一本有关好奇心的优秀书籍。 – mike511&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;effective-java-httptcnzonvvov&quot;&gt;22、《&lt;a href=&quot;http://t.cn/zOnvvoV&quot;&gt;Effective Java 中文版&lt;/a&gt;》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;此书第二版教你如何编写漂亮并高效的代码，虽然这是一本Java书，但其中有很多跨语言的理念。 – Marcio Aguiar&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;patterns-of-enterprise-application-architecture--httptcnzonvp4i&quot;&gt;23、《&lt;a href=&quot;http://t.cn/zOnvP4i&quot;&gt;Patterns of Enterprise Application Architecture / 企业应用架构模式&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;很奇怪，还没人推荐 Martin Fowler 的《企业应用架构模式》- levi rosol&lt;/p&gt;

&lt;h2 id=&quot;the-little-schemerthe-seasoned-schemer-nmiranda&quot;&gt;24、《The Little Schemer》和《The Seasoned Schemer》 nmiranda&lt;/h2&gt;

&lt;p&gt;这两本是LISP的英文书，尚无中文版。
美国东北大学网站上也有电子版。&lt;/p&gt;

&lt;h2 id=&quot;the-inmates-are-running-the-asylum-why-high-tech-products-drive-us-crazy-and-how-to-restore-the-sanityalan-coopervisual-basic&quot;&gt;25、《交互设计之路》英文名：《The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity》该书作者：Alan Cooper，人称Visual Basic之父，交互设计之父。&lt;/h2&gt;

&lt;p&gt;本书是基于众多商务案例，讲述如何创建更好的、高客户忠诚度的软件产品和基于软件的高科技产品的书。
本书列举了很多真实可信的实际例子，说明目前在软件产品和基于软件的高科技产品中，普遍存在着“难用”的问题。&lt;/p&gt;

&lt;p&gt;作者认为，“难用”问题是由这些产品中存在着的高度“认知摩擦”引起的，
而产生这个问题的根源在于现今软件开发过程中欠缺了一个为用户利益着想的前期“交互设计”阶段。
“难用”的产品不仅损害了用户的利益，最终也将导致企业的失败。&lt;/p&gt;

&lt;p&gt;本书通过一些生动的实例，让人信服地讲述了由作者倡导的“目标导向”交互设计方法在解决“难用”问题方面的有效性，
证实了只有改变现有观念，才能有效地在开发过程中引入交互设计，将产品的设计引向成功。&lt;/p&gt;

&lt;p&gt;本书虽然是一本面向商务人员而编写的书，但也适合于所有参与软件产品和基于软件的高科技产品开发的专业人士，
以及关心软件行业和高科技行业现状与发展的人士阅读。&lt;/p&gt;

&lt;p&gt;他还有另一本中文版著作：《About Face 3 交互设计精髓》&lt;/p&gt;

&lt;h2 id=&quot;whys-poignant-guide-to-ruby-&quot;&gt;26、《Why’s (Poignant) Guide to Ruby 》&lt;/h2&gt;

&lt;p&gt;如果你不是程序员，阅读此书可能会很有趣，但如果你已经是个程序员，可能会有点乏味。&lt;/p&gt;

&lt;h2 id=&quot;unix&quot;&gt;27、《Unix编程艺术》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;It is useful regardless operating system you use. – J.F. Sebastian&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;不管你使用什么操作系统，这本书都很有用。 – J.F. Sebastian&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzonvhrm&quot;&gt;28、《&lt;a href=&quot;http://t.cn/zOnvhRM&quot;&gt;高效程序员的45个习惯：敏捷开发修炼之道&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;45个习惯，分为7个方面：工作态度、学习、软件交付、反馈、编码、调试和协作。&lt;/p&gt;

&lt;p&gt;每一个具体的习惯里，一开始提出一个谬论，然后展开分析，之后有正队性地提出正确的做法，并设身处地地讲出了正确做法给你个人的“切身感受”，最后列出几条注意事项，帮助你修正自己的做法（“平衡的艺术”）。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzonvzk7&quot;&gt;29、《&lt;a href=&quot;http://t.cn/zOnvzK7&quot;&gt;测试驱动开发&lt;/a&gt;》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;前面已经提到的很多书都启发了我，并影响了我，但这本书每位程序员都应该读。
它向我展示了单元测试和TDD的重要性，并让我很快上手。 – Curro&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我不关心你的代码有多好或优雅。
如果你没有测试，你或许就如同没有编写代码。
这本书得到的推荐数应该更高些。
人们讨论编写用户喜欢的软件，或既设计出色并健壮的高效代码，但如果你的软件有一堆bug，谈论那些东西毫无意义。– Adam Gent&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzonvzyq&quot;&gt;30、《&lt;a href=&quot;http://t.cn/zOnvZYq&quot;&gt;点石成金:访客至上的网页设计秘笈&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;可用性设计是Web设计中最重要也是难度最大的一项任务。
《点石成金－访客至上的网页设计秘笈（原书第二版）》作者根据多年从业的经验，剖析用户的心理，
在用户使用的模式、为扫描进行设计、导航设计、主页布局、可用性测试等方面提出了许多独特的观点，
并给出了大量简单、易行的可用性设计的建议。&lt;/p&gt;

&lt;p&gt;本书短小精炼，语言轻松诙谐，书中穿插大量色彩丰富的屏幕截图、趣味丛生的卡通插图以及包含大量信息的图表，
使枯燥的设计原理变得平易近人。&lt;/p&gt;

&lt;p&gt;本书适合从事Web设计和Web开发的技术人员阅读，特别适合为如何留住访问者而苦恼的网站/网页设计人员阅读。
这是一本关于Web设计原则而不是Web设计技术的书。&lt;/p&gt;

&lt;p&gt;本书作者是Web设计专家，具有丰富的实践经验。
他用幽默的语言为你揭示Web设计中重要但却容易被忽视的问题，只需几个小时，
你便能对照书中讲授的设计原则找到网站设计的症结所在，令你的网站焕然一新。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;取决于你所追求的目标。
我喜欢《代码大全》是因纯编程，《点石成金》是一本有关UI设计的卓越书籍。 – Justin Standard&lt;/p&gt;
&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>Markdown 语法 (简体中文版)</title>
   <link href="http://http://coolshell.info/blog/2014/07/markdown-syntax.html"/>
   <updated>2014-07-11T00:00:00+00:00</updated>
   <id>/blog/2014/07/markdown-syntax</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; This is Simplelified  Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to &lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown: Syntax&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt; 这份文档派生(fork)于&lt;a href=&quot;http://markdown.tw/&quot;&gt;繁体中文版&lt;/a&gt;，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里&lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md&quot;&gt;查看它的源文件&lt;/a&gt;。「繁体中文版的原始文件可以&lt;a href=&quot;https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md&quot;&gt;查看这里&lt;/a&gt; 。」–By @&lt;a href=&quot;http://twitter.com/riku&quot;&gt;riku&lt;/a&gt; / 本项目托管于 &lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN&quot;&gt;GitCafe&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 本项目同时也托管于 &lt;a href=&quot;https://github.com/riku/Markdown-Syntax-CN&quot;&gt;Github&lt;/a&gt; 上，请通过 fork＋pull request 方式来帮忙改进本项目。&lt;/p&gt;

&lt;h1 id=&quot;markdown----markdown-basicshtml&quot;&gt;Markdown 语法说明 (简体中文版) / (&lt;a href=&quot;./markdown-basics.html&quot;&gt;点击查看快速入门&lt;/a&gt;)&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#overview&quot;&gt;概述&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#philosophy&quot;&gt;宗旨&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#html&quot;&gt;兼容 HTML&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#autoescape&quot;&gt;特殊字符自动转换&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#block&quot;&gt;区块元素&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#p&quot;&gt;段落和换行&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#header&quot;&gt;标题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#blockquote&quot;&gt;区块引用&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#list&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#precode&quot;&gt;代码区块&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hr&quot;&gt;分隔线&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#span&quot;&gt;区段元素&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#link&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#em&quot;&gt;强调&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#code&quot;&gt;代码&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#img&quot;&gt;图片&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#misc&quot;&gt;其它&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#backslash&quot;&gt;反斜杠&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#autolink&quot;&gt;自动链接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#acknowledgement&quot;&gt;感谢&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;overview&quot;&gt;概述&lt;/h2&gt;

&lt;h3 id=&quot;philosophy&quot;&gt;宗旨&lt;/h3&gt;

&lt;p&gt;Markdown 的目标是实现「易读易写」。&lt;/p&gt;

&lt;p&gt;可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt;、&lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt;、&lt;a href=&quot;http://textism.com/tools/textile/&quot;&gt;Textile&lt;/a&gt;、&lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;reStructuredText&lt;/a&gt;、&lt;a href=&quot;http://www.triptico.com/software/grutatxt.html&quot;&gt;Grutatext&lt;/a&gt; 和 &lt;a href=&quot;http://ettext.taint.org/doc/&quot;&gt;EtText&lt;/a&gt;，而最大灵感来源其实是纯文本电子邮件的格式。&lt;/p&gt;

&lt;p&gt;总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。&lt;/p&gt;

&lt;h3 id=&quot;html&quot;&gt;兼容 HTML&lt;/h3&gt;

&lt;p&gt;Markdown 语法的目标是：成为一种适用于网络的&lt;em&gt;书写&lt;/em&gt;语言。&lt;/p&gt;

&lt;p&gt;Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想&lt;em&gt;不是&lt;/em&gt;要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种&lt;em&gt;发布&lt;/em&gt;的格式，Markdown 是一种&lt;em&gt;书写&lt;/em&gt;的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。&lt;/p&gt;

&lt;p&gt;不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。&lt;/p&gt;

&lt;p&gt;要制约的只有一些 HTML 区块元素――比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;table&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;

&lt;p&gt;例子如下，在 Markdown 文件里加上一段 HTML 表格：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这是一个普通段落。

&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;

这是另一个普通段落。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的&lt;code class=&quot;highlighter-rouge&quot;&gt;*强调*&lt;/code&gt;会没有效果。&lt;/p&gt;

&lt;p&gt;HTML 的区段（行内）标签如 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;del&amp;gt;&lt;/code&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。&lt;/p&gt;

&lt;p&gt;和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。&lt;/p&gt;

&lt;h3 id=&quot;autoescape&quot;&gt;特殊字符自动转换&lt;/h3&gt;

&lt;p&gt;在 HTML 文件中，有两个字符需要特殊处理： &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 。 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 符号用于起始标签，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;amp;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 字符尤其让网络文档编写者受折磨，如果你要打「&lt;code class=&quot;highlighter-rouge&quot;&gt;AT&amp;amp;T&lt;/code&gt;」 ，你必须要写成「&lt;code class=&quot;highlighter-rouge&quot;&gt;AT&amp;amp;amp;T&lt;/code&gt;」。而网址中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 字符也要转换。比如你要链接到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;q=larry+bird
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你必须要把网址转换写为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;amp;q=larry+bird
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;才能放到链接标签的 &lt;code class=&quot;highlighter-rouge&quot;&gt;href&lt;/code&gt; 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。&lt;/p&gt;

&lt;p&gt;Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;amp&lt;/code&gt;;。&lt;/p&gt;

&lt;p&gt;所以你如果要在文档中插入一个版权符号 &lt;code class=&quot;highlighter-rouge&quot;&gt;©&lt;/code&gt;，你可以这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;amp;copy;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 会保留它不动。而若你写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AT&amp;amp;T
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 就会将它转为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AT&amp;amp;amp;T
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;类似的状况也会发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 符号上，因为 Markdown 允许 &lt;a href=&quot;#html&quot;&gt;兼容 HTML&lt;/a&gt; ，如果你是把 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4 &amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 将会把它转换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4 &amp;amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不过需要注意的是，code 范围内，不论是行内还是区块， &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 两个符号都&lt;em&gt;一定&lt;/em&gt;会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;block&quot;&gt;区块元素&lt;/h2&gt;

&lt;h3 id=&quot;p&quot;&gt;段落和换行&lt;/h3&gt;

&lt;p&gt;一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。&lt;/p&gt;

&lt;p&gt;「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;

&lt;p&gt;如果你&lt;em&gt;确实&lt;/em&gt;想要依赖 Markdown 来插入 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; 标签的话，在插入处先按入两个以上的空格然后回车。&lt;/p&gt;

&lt;p&gt;的确，需要多费点事（多加空格）来产生 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; ，但是简单地「每个换行都转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 &lt;a href=&quot;#blockquote&quot;&gt;区块引用&lt;/a&gt; 和多段落的 &lt;a href=&quot;#list&quot;&gt;列表&lt;/a&gt; 在使用换行来排版的时候，不但更好用，还更方便阅读。&lt;/p&gt;

&lt;h3 id=&quot;header&quot;&gt;标题&lt;/h3&gt;

&lt;p&gt;Markdown 支持两种标题的语法，类 &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt; 和类 &lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt; 形式。&lt;/p&gt;

&lt;p&gt;类 Setext 形式是用底线的形式，利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; （最高阶标题）和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; （第二阶标题），例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is an H1
=============

This is an H2
-------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任何数量的 &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 都可以有效果。&lt;/p&gt;

&lt;p&gt;类 Atx 形式则是在行首插入 1 到 6 个 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; ，对应到标题 1 到 6 阶，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 这是 H1

## 这是 H2

###### 这是 H6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;，而行尾的 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;blockquote&quot;&gt;区块引用 Blockquotes&lt;/h3&gt;

&lt;p&gt;Markdown 标记区块引用是使用类似 email 中用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&amp;gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&amp;gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&amp;gt; 
&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&amp;gt; id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; This is the first level of quoting.
&amp;gt;
&amp;gt; &amp;gt; This is nested blockquote.
&amp;gt;
&amp;gt; Back to the first level.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; ## 这是一个标题。
&amp;gt; 
&amp;gt; 1.   这是第一行列表项。
&amp;gt; 2.   这是第二行列表项。
&amp;gt; 
&amp;gt; 给出一些例子代码：
&amp;gt; 
&amp;gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择&lt;em&gt;增加引用阶层&lt;/em&gt;。&lt;/p&gt;

&lt;h3 id=&quot;list&quot;&gt;列表&lt;/h3&gt;

&lt;p&gt;Markdown 支持有序列表和无序列表。&lt;/p&gt;

&lt;p&gt;无序列表使用星号、加号或是减号作为列表标记：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   Red
*   Green
*   Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等同于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+   Red
+   Green
+   Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也等同于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-   Red
-   Green
-   Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有序列表则使用数字接着一个英文句点：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  Bird
2.  McHale
3.  Parish
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;McHale&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Parish&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你的列表标记写成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  Bird
1.  McHale
1.  Parish
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或甚至是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3. Bird
1. McHale
8. Parish
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。&lt;/p&gt;

&lt;p&gt;如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。&lt;/p&gt;

&lt;p&gt;列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。&lt;/p&gt;

&lt;p&gt;要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是如果你懒，那也行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 
标签包起来，举例来说：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   Bird
*   Magic
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Magic&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是这个：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   Bird

*   Magic
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Bird&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Magic&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You&#39;re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要在列表项目内放进引用，那 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 就需要缩进：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   A list item with a blockquote:

    &amp;gt; This is a blockquote
    &amp;gt; inside a list item.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要放代码区块的话，该区块就需要缩进&lt;em&gt;两次&lt;/em&gt;，也就是 8 个空格或是 2 个制表符：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   一列表项包含一个列表区块：

        &amp;lt;代码写在这&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，项目列表很可能会不小心产生，像是下面这样的写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1986. What a great season.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;换句话说，也就是在行首出现&lt;em&gt;数字-句点-空白&lt;/em&gt;，要避免这样的状况，你可以在句点前面加上反斜杠。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1986\. What a great season.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;precode&quot;&gt;代码区块&lt;/h3&gt;

&lt;p&gt;和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 标签来把代码区块包起来。&lt;/p&gt;

&lt;p&gt;要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这是一个普通段落：

    这是一个代码区块。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 会转换成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;这是一个普通段落：&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;这是一个代码区块。
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Here is an example of AppleScript:

    tell application &quot;Foo&quot;
        beep
    end tell
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;Here is an example of AppleScript:&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;tell application &quot;Foo&quot;
    beep
end tell
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。&lt;/p&gt;

&lt;p&gt;在代码区块里面， &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;div class=&quot;footer&quot;&amp;gt;
        &amp;amp;copy; 2004 Foo Corporation
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;div class=&quot;footer&quot;&amp;amp;gt;
    &amp;amp;amp;copy; 2004 Foo Corporation
&amp;amp;lt;/div&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。&lt;/p&gt;

&lt;h3 id=&quot;hr&quot;&gt;分隔线&lt;/h3&gt;

&lt;p&gt;你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* * *

***

*****

- - -

---------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;span&quot;&gt;区段元素&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;链接&lt;/h3&gt;

&lt;p&gt;Markdown 支持两种形式的链接语法： &lt;em&gt;行内式&lt;/em&gt;和&lt;em&gt;参考式&lt;/em&gt;两种形式。&lt;/p&gt;

&lt;p&gt;不管是哪一种，链接文字都是用 [方括号] 来标记。&lt;/p&gt;

&lt;p&gt;要建立一个&lt;em&gt;行内式&lt;/em&gt;的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会产生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;This is &amp;lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&amp;gt;
an example&amp;lt;/a&amp;gt; inline link.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;a href=&quot;http://example.net/&quot;&amp;gt;This link&amp;lt;/a&amp;gt; has no
title attribute.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你是要链接到同样主机的资源，你可以使用相对路径：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;See my [About](/about/) page for details.   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;参考式&lt;/em&gt;的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is [an example][id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以选择性地在两个方括号中间加上一个空格：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is [an example] [id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着，在文件的任意处，你可以把这个标记的链接内容定义出来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[id]: http://example.com/  &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;链接内容定义的形式为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字&lt;/li&gt;
  &lt;li&gt;接着一个冒号&lt;/li&gt;
  &lt;li&gt;接着一个以上的空格或制表符&lt;/li&gt;
  &lt;li&gt;接着链接的网址&lt;/li&gt;
  &lt;li&gt;选择性地接着 title 内容，可以用单引号、双引号或是括弧包着&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这三种链接的定义都是相同：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[foo]: http://example.com/  &quot;Optional Title Here&quot;
[foo]: http://example.com/  &#39;Optional Title Here&#39;
[foo]: http://example.com/  (Optional Title Here)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;请注意：&lt;/strong&gt;有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。&lt;/p&gt;

&lt;p&gt;链接网址也可以用方括号包起来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[id]: &amp;lt;http://example.com/&amp;gt;  &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[id]: http://example.com/longish/path/to/resource/here
    &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。&lt;/p&gt;

&lt;p&gt;链接辨别标签可以有字母、数字、空白和标点符号，但是并&lt;em&gt;不&lt;/em&gt;区分大小写，因此下面两个链接是一样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[link text][a]
[link text][A]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;隐式链接标记&lt;/em&gt;功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Google][]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后定义链接内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Google]: http://google.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Visit [Daring Fireball][] for more information.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后接着定义链接：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Daring Fireball]: http://daringfireball.net/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。&lt;/p&gt;

&lt;p&gt;下面是一个参考式链接的范例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &quot;Google&quot;
  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [3]: http://search.msn.com/    &quot;MSN Search&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果改成用链接名称的方式写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        &quot;Google&quot;
  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面两种写法都会产生下面的 HTML。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from
&amp;lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt;
or &amp;lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)
than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or
[MSN](http://search.msn.com/ &quot;MSN Search&quot;).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。&lt;/p&gt;

&lt;p&gt;使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。&lt;/p&gt;

&lt;h3 id=&quot;em&quot;&gt;强调&lt;/h3&gt;

&lt;p&gt;Markdown 使用星号（&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;）和底线（&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;）作为标记强调字词的符号，被 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 包围的字词会被转成用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt; 标签包围，用两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 包起来的话，则会被转成 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会转成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;em&amp;gt;single asterisks&amp;lt;/em&amp;gt;

&amp;lt;em&amp;gt;single underscores&amp;lt;/em&amp;gt;

&amp;lt;strong&amp;gt;double asterisks&amp;lt;/strong&amp;gt;

&amp;lt;strong&amp;gt;double underscores&amp;lt;/strong&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。&lt;/p&gt;

&lt;p&gt;强调也可以直接插在文字中间：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;un*frigging*believable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是&lt;strong&gt;如果你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 两边都有空白的话，它们就只会被当成普通的符号&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\*this text is surrounded by literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;code&quot;&gt;代码&lt;/h3&gt;

&lt;p&gt;如果要标记一小段行内代码，你可以用反引号把它包起来（&lt;code class=&quot;highlighter-rouge&quot;&gt;`&lt;/code&gt;），例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Use the `printf()` function.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会产生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;Use the &amp;lt;code&amp;gt;printf()&amp;lt;/code&amp;gt; function.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;``There is a literal backtick (`) here.``
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这段语法会产生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;There is a literal backtick (`) here.&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会产生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;A single backtick in a code span: &amp;lt;code&amp;gt;`&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;A backtick-delimited string in a code span: &amp;lt;code&amp;gt;`foo`&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在代码区段内，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 和方括号&lt;strong&gt;都&lt;/strong&gt;会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Please don&#39;t use any `&amp;lt;blink&amp;gt;` tags.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;转为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;Please don&#39;t use any &amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`&amp;amp;#8212;` is the decimal-encoded equivalent of `&amp;amp;mdash;`.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以产生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt; is the decimal-encoded
equivalent of &amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;img&quot;&gt;图片&lt;/h3&gt;

&lt;p&gt;很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。&lt;/p&gt;

&lt;p&gt;Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： &lt;em&gt;行内式&lt;/em&gt;和&lt;em&gt;参考式&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;行内式的图片语法看起来像是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;详细叙述如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个惊叹号 &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;接着一个方括号，里面放上图片的替代文字&lt;/li&gt;
  &lt;li&gt;接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上
选择性的 ‘title’ 文字。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考式的图片语法则长得像这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![Alt text][id]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[id]: url/to/image  &quot;Optional title attribute&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;misc&quot;&gt;其它&lt;/h2&gt;

&lt;h3 id=&quot;autolink&quot;&gt;自动链接&lt;/h3&gt;

&lt;p&gt;Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;http://example.com/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 会转为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;a href=&quot;http://example.com/&quot;&amp;gt;http://example.com/&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;address@example.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 会转成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;a href=&quot;&amp;amp;#x6D;&amp;amp;#x61;i&amp;amp;#x6C;&amp;amp;#x74;&amp;amp;#x6F;:&amp;amp;#x61;&amp;amp;#x64;&amp;amp;#x64;&amp;amp;#x72;&amp;amp;#x65;
&amp;amp;#115;&amp;amp;#115;&amp;amp;#64;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6C;e&amp;amp;#x2E;&amp;amp;#99;&amp;amp;#111;
&amp;amp;#109;&quot;&amp;gt;&amp;amp;#x61;&amp;amp;#x64;&amp;amp;#x64;&amp;amp;#x72;&amp;amp;#x65;&amp;amp;#115;&amp;amp;#115;&amp;amp;#64;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;
&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6C;e&amp;amp;#x2E;&amp;amp;#99;&amp;amp;#111;&amp;amp;#109;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在浏览器里面，这段字串（其实是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a href=&quot;mailto:address@example.com&quot;&amp;gt;address@example.com&amp;lt;/a&amp;gt;&lt;/code&gt;）会变成一个可以点击的「address@example.com」链接。&lt;/p&gt;

&lt;p&gt;（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）&lt;/p&gt;

&lt;h3 id=&quot;backslash&quot;&gt;反斜杠&lt;/h3&gt;

&lt;p&gt;Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt; 标签），你可以在星号的前面加上反斜杠：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\*literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;acknowledgement&quot;&gt;感谢&lt;/h2&gt;

&lt;p&gt;感谢 &lt;a href=&quot;https://twitter.com/#!/leafy7382&quot;&gt;leafy7382&lt;/a&gt; 协助翻译，&lt;a href=&quot;http://iamhlb.com/&quot;&gt;hlb&lt;/a&gt;、&lt;a href=&quot;http://twitter.com/randylien&quot;&gt;Randylien&lt;/a&gt; 帮忙润稿，&lt;a href=&quot;https://twitter.com/#!/ethantw&quot;&gt;ethantw&lt;/a&gt; 的&lt;a href=&quot;http://ethantw.net/projects/han/&quot;&gt;汉字标准格式・CSS Reset&lt;/a&gt;， &lt;a href=&quot;http://kidwm.net/&quot;&gt;WM&lt;/a&gt; 回报文字错误。&lt;/p&gt;

&lt;p&gt;感谢 &lt;a href=&quot;https://github.com/fenprace&quot;&gt;fenprace&lt;/a&gt;，&lt;a href=&quot;https://github.com/addv&quot;&gt;addv&lt;/a&gt;。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>markdown 快速入门</title>
   <link href="http://http://coolshell.info/blog/2014/07/markdown-basics.html"/>
   <updated>2014-07-10T00:00:00+00:00</updated>
   <id>/blog/2014/07/markdown-basics</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt; 这份文档派生(fork)于&lt;a href=&quot;http://markdown.tw/&quot;&gt;繁体中文版&lt;/a&gt;，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里&lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basics.md&quot;&gt;查看它的源文件&lt;/a&gt;。「繁体中文版的原始文件可以&lt;a href=&quot;https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md&quot;&gt;查看这里&lt;/a&gt;」–By @&lt;a href=&quot;http://twitter.com/riku&quot;&gt;riku&lt;/a&gt; / 本项目托管于 &lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN&quot;&gt;GitCafe&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 本项目同时也托管于 &lt;a href=&quot;https://github.com/riku/Markdown-Syntax-CN&quot;&gt;Github&lt;/a&gt;上，请通过 fork＋pull request 方式来帮忙改进本项目。&lt;/p&gt;

&lt;h1 id=&quot;markdown-basics---markdown-syntaxhtml&quot;&gt;Markdown: Basics （快速入门） / (&lt;a href=&quot;./markdown-syntax.html&quot;&gt;点击查看完整语法说明&lt;/a&gt;)&lt;/h1&gt;

&lt;h2 id=&quot;getting-the-gist-of-markdowns-formatting-syntax&quot;&gt;Getting the Gist of Markdown’s Formatting Syntax&lt;/h2&gt;

&lt;p&gt;此页提供了 Markdown 的简单概念， &lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md&quot; title=&quot;Markdown Syntax&quot;&gt;语法说明&lt;/a&gt; 页提供了完整详细的文档，说明了每项功能。但是 Markdown 其实很简单就可以上手，此页文档提供了一些范例，并且每个范例都会提供输出的 HTML 结果。&lt;/p&gt;

&lt;p&gt;其实直接试试看也是一个很不错的方法， &lt;a href=&quot;http://daringfireball.net/projects/markdown/dingus&quot; title=&quot;Markdown Dingus&quot;&gt;Dingus&lt;/a&gt; 是一个网页应用程序，你可以把自已编写的 Markdown 文档转成 XHTML。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;段落、标题、区块代码&lt;/h2&gt;

&lt;p&gt;一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。&lt;/p&gt;

&lt;p&gt;Markdown 支持两种标题的语法，&lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt; 和 &lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt; 形式。Setext 形式是用底线的形式，利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; （最高阶标题）和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; （第二阶标题），Atx 形式在行首插入 1 到 6 个 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; ，对应到标题 1 到 6 阶。&lt;/p&gt;

&lt;p&gt;区块引用则使用 email 形式的 ‘&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;’ 角括号。&lt;/p&gt;

&lt;p&gt;Markdown 语法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A First Level Header
====================
A Second Level Header
---------------------

Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.

The quick brown fox jumped over the lazy
dog&#39;s back.
### Header 3

&amp;gt; This is a blockquote.
&amp;gt; 
&amp;gt; This is the second paragraph in the blockquote.
&amp;gt;
&amp;gt; ## This is an H2 in a blockquote
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;h1&amp;gt;A First Level Header&amp;lt;/h1&amp;gt;
&amp;lt;h2&amp;gt;A Second Level Header&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The quick brown fox jumped over the lazy
dog&#39;s back.&amp;lt;/p&amp;gt;
&amp;lt;h3&amp;gt;Header 3&amp;lt;/h3&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;This is a blockquote.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;This is the second paragraph in the blockquote.&amp;lt;/p&amp;gt;
&amp;lt;h2&amp;gt;This is an H2 in a blockquote&amp;lt;/h2&amp;gt;
&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;修辞和强调&lt;/h3&gt;

&lt;p&gt;Markdown 使用星号和底线来标记需要强调的区段。&lt;/p&gt;

&lt;p&gt;Markdown 语法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Some of these words *are emphasized*.
Some of these words _are emphasized also_.
Use two asterisks for **strong emphasis**.
Or, if you prefer, __use two underscores instead__.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;Some of these words &amp;lt;em&amp;gt;are emphasized&amp;lt;/em&amp;gt;.
Some of these words &amp;lt;em&amp;gt;are emphasized also&amp;lt;/em&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Use two asterisks for &amp;lt;strong&amp;gt;strong emphasis&amp;lt;/strong&amp;gt;.
Or, if you prefer, &amp;lt;strong&amp;gt;use two underscores instead&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;列表&lt;/h2&gt;

&lt;p&gt;无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* Candy.
* Gum.
* Booze.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;加号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Candy.
+ Gum.
+ Booze.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;和减号&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- Candy.
- Gum.
- Booze.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;都会输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Candy.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Gum.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Booze.&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有序的列表则是使用一般的数字接着一个英文句点作为项目标记：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. Red
2. Green
3. Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Red&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Green&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Blue&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你在项目之间插入空行，那项目的内容会用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* A list item.
With multiple paragraphs.

* Another item in the list.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;A list item.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;With multiple paragraphs.&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Another item in the list.&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt; ### 链接 ###
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 支援两种形式的链接语法： &lt;em&gt;行内&lt;/em&gt; 和 &lt;em&gt;参考&lt;/em&gt; 两种形式，两种都是使用角括号来把文字转成连结。&lt;/p&gt;

&lt;p&gt;行内形式是直接在后面用括号直接接上链接：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is an [example link](http://example.com/).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;http://example.com/&quot;&amp;gt;
example link&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以选择性的加上 title 属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is an [example link](http://example.com/ &quot;With a Title&quot;).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&amp;gt;
example link&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I get 10 times more traffic from [Google][1] than from
[Yahoo][2] or [MSN][3].

[1]: http://google.com/ &quot;Google&quot;
[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;
[3]: http://search.msn.com/ &quot;MSN Search&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from &amp;lt;a href=&quot;http://search.yahoo.com/&quot;
title=&quot;Yahoo Search&quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt; or &amp;lt;a href=&quot;http://search.msn.com/&quot;
title=&quot;MSN Search&quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I start my morning with a cup of coffee and
[The New York Times][NY Times].

[ny times]: http://www.nytimes.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;I start my morning with a cup of coffee and
&amp;lt;a href=&quot;http://www.nytimes.com/&quot;&amp;gt;The New York Times&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;图片&lt;/h3&gt;

&lt;p&gt;图片的语法和链接很像。&lt;/p&gt;

&lt;p&gt;行内形式（title 是选择性的）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![alt text](/path/to/img.jpg &quot;Title&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考形式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![alt text][id]

[id]: /path/to/img.jpg &quot;Title&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面两种方法都会输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;代码&lt;/h3&gt;
&lt;p&gt;在一般的段落文字中，你可以使用反引号 &lt;code class=&quot;highlighter-rouge&quot;&gt;`&lt;/code&gt; 来标记代码区段，区段内的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I strongly recommend against using any `&amp;lt;blink&amp;gt;` tags.

I wish SmartyPants used named entities like `&amp;amp;mdash;`
instead of decimal-encoded entites like `&amp;amp;#8212;`.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;I strongly recommend against using any
&amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;I wish SmartyPants used named entities like
&amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt; instead of decimal-encoded
entites like &amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 也一样会自动转成 HTML 实体。&lt;/p&gt;

&lt;p&gt;Markdown 语法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If you want your page to validate under XHTML 1.0 Strict,
you&#39;ve got to put paragraph tags in your blockquotes:

&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt;
&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;If you want your page to validate under XHTML 1.0 Strict,
you&#39;ve got to put paragraph tags in your blockquotes:&amp;lt;/p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;blockquote&amp;amp;gt;
&amp;amp;lt;p&amp;amp;gt;For example.&amp;amp;lt;/p&amp;amp;gt;
&amp;amp;lt;/blockquote&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>C语言高级编程指南</title>
   <link href="http://http://coolshell.info/blog/2014/07/c-advaced-programming.html"/>
   <updated>2014-07-05T00:00:00+00:00</updated>
   <id>/blog/2014/07/c-advaced-programming</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;整形溢出和提升&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子,
你觉得输出结果是什么:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(int argc, char** argv) {
    long i = -1;

    if (i &amp;lt; sizeof(i)) {
         printf(&quot;OK\n&quot;);
    }
    else {
         printf(&quot;error\n&quot;);
    }

    return 0;
} 当一个变量转换成无符号整形时,i的值不再是-1,而是 size_t的最大值,因 为sizeof操作返回的是一个 size_t类型的无符号数。 在C99/C11标准里写道:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;“If the operand that has unsigned integer type has rank greater or
equal to the rank of the type of the other operand, then the operand
with signed integer type is converted to the type of the operand with
unsigned integer type.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在C标准里面 size_t至少是一个 16 位的无符号整数,对于给定的架构 size_t 一般对应long,所以sizeof（int）和size_t至少相等,这就带来了可移植性的问题,C标准没有定义 short, int,long,longlong的大小,只是说明了他们的最小长度,对于 x86_64 架构,long在Linux下是64位,而在64位Windows下是32位。一般的方法是采用固定长度的类型比如定义在C99头文件stdint.h中的uint16_t,int32_t,uint_least16_t,uint_fast16_t等。&lt;/p&gt;

&lt;p&gt;如果 int可以表示原始类型的所有值,那么这个操作数会转换成 int,否则
他会转换成 unsigned int。下面这个函数在 32 位平台返回 65536,但是在 16 位系统返回 0。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uint32_t sum()
{
    uint16_t a = 65535;
    uint16_t b = 1;
    return a+b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于char 类型到底是 signed 还是 unsigned 取决于硬件架构和操作系统,通常
由特定平台的 ABI(Application Binary Interface) 指定,如果是 signed char,下面的代码输出-128 和-127,否则输出 128,129(x86 架构)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char c = 128;
char d = 129;
printf(&quot;%d,%d\n&quot;,c,d);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;##内存管理和分配&lt;/p&gt;

&lt;p&gt;malloc 函数分配制定字节大小的内存,对象未被初始化,如果 size 是 0 取
决与系统实现。malloc(0)返回一个空指针或者 unique pointer,如果 size 是表达式的运算结果,确保没有整形溢出。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“If the size of the space requested is 0, the behavior is
implementation- defined: the value returned shall be either a null
pointer or a unique pointer.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;size_t computed_size;

if (elem_size &amp;amp;&amp;amp; num &amp;gt; SIZE_MAX / elem_size) {
    errno = ENOMEM;
    err(1, &quot;overflow&quot;);
}

computed_size = elem_size*num;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;malloc不会给分配的内存初始化，如果要对新分配的内存初始化，可以用calloc代替malloc,一般情况下给序列分配相等大小的元素时,用calloc来代替用表达式计算大小,calloc 会把内存初始化为 0。&lt;/p&gt;

&lt;p&gt;realloc 用来对已经分配内存的对象改变大小,如果新的 size 更大,额外的空间
没 有 被 初 始 化 , 如 果 提 供 给 realloc 的 指 针 是 空 指 针 , realloc 就 等 效 于malloc,如果原指针非空而 new size是0,结果依赖于操作系统的具体实现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“In case of failure realloc shall return NULL and leave provided memory
object intact. Thus it is important not only to check for integer
overflow of size argument, but also to correctly handle object size if
realloc fails.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面这段代码可以带你领会malloc,calloc，realloc,free的用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;malloc.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

#define VECTOR_OK            0
#define VECTOR_NULL_ERROR    1
#define VECTOR_SIZE_ERROR    2
#define VECTOR_ALLOC_ERROR   3

struct vector {
    int *data;
    size_t size;
};

int create_vector(struct vector *vc, size_t num) {

    if (vc == NULL) {
        return VECTOR_NULL_ERROR;
    }

    vc-&amp;gt;data = 0;
    vc-&amp;gt;size = 0;

    /* check for integer and SIZE_MAX overflow */
    if (num == 0 || SIZE_MAX / num &amp;lt; sizeof(int)) {
        errno = ENOMEM;
        return VECTOR_SIZE_ERROR;
    }

    vc-&amp;gt;data = calloc(num, sizeof(int));

    /* calloc faild */
    if (vc-&amp;gt;data == NULL) {
        return VECTOR_ALLOC_ERROR;
    }

    vc-&amp;gt;size = num * sizeof(int);
    return VECTOR_OK;
}

int grow_vector(struct vector *vc) {

    void *newptr = 0;
    size_t newsize;

    if (vc == NULL) {
        return VECTOR_NULL_ERROR;
    }


    /* check for integer and SIZE_MAX overflow */
    if (vc-&amp;gt;size == 0 || SIZE_MAX / 2 &amp;lt; vc-&amp;gt;size) {
        errno = ENOMEM;
        return VECTOR_SIZE_ERROR;
    }

    newsize = vc-&amp;gt;size * 2;

    newptr = realloc(vc-&amp;gt;data, newsize);

    /* realloc faild; vector stays intact size was not changed */
    if (newptr == NULL) {
        return VECTOR_ALLOC_ERROR;
    }

    /* upon success; update new address and size */
    vc-&amp;gt;data = newptr;
    vc-&amp;gt;size = newsize;
    return VECTOR_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;##避免重大错误&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用未初始化的变量，
 C语言要求所有变量在使用之前要初始化，使用未初始化的变量会造成为定义的行为，这和C++不同，C++保证所有变量在使用之前都得到初始化，Java&lt;strong&gt;尽量保证&lt;/strong&gt;变量使用前的得到初始化，如类基本数据成员会被初始化为默认值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;free错误
对空指针调用 free,对不是由 malloc family 函数分配的指针调用 free,或者对
已经调用 free 的指针再次调用 free。
一开始初始化指针为NULL可以减少错误,GCC和Clang编译器有-Wuninitialized 选项来对未初始化的变量显示警告信息,另外不要将同一个指针用于静态变量和动态变量。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char *ptr = NULL;
void nullfree(void **pptr) {
    void *ptr = *pptr;
    assert(ptr != NULL)
    free(ptr);
    *pptr = NULL;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.对空指针解引用，数组越界访问&lt;/p&gt;

&lt;p&gt;对NULL指针或者free’d内存解引用，数组越界访问，是很明显的错误，为了消除这种错误，一般的做法就是增加数组越界检查的功能，比如Java里的array就有下标检查的功能，但是这样会带来严重的性能代价，我们要修改ABI（application binary interface），让每个指针都跟随着它的范围信息，在数值计算中cost is terrible。&lt;/p&gt;

&lt;p&gt;4.违反类型规则&lt;/p&gt;

&lt;p&gt;把int×指针cast成float×，然后对它解引用，在C里面会引发undefined behavior，C规定这种类型的转换需要使用memset，C++里面有个reinterpret_cast函数用于无关类型之间的转换，reinterpret_cast &lt;new_type&gt; (expression)&lt;/new_type&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;##防止内存泄漏&lt;/p&gt;

&lt;p&gt;内存泄漏发生在程序不再使用的动态内存没有得到释放，这需要我们掌握动态分配对象的作用域，尤其是什么时候该调用free来释放内存，常用的集中方法如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在程序启动的时候分配
 在程序启动的时候分配需要的heap memory，程序退出时把释放的任务交给操作系统，这种方法一般适用于程序运行后马上退出的那种。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用变长数组（VLA）
 如果你需要一块变长大小的空间并且作用域在函数中，变长数组可以帮到你，但是也有一个限制，一个函数中的变长数组内存大小一般不超过几百字节，这个数字C标准没有明确的定义，最好是把内存分配到栈上，在栈上允许分配的最大VLA内存是SIZE_MAX，掌握目标平台的栈大小可以有效的防止栈溢出。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用引用计数
 引用计数是一个很好的管理内存的方法，特别是当你不希望自己定义的对象被复制时，每一次赋值把引用计数加1,每次失去引用就把引用计数减1,当引用计数等于0时，以为的对象已经不再需要了，我们需要释放对象占用的内存，由于C不提供自动的析构函数，我们必须手动释放内存，看一个例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
    
#define MAX_REF_OBJ 100
#define RC_ERROR -1
    
struct mem_obj_t{
    void *ptr;
    uint16_t count;
};
    
static struct mem_obj_t references[MAX_REF_OBJ];
static uint16_t reference_count = 0;
    
/* create memory object and return handle */
uint16_t create(size_t size){
    
    if (reference_count &amp;gt;= MAX_REF_OBJ)
        return RC_ERROR;

if (size){
  void *ptr = calloc(1, size);

if (ptr != NULL){
    references[reference_count].ptr = ptr;
    references[reference_count].count = 0;
    return reference_count++;
                }
        }

    return RC_ERROR;
}
        
        
/* get memory object and increment reference counter */
void* retain(uint16_t handle){

if(handle &amp;lt; reference_count &amp;amp;&amp;amp; handle &amp;gt;= 0){
    references[handle].count++;
    return references[handle].ptr;
    } else {
        return NULL;
    }
}
    
/* decrement reference counter */
void release(uint16_t handle){
printf(&quot;release\n&quot;);

if(handle &amp;lt; reference_count &amp;amp;&amp;amp; handle &amp;gt;= 0){
    struct mem_obj_t *object = &amp;amp;references[handle];

    if (object-&amp;gt;count &amp;lt;= 1){
        printf(&quot;released\n&quot;);
    free(object-&amp;gt;ptr);
    reference_count--;
} else {
    printf(&quot;decremented\n&quot;);
    object-&amp;gt;count--;
        }
     }
} C++标准库有个auto_ptr智能指针，能够自动释放指针所指对象的内存，C++ boost库有个boost：：shared_ptr智能指针，内置引用计数，支持拷贝和赋值，看下面这个例子：
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;

  &lt;p&gt;“Objects of shared_ptr types have the ability of taking ownership of a pointer and share that ownership: once they take ownership, the group of owners of a pointer become responsible for its deletion when the last one of them releases that ownership.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;boost/smart_ptr.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;
int main()
{
    // Basic useage
    boost::shared_ptr&amp;lt;int&amp;gt; p1(new int(10));
    std::cout &amp;lt;&amp;lt; &quot;ref count of p1: &quot; &amp;lt;&amp;lt; p1.use_count() &amp;lt;&amp;lt; std::endl;
    boost::shared_ptr&amp;lt;int&amp;gt; p2(p1); // or p2 = p1;
    std::cout &amp;lt;&amp;lt; &quot;ref count of p1: &quot; &amp;lt;&amp;lt; p1.use_count() &amp;lt;&amp;lt; std::endl;
    *p1 = 999;
    std::cout &amp;lt;&amp;lt; &quot;*p2: &quot; &amp;lt;&amp;lt; *p2 &amp;lt;&amp;lt; std::endl;
    p2.reset();
    std::cout &amp;lt;&amp;lt; &quot;ref count of p1: &quot; &amp;lt;&amp;lt; p1.use_count() &amp;lt;&amp;lt; std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.内存池，有利于减少内存碎片，看下面这个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;

struct mem_pool_t{
void* ptr;//指向内存池起始地址
size_t size;//内存池大小
size_t used;//已用内存大小
};

//create memory pool
struct mem_pool_t* create_pool(size_t size){
mem_pool_t* pool=calloc(1,sizeof(struct men_pool_t));
if(pool!=NULL){
void* mem=calloc(1,size);
if(mem!=NULL){
pool-&amp;gt;ptr=mem;
pool-&amp;gt;size=size;
pool-&amp;gt;used=0;
return pool;
        }
    }
return NULL;
}

//allocate memory from pool
void* pool_alloc(mem_pool_t* pool,size_t size){
if(pool=NULL)
    return NULL;
size_t bytes_left=pool-&amp;gt;size-pool-&amp;gt;used;
if(size&amp;amp;&amp;amp;size&amp;lt;=bytes_left){
    void* mem=pool-&amp;gt;ptr+pool-&amp;gt;used;
    pool-&amp;gt;used+=size;
    return mem;
    }
return NULL；
}

／／release memory of the pool
void pool_free(mem_pool_t* pool){
if(pool!=NULL){
free(pool-&amp;gt;ptr);
free(pool);
 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.垃圾回收机制
 引用计数采用的方法是当内存不再需要时得到手动释放，垃圾回收发生在内存分配失败或者内存到达一定的水位（watermarks），实现垃圾回收最简单的一个算法是MARK AND SWEEP算法，该算法的思路是遍历所有动态分配对象的内存，标记那些还能继续使用的，回收那些没有被标记的内存。
    Java采用的垃圾回收机制就更复杂了，思路也是回收那些不再使用的内存，JAVA的垃圾回收和C++的析构函数又不一样，C++保证对象在使用之前得到初始化，对象超出作用域之后内存得到释放，而JAVA不能保证对象一定被析构。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;##指针和数组&lt;/p&gt;

&lt;p&gt;我们一般的概念里指针和数组名是可互换的，但是在编译器里他们被不同的对待，当我们说一个对象或者表达式具有某种类型的时候我们一般是说这个对象是个左值（lvalue），当对象不是const的时候，左值是可以修改的，比如对象是复制操作符的左参数，而数组名是一个const左值，指向地一个元素的const指针，所以你不能给数组名赋值或者意图改变数组名，如果表达式是数组类型，数组名通常转换成指向地一个元素的指针。&lt;/p&gt;

&lt;p&gt;但是也有例外，什么情况下数组名不是一个指针呢？
1.当它是sizeof操作符的操作数时，返回数组占的内存字节数
2.当它是取地址操作&amp;amp;的操作数时，返回一个数组的地址&lt;/p&gt;

&lt;p&gt;看下面这个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;short a[] = {1,2,3};
short *pa;
short (*px)[];

void init(){
    pa = a;
    px = &amp;amp;a;

    printf(&quot;a:%p; pa:%p; px:%p\n&quot;, a, pa, px);

    printf(&quot;a[1]:%i; pa[1]:%i (*px)[1]:%i\n&quot;, a[1], pa[1],(*px)[1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;a是一个short类型数组，pa是一个指向short类型的指针，px呢？
px是一个指向数组类型的指针，在a被赋值给pa之前，他的值被转换成一个指向数组第一个元素的指针，下面那个a却没有转换，因为遇到的是&amp;amp;操作符。
数组下标a[1]等价于&lt;em&gt;(a+1),和p[1]一样，也指向&lt;/em&gt;(p+1)，但是两者还是有区别的，a是一个数组，它实际上存储的是第一个元素的地址，所以数组a是用来定位第一个元素的，而pa不一样，它就是一个指针，不是用来定位的。
再比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a[10];
int b[10];
int *a;
c=&amp;amp;a[0];//c是指向数组a地一个元素的指针
c=a;//a自动转换成指向第一个元素的指针，实际上是指针拷贝
b=a;//非法的，你不能用赋值符把一个数组的所有元素赋给另一个数组
a=c;//非法的，你不能修改const指针的值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Java编程Tips</title>
   <link href="http://http://coolshell.info/blog/2014/06/26-methods-to-improve-java-performance.html"/>
   <updated>2014-06-18T00:00:00+00:00</updated>
   <id>/blog/2014/06/26-methods-to-improve-java-performance</id>
   <content type="html">&lt;p&gt;原文： &lt;a href=&quot;http://www.iteye.com/magazines/66&quot;&gt;Java编程中“为了性能”尽量要做到的一些地方&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者： &lt;a href=&quot;http://javatgo.iteye.com/&quot;&gt;javatgo&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最近的机器内存又爆满了，除了新增机器内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。&lt;/p&gt;

&lt;p&gt;下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 尽量在合适的场合使用单例&lt;/h2&gt;

&lt;p&gt;使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;控制资源的使用，通过线程同步来控制资源的并发访问；&lt;/li&gt;
&lt;li&gt;控制实例的产生，以达到节约资源的目的；&lt;/li&gt;
&lt;li&gt;控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2. 尽量避免随意使用静态变量&lt;/h2&gt;

&lt;p&gt;要知道，当某个对象被定义为stataic变量所引用，那么gc通常是不会回收这个对象所占有的内存，如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class A{  
    static B b = new B();  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;3. 尽量避免过多过常的创建Java对象&lt;/h2&gt;

&lt;p&gt;尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。&lt;/p&gt;

&lt;h2 id=&quot;final&quot;&gt;4. 尽量使用final修饰符&lt;/h2&gt;

&lt;p&gt;带有final修饰符的类是不可派生的。&lt;/p&gt;

&lt;p&gt;在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。&lt;/p&gt;

&lt;p&gt;另外，如果一个类是final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;5. 尽量使用局部变量&lt;/h2&gt;

&lt;p&gt;调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。&lt;/p&gt;

&lt;p&gt;其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;6. 尽量处理好包装类型和基本类型两者的使用场所&lt;/h2&gt;

&lt;p&gt;虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。&lt;/p&gt;

&lt;p&gt;在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。&lt;/p&gt;

&lt;h2 id=&quot;synchronizedsynchronize&quot;&gt;7. 慎用synchronized，尽量减小synchronize的方法&lt;/h2&gt;

&lt;p&gt;都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。&lt;/p&gt;

&lt;p&gt;synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。&lt;/p&gt;

&lt;p&gt;所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。&lt;/p&gt;

&lt;h2 id=&quot;stringbuilderstringbuffer&quot;&gt;8. 尽量使用StringBuilder和StringBuffer进行字符串连接&lt;/h2&gt;

&lt;p&gt;这个就不多讲了。&lt;/p&gt;

&lt;h2 id=&quot;finalize&quot;&gt;9. 尽量不要使用finalize方法&lt;/h2&gt;

&lt;p&gt;实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;10. 尽量使用基本数据类型代替对象&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String str = &quot;hello&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String str = new String(&quot;hello&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o&lt;/p&gt;

&lt;h2 id=&quot;hashmaparraylist&quot;&gt;11. 单线程应尽量使用HashMap、ArrayList&lt;/h2&gt;

&lt;p&gt;HashTable、Vector等使用了同步机制，降低了性能。&lt;/p&gt;

&lt;h2 id=&quot;hashmap&quot;&gt;12. 尽量合理的创建HashMap&lt;/h2&gt;

&lt;p&gt;当你要创建一个比较大的hashMap时，充分利用另一个构造函数
public HashMap(int initialCapacity, float loadFactor)
避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;13. 尽量减少对变量的重复计算&lt;/h2&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(int i=0;i&amp;lt;list.size();i++)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应该改为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(int i=0,len=list.size();i&amp;lt;len;i++)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;14. 尽量避免不必要的创建&lt;/h2&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A a = new A();
if(i==1){list.add(a);}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应该改为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(i==1){
A a = new A();
list.add(a);}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;finally&quot;&gt;15. 尽量在finally块中释放资源&lt;/h2&gt;

&lt;p&gt;程序中使用到的资源应当被释放，以避免资源泄漏。&lt;/p&gt;

&lt;p&gt;这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。&lt;/p&gt;

&lt;h2 id=&quot;ab&quot;&gt;16. 尽量使用移位来代替’a/b’的操作&lt;/h2&gt;

&lt;p&gt;”/”是一个代价很高的操作，使用移位的操作将会更快和更有效&lt;/p&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int num = a / 4;
int num = a / 8;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应该改为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int num = a &amp;gt;&amp;gt; 2;
int num = a &amp;gt;&amp;gt; 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解&lt;/p&gt;

&lt;h2 id=&quot;ab-1&quot;&gt;17.尽量使用移位来代替’a*b’的操作&lt;/h2&gt;

&lt;p&gt;同样的，对于’*‘操作，使用移位的操作将会更快和更有效&lt;/p&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int num = a * 4;
int num = a * 8;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应该改为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int num = a &amp;lt;&amp;lt; 2;
int num = a &amp;lt;&amp;lt; 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;stringbuffer&quot;&gt;18. 尽量确定StringBuffer的容量&lt;/h2&gt;

&lt;p&gt;StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。&lt;/p&gt;

&lt;p&gt;在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;StringBuffer buffer = new StringBuffer(1000);  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;19. 尽量早释放无用对象的引用&lt;/h2&gt;

&lt;p&gt;大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Public void test(){  
    Object obj = new Object();  
    ……  
    Obj=null;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。&lt;/p&gt;

&lt;p&gt;但是如果是改成下面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Public void test(){  
    Object obj = new Object();  
    ……  
    Obj=null;  
    //执行耗时，耗内存操作；或调用耗时，耗内存的方法  
    ……  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;20. 尽量避免使用二维数组&lt;/h2&gt;

&lt;p&gt;二维数据占用的内存空间比一维数组多得多，大概10倍以上。&lt;/p&gt;

&lt;h2 id=&quot;split&quot;&gt;21. 尽量避免使用split&lt;/h2&gt;

&lt;p&gt;除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需 要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。&lt;/p&gt;

&lt;h2 id=&quot;arraylist--linkedlist&quot;&gt;22. ArrayList &amp;amp; LinkedList&lt;/h2&gt;

&lt;p&gt;一个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。&lt;/p&gt;

&lt;h2 id=&quot;systemarraycopy-&quot;&gt;23. 尽量使用System.arraycopy ()代替通过来循环复制数组&lt;/h2&gt;

&lt;p&gt;System.arraycopy() 要比通过循环来复制数组快的多&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;24. 尽量缓存经常使用的对象&lt;/h2&gt;

&lt;p&gt;尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;25. 尽量避免非常大的内存分配&lt;/h2&gt;

&lt;p&gt;有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;26. 慎用异常&lt;/h2&gt;

&lt;p&gt;当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。
构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。&lt;/p&gt;

&lt;p&gt;当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。
栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。&lt;/p&gt;

&lt;p&gt;如果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。
从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。
招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。
真正要花代价的是创建异常。&lt;/p&gt;

&lt;p&gt;幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。&lt;/p&gt;

&lt;p&gt;异常是为异常的情况而设计的，使用时也应该牢记这一原则。&lt;/p&gt;
</content>
 </entry>
 
 
</feed>