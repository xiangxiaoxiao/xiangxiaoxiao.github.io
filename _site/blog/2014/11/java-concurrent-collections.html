<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta name="baidu-site-verification" content="HvuxptDcq6" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="java同步容器与并发容器 - Lippi-浮生志 - Lippi.OuYang(ouyanglip@gmail.com)">
    <title>
      java同步容器与并发容器 - Lippi-浮生志
    </title>
    <!-- Bootstrap Core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS 
    <link href="/css/blog.css" rel="stylesheet">-->
    <!-- index css -->
    <link href="/css/index.css" rel="stylesheet">
	<!-- pagments CSS-->
	<link href="/css/pygments.css" rel="stylesheet">
        <!-- jQuery Version 1.11.0 -->
    <script src="/js/jquery-1.11.0.js"> </script>
    <!-- Bootstrap Core JavaScript -->
    <script src="/js/bootstrap.min.js"></script>
   <!-- 回到顶部js-->
    <script src="/js/index.js"></script>

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?085fc257cb1e774f7764a2cf527c393d";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

	<script>
    (function(){
     var bp = document.createElement('script');
	 bp.src = '//push.zhanzhang.baidu.com/push.js';
	 var s = document.getElementsByTagName("script")[0];
	 s.parentNode.insertBefore(bp, s);
	 })();
	</script>

  </head>
  
  <body>
    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="sr-only">
              Toggle navigation
            </span>
            <span class="icon-bar">
            </span>
            <span class="icon-bar">
            </span>
            <span class="icon-bar">
            </span>
          </button>
          <a class="navbar-brand" href="/index.html">
            Lippi-浮生志
          </a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav">
            <li>
              <a href="/categories.html">
                分 类
              </a>
            </li>
            <li>
              <a href="/tags.html">
                标 签
              </a>
            </li>
            <li>
              <a href="/archives.html">
                归 档
              </a>
            </li>
            <li>
              <a href="/faqs.html">
                备 忘
              </a>
            </li>
            <li>
              <a href="/about.html">
                关 于
              </a>
            </li>
          </ul> 
        </div>
        <!-- /.navbar-collapse -->
      </div>
      <!-- /.container -->
    </nav>
    <!-- Page Content -->
    <div class="container">
      <div class="row">
        <!-- Blog Entries Column -->
        <div class="col-md-8">
          <!-- Blog Post -->
<!-- Title -->
<div class="row">
  <div class="post-area post">

 	<div class="post-list-body">
        	<div class="all-posts" post-cate="All">
 		<header>
		<h1>
		  java同步容器与并发容器
		  <div class="post-date"><a href="https://github.com/LippiOuYang/LippiOuYang.github.io/edit/master/_posts/2014-11-08-java-concurrent-collections.md" target="_blank">纠错</a>&nbsp;&nbsp;
			<span class="glyphicon glyphicon-time"></span>
			08 Nov 2014
		  </div>
		</h1>
 		</header>
		<!-- Author -->
		<hr>
		 <article>
		<p>在编程的时候经常会用到容器，当容器被多线程读取的时候我们就要考虑线程安全的问题，哪些容器是线程是线程安全的，容器的哪些操作又是线程安全的，这些安全机制是怎么实现的，本文将一一介绍。</p>

<hr />
<p># 同步容器 #</p>

<p><strong>1. vector和hashtable</strong></p>

<p>jdk很早的时候就支持vector和hashtable，vector内部是一个数组，它的同步是在所有对元素的存取操作上进行synchronized的，也就是说每个时刻只能由一个线程可以访问容器的元素，这种线程安全是比较粗粒度的。
比如你在进行vector容器的迭代操作(iterator.next())时再调用vector.put(object o)时会抛出ConcurrentModificationException</p>

<hr />

<p>hashtable的内部实现：
  首先回顾下hashmap的实现，我们初始化一个hashmap时有两个参数inital capacity用来定义hashmap的初始化buckets数，reload factor加载因子，初始值为0.75，当hashmap中entry的数量超过这个比值时hashmap就会进行扩容，然后所有的entry进行rehash，这两个初始参数都必须选择合适的值，如果inital capacity选择太小，由于容器是开链的，会给查找元素增加额外的负担，reload factor不能选的过大，否则插入元素时出现碰撞的几率会增大。
hashtable就是在hashmap的基础上对所有元素的访问和插入操作用synchronized关键字同步，同样，在对容器元素迭代访问时进行插入操作会抛出ConcurrentModificationException。</p>

<hr />
<p><strong>2. collections.synchronizedXXX工厂方法创建</strong></p>

<p>collections.synchronizedXXX是在jdk2引入的，和vector,hashtable一样，都是在整个容器上进行同步操作。
举个例子，下面这个是jdk7种collections.synchronizedMap的实现，这里只列出部分代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private static class SynchronizedMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Serializable {
    private static final long serialVersionUID = 1978198479659022715L;

    private final Map&lt;K,V&gt; m;     // Backing Map
    final Object      mutex;        // Object on which to synchronize

    SynchronizedMap(Map&lt;K,V&gt; m) {
        this.m = Objects.requireNonNull(m);
        mutex = this;
    }

    SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) {
        this.m = m;
        this.mutex = mutex;
    }
	//所有的操作都是在同一个监视器上进行同步
    public int size() {
        synchronized (mutex) {return m.size();}
    }
    public boolean isEmpty() {
        synchronized (mutex) {return m.isEmpty();}
    }
    public boolean containsKey(Object key) {
        synchronized (mutex) {return m.containsKey(key);}
    }
    public boolean containsValue(Object value) {
        synchronized (mutex) {return m.containsValue(value);}
    }
    public V get(Object key) {
        synchronized (mutex) {return m.get(key);}
    }

    public V put(K key, V value) {
        synchronized (mutex) {return m.put(key, value);}
    }
    public V remove(Object key) {
        synchronized (mutex) {return m.remove(key);}
    }
    public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
        synchronized (mutex) {m.putAll(map);}
    }
    public void clear() {
        synchronized (mutex) {m.clear();}
    }
</code></pre>
</div>

<hr />
<p># 并发容器 #
JDK5中添加了新的concurrent包，其中包含了很多并发容器，这些容器针对多线程环境进行了优化，大大提高了容器类在并发环境下的执行效率。
下面所有的代码都是来源于jdk7。</p>

<h2 id="copyonwritearraylist">CopyOnWriteArrayList</h2>

<p>CopyOnWriteArrayList类是一个线程安全的List接口的实现，在该类的内部进行元素的<strong>写操作时，底层的数组将被完整的复制</strong>，这对于读操作远远多于写操作的应用非常适合。在CopyOnWriteArrayList上进行操作时，<strong>读操作不需要加锁，而写操作类实现中对其进行了加锁</strong>。</p>

<p>底层实现如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class CopyOnWriteArrayList&lt;E&gt;  
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {  
  
/** The lock protecting all mutators */
final transient ReentrantLock lock = new ReentrantLock();

/** The array, accessed only via getArray/setArray. */
private transient volatile Object[] array;
 final Object[] getArray() {
    return array;
}

  ...  
}  
</code></pre>
</div>

<p>读写操作：</p>

<div class="highlighter-rouge"><pre class="highlight"><code> @SuppressWarnings("unchecked")
private E get(Object[] a, int index) {
    return (E) a[index];
}

public E get(int index) {
    return get(getArray(), index);
}
//使用ReentrantLock加锁保护
 public E set(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        E oldValue = get(elements, index);

        if (oldValue != element) {
            int len = elements.length;
//创建一个新的数组，复制原来的元素
            Object[] newElements = Arrays.copyOf(elements, len);
//set的元素
            newElements[index] = element;
            setArray(newElements);
        } else {
// 替换底层的数组
            setArray(elements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
</code></pre>
</div>

<p>特别注意：在CopyOnWriteArrayList上获得的Iterator是不能进行set和remove操作的，否则会抛出ConcurrentModificationException。</p>

<hr />
<p>## BlockingQueue ##
BlockingQueue接口定义了一种阻塞的FIFO queue，基于生产者消费者模式，每一个BlockingQueue都有一个容量，让容量满时往BlockingQueue中添加数据时会造成阻塞，当容量为空时取元素操作会阻塞。</p>

<p>ArrayBlockingQueue是对BlockingQueue的一个数组实现，它使用一把全局的锁并行对queue的读写操作，同时使用两个Condition阻塞容量为空时的取操作和容量满时的写操作。
底层实现：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  
  
// 使用循环数组来实现queue，初始时takeIndex和putIndex均为0  
private final E[] items;  
private transient int takeIndex;  
private transient int putIndex;  
private int count;  
  
// 用于并发的锁和条件  
private final ReentrantLock lock;  
private final Condition notEmpty;  
private final Condition notFull;  
  
/** 
 * 循环数组 
 * Circularly increment i. 
 */  
final int inc(int i) {  
    return (++i == items.length)? 0 : i;  
}  
  
public ArrayBlockingQueue(int capacity, boolean fair) {  
    if (capacity &lt;= 0)  
        throw new IllegalArgumentException();  
    this.items = (E[]) new Object[capacity];  
    // 分配锁及该锁上的condition  
    lock = new ReentrantLock(fair);  
    notEmpty = lock.newCondition();  
    notFull =  lock.newCondition();  
}  
  
  ...  
}  
</code></pre>
</div>

<p>ArrayBlockingQueue的取操作：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  
  
private E extract() {  
    final E[] items = this.items;  
    E x = items[takeIndex];  
    items[takeIndex] = null;  
    takeIndex = inc(takeIndex);  
    --count;  
   // 激发notFull条件  
    notFull.signal();  
    return x;  
}  
  
 /** 
 * condition的await的语义如下： 
 *　与condition相关的锁以原子方式释放，并禁用该线程 
 *　方法返回时，线程必须获得与该condition相关的锁 
 */  
public E take() throws InterruptedException {  
    final ReentrantLock lock = this.lock;  
    lock.lockInterruptibly();  
    try {  
        try {  
              // 等待notEmpty的条件  
            while (count == 0)  
                notEmpty.await();  
        } catch (InterruptedException ie) {  
		// 唤醒其他正在等待的线程  
            notEmpty.signal(); 
  
            throw ie;  
        }  
        E x = extract();  
        return x;  
    } finally {  
        lock.unlock();  
    }  
}  
  
  ...  
}  
</code></pre>
</div>

<p>ArrayBlockingQueue的写操作：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  
  
private void insert(E x) {  
    items[putIndex] = x;  
    putIndex = inc(putIndex);  
    ++count;  
    notEmpty.signal();  
}  
  
public void put(E o) throws InterruptedException {  
    if (o == null) throw new NullPointerException();  
    final E[] items = this.items;  
    final ReentrantLock lock = this.lock;  
    lock.lockInterruptibly();  
    try {  
        try {  
              // 等待notFull条件  
       while (count == items.length)  
                notFull.await();  
        } catch (InterruptedException ie) {  
    // 唤醒其他正在等待的线程      
			  notFull.signal(); 

            throw ie;  
        }  
        insert(o);  
    } finally {  
        lock.unlock();  
    }  
}  
  
  ...  
}  
</code></pre>
</div>

<p>注意：ArrayBlockingQueue<strong>在读写操作上都需要锁住整个容器</strong>，因此吞吐量与一般的实现是相似的，适合于实现“生产者消费者”模式。</p>

<h2 id="linkedblockingqueue">LinkedBlockingQueue</h2>

<p>LinkedBlockingQueue是BlockingQueue的一种使用Link List的实现，它<strong>对头和尾（取和添加操作）采用两把不同的锁</strong>，相对于ArrayBlockingQueue提高了吞吐量。它也是一种阻塞型的容器，适合于实现“消费者生产者”模式。</p>

<p>LinkedBlockingQueue底层的定义如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  
  
static class Node&lt;E&gt; {  
    /** The item, volatile to ensure barrier separating write and read */  

    volatile E item;  
    Node&lt;E&gt; next;  
    Node(E x) { item = x; }  
}  
  
// 支持原子操作  
private final AtomicInteger count = new AtomicInteger(0);  
  
// 链表的头和尾  
private transient Node&lt;E&gt; head;  
private transient Node&lt;E&gt; last;  
  
// 针对取和添加操作的两把锁及其上的条件  
private final ReentrantLock takeLock = new ReentrantLock();  
private final Condition notEmpty = takeLock.newCondition();  

private final ReentrantLock putLock = new ReentrantLock();  
private final Condition notFull = putLock.newCondition();  
  
   ...  
} 
</code></pre>
</div>

<p>LinkedBlockingQueue的添加操作：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  
  
private void insert(E x) {  
    last = last.next = new Node&lt;E&gt;(x);  
}  
  
/** 
 * signal方法在被调用时，当前线程必须拥有该condition相关的锁! 
 * Signal a waiting take. Called only from put/offer (which do not otherwise ordinarily lock takeLock.) 
 */  
private void signalNotEmpty() {  
    final ReentrantLock takeLock = this.takeLock;  
    takeLock.lock();  
    try {  
        notEmpty.signal();  
    } finally {  
        takeLock.unlock();  
    }  
}  
  
public void put(E o) throws InterruptedException {  
    if (o == null) throw new NullPointerException();  
    int c = -1;  
    final ReentrantLock putLock = this.putLock;  
    final AtomicInteger count = this.count;  
    // 使用putLock  
    putLock.lockInterruptibly();  
    try {  
        try {  
              // 当容量已满时，等待notFull条件  
        while (count.get() == capacity)  
                notFull.await();  
        } catch (InterruptedException ie) {  
            notFull.signal(); // propagate to a non-interrupted thread  
            throw ie;  
        }  
        insert(o);  
        // 取出当前值，并将原数据增加1  
        c = count.getAndIncrement();  
        // 容量不满，再次激活notFull上等待的put线程  
    if (c + 1 &lt; capacity)  
            notFull.signal();  
    } finally {  
        putLock.unlock();  
    }  
    // 必须先释放putLock再在notEmpty上signal，否则会造成死锁  
 if (c == 0)  
        signalNotEmpty();  
}  
  
  ...  
}   
</code></pre>
</div>

<p>LinkedBlockingQueue的取操作：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  
  
private E extract() {  
    Node&lt;E&gt; first = head.next;  
    head = first;  
    E x = first.item;  
    first.item = null;  
    return x;  
}  
  
private void signalNotFull() {  
    final ReentrantLock putLock = this.putLock;  
    putLock.lock();  
    try {  
        notFull.signal();  
    } finally {  
        putLock.unlock();  
    }  
}  
  
public E take() throws InterruptedException {  
    E x;  
    int c = -1;  
    final AtomicInteger count = this.count;  
    final ReentrantLock takeLock = this.takeLock;  
    // 使用takeLock  
    takeLock.lockInterruptibly();  
    try {  
        try {  
              // 若容量为空，等待notEmpty  
            while (count.get() == 0)  
                notEmpty.await();  
        } catch (InterruptedException ie) {  
            notEmpty.signal(); // propagate to a non-interrupted thread  
            throw ie;  
        }  
  
        x = extract();  
        c = count.getAndDecrement();  
        // 再次激活notEmpty  
        if (c &gt; 1)  
            notEmpty.signal();  
    } finally {  
        takeLock.unlock();  
    }  
    // take执行之前容量已满，则激活notFull  
    if (c == capacity)  
        signalNotFull();  
    return x;  
}  
  
  ...  
}  
</code></pre>
</div>

<hr />

<h2 id="concurrenthashmap">ConcurrentHashMap</h2>

<p>ConcurrentHashMap是Map的一种并发实现，在该类中<strong>元素的read操作都是无锁了，而write操作需要被同步</strong>。这非常适合于读操作远大于写操作的情况。在实现过程中，ConcurrentHashMap将所有元素分成了若干个segment，每个segment是独立的，在一个segment上加锁并不影响其他segment的操作。segment本身是一个hashtable，对于一个加入ConcurrentHashMap的&lt;key, value&gt;对，key的hash值中的高位被用来索引segment，而低位用于segment中的索引。</p>

<p>虽然读操作不阻塞，但是读到的值可能不是最新的值，因为可能有其他线程又更新了元素，Iterator操作也是一样，包括size(),isEmpty(),containValue()返回的结果可能是错误的，而且每个时刻只有一个线程可以访问迭代器。</p>

<p>segment是ConcurrentHashMap存储元素的基本段，它本身是一个hashtable的实现，read操作时无锁的，write需要同步，定义如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;  
    implements ConcurrentMap&lt;K, V&gt;, Serializable {  
  
  
/** 
 *  key, hash, next都是不可改的 
*  value值可被重写 
*/  
static final class HashEntry&lt;K,V&gt; {  
    final K key;  
    final int hash;  
    volatile V value;  
    final HashEntry&lt;K,V&gt; next;  
  
    ...  
 }  
  
   static final class Segment&lt;K,V&gt; extends ReentrantLock   implements Serializable {  
  
    transient volatile int count;  
    transient volatile HashEntry[] table;  
    // 当segment中元素个数达到threshold时，需要rehash  
    transient int threshold;  
}  
  
  ...  
}
</code></pre>
</div>

<p>segment的read操作：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  
  
  HashEntry&lt;K,V&gt; getFirst(int hash) {  
      HashEntry[] tab = table;  
      return (HashEntry&lt;K,V&gt;) tab[hash &amp; (tab.length - 1)];  
  }  
  
 V get(Object key, int hash) { // 该操作是无锁的  
      if (count != 0) { // read-volatile  
          HashEntry&lt;K,V&gt; e = getFirst(hash);  
          while (e != null) {  
              if (e.hash == hash &amp;&amp; key.equals(e.key)) {  
                  V v = e.value;  
                  if (v != null)  
                      return v;  
					// recheck  
                  return readValueUnderLock(e);
 
              }  
              e = e.next;  
          }  
      }  
      return null;  
  }  
  
...  
} 
</code></pre>
</div>

<p>由于HashEntry当中的key和next都是final的，所以segment之上的操作不可能影响HashEntry列表之间相对的顺序，而value是可变的，当第一次读值失败时，尝试加锁读。
  segment的replace操作：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  
  
   /** 
   * replace操作是就地替换，HashEntry的value是非final的 
   */  
    boolean replace(K key, int hash, V oldValue, V newValue) {  
        lock();  // replace操作是同步的  
    try {  
            // 得到该hash值对应的entry列表  
       HashEntry&lt;K,V&gt; e = getFirst(hash);  
       while (e != null &amp;&amp; (e.hash != hash || !				key.equals(e.key)))  
             e = e.next;  
 
            boolean replaced = false;  
            if (e != null &amp;&amp; oldValue.equals(e.value)) { 	// 替换  
         		 replaced = true;  
                 e.value = newValue;  
            }  
            return replaced;  
        } finally {  
            unlock();  
        }  
    }  
  
  ...  
}  
</code></pre>
</div>

<p>segment的remove操作一种copy on write 的方法，保留被删元素之后的列表，copy被删元素之前的hashEntry：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  
  
    V remove(Object key, int hash, Object value) {  
        lock();  
        try {  
            int c = count - 1;  
            HashEntry[] tab = table;  
            int index = hash &amp; (tab.length - 1);  
            HashEntry&lt;K,V&gt; first = (HashEntry&lt;K,V&gt;)tab[index];  
            HashEntry&lt;K,V&gt; e = first;  
            while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))  
                e = e.next;  
  
            V oldValue = null;  
            if (e != null) {  
                V v = e.value;  
                if (value == null || value.equals(v)) { // copy on write  
                    oldValue = v;  
                    ++modCount;  
                    // e之后的列表可以保留，只需要重新创建e之前的HashEntry即可  
             HashEntry&lt;K,V&gt; newFirst = e.next;  
                    // copy on write e之前的HashEntry  
                    for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)  
                        newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash,    
                                                      newFirst, p.value);  
                    tab[index] = newFirst;  
                    count = c; // write-volatile  
                }  
            }  
            return oldValue;  
        } finally {  
            unlock();  
        }  
    }  
  
  ...  
}  
</code></pre>
</div>

<p>segment的rehash操作实现比较特别，为了保证rehash过程中copy的元素尽可能少，segment在rehash时Entry入口的个数是以2的倍数增长，这可以保证一个entry在rehash之后要么在原来的列表中，要么在下一个列表中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  
  
    void rehash() {  
        // 局部变量引用table  
        HashEntry[] oldTable = table;              
        int oldCapacity = oldTable.length;  
        if (oldCapacity &gt;= MAXIMUM_CAPACITY)  
            return;  
  
        // 右移1位相当于乘以2  
        HashEntry[] newTable = new HashEntry[oldCapacity &lt;&lt; 1];  
        threshold = (int)(newTable.length * loadFactor);  
        int sizeMask = newTable.length - 1;  
        for (int i = 0; i &lt; oldCapacity ; i++) {  
            // 第i个entry列表  
       HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;)oldTable[i];  
  
            if (e != null) {  
                HashEntry&lt;K,V&gt; next = e.next;  
                // 在新table上的索引  
                int idx = e.hash &amp; sizeMask;  
  
                if (next == null)  
                    newTable[idx] = e;  
                else {  
                    // 寻找该entry列表末端，rehash之后idx相同的元素  
                    // 这些元素不需要被copy  
                    HashEntry&lt;K,V&gt; lastRun = e;  
                    int lastIdx = idx;  
                    for (HashEntry&lt;K,V&gt; last = next;  
                         last != null;  
                         last = last.next) {  
                        int k = last.hash &amp; sizeMask;  
                        if (k != lastIdx) {  
                            lastIdx = k;  
                            lastRun = last;  
                        }  
                    }  
                    // 将lastRun之后的整个列表挂到新位置上  
                    newTable[lastIdx] = lastRun;  
  
                    // Clone all remaining nodes  
                    for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {  
                        int k = p.hash &amp; sizeMask;  
                        HashEntry&lt;K,V&gt; n = (HashEntry&lt;K,V&gt;)newTable[k];  
                        newTable[k] = new HashEntry&lt;K,V&gt;(p.key, p.hash,  
                                                         n, p.value);  
                    }  
                }  
            }  
        }  
        table = newTable;  
    }  
  
  ...  
}
</code></pre>
</div>

<p>ConcurrentHashMap在Segment的基础上，通过首先将&lt;key, value&gt;对hash到一个segment，再由segment实现对entry的管理。</p>

<p>ConcurrentHashMap的get实现：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;  
    implements ConcurrentMap&lt;K, V&gt;, Serializable {  
  
final Segment&lt;K,V&gt; segmentFor(int hash) {  
    return (Segment&lt;K,V&gt;) segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];  
}  
  
public V get(Object key) {  
    int hash = hash(key); // throws NullPointerException if key null  
    return segmentFor(hash).get(key, hash);  
}  
  
  ...  
}  
</code></pre>
</div>

<p>ConcurrentHashMap的put和get方法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;  
    implements ConcurrentMap&lt;K, V&gt;, Serializable {  
  
public V put(K key, V value) {  
    if (value == null)  
        throw new NullPointerException();  
    int hash = hash(key);  
    return segmentFor(hash).put(key, hash, value, false);  
}  
  
public V remove(Object key) {  
    int hash = hash(key);  
    return segmentFor(hash).remove(key, hash, null);  
}  
</code></pre>
</div>

<p>…<br />
}</p>

<hr />

<h2 id="concurrentlinkedqueue">ConcurrentLinkedQueue</h2>

<p>ConcurrentLinkedQueue充分使用了atomic包的实现<strong>打造了一个无锁并发线程安全的队列</strong>。对比锁机制的实现，个人认为使用无锁机制的难点在于要充分考虑线程间的协调。简单的说就是多个线程对内部数据结构进行访问时，如果其中一个线程执行的中途因为一些原因出现故障，其他的线程能够检测并帮助完成剩下的操作。这就需要把对数据结构的操作过程精细的划分成多个状态或阶段，考虑每个阶段或状态多线程访问会出现的情况。上述的难点在此次分析的并发Queue的实现中有很好的说明。</p>

<p>对于多线程同时访问容器元素的情况，concurrentLinkedQueue是一个很好的选择，因为所有的操作都是非阻塞的，所以它的迭代操作返回的结果并不是最新的，不会出现concurrentmodificationException。</p>

<p>而且不像很多其他容器，ConcurrentLinkedQueue的size()操作不是常量时间，返回的结果也不一定是准确的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements Queue&lt;E&gt;, java.io.Serializable {  
private static final long serialVersionUID = 196745693267521676L;  
  
private static class Node&lt;E&gt; {  
    private volatile E item;  
    private volatile Node&lt;E&gt; next;  
  
    private static final  
        AtomicReferenceFieldUpdater&lt;Node, Node&gt;  
        nextUpdater =  
        AtomicReferenceFieldUpdater.newUpdater  
        (Node.class, Node.class, "next");  
    private static final  
        AtomicReferenceFieldUpdater&lt;Node, Object&gt;  
        itemUpdater =  
        AtomicReferenceFieldUpdater.newUpdater  
        (Node.class, Object.class, "item");  
  
    Node(E x) { item = x; }  
  
    Node(E x, Node&lt;E&gt; n) { item = x; next = n; }  
  
    E getItem() {  
        return item;  
    }  
  
    boolean casItem(E cmp, E val) {  
        return itemUpdater.compareAndSet(this, cmp, val);  
    }  
  
    void setItem(E val) {  
        itemUpdater.set(this, val);  
    }  
  
    Node&lt;E&gt; getNext() {  
        return next;  
    }  
  
    boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {  
        return nextUpdater.compareAndSet(this, cmp, val);  
    }  
  
    void setNext(Node&lt;E&gt; val) {  
        nextUpdater.set(this, val);  
    }  
  
}  
  
private static final  
    AtomicReferenceFieldUpdater&lt;ConcurrentLinkedQueue, Node&gt;  
    tailUpdater =  
    AtomicReferenceFieldUpdater.newUpdater  
    (ConcurrentLinkedQueue.class, Node.class, "tail");  
private static final  
    AtomicReferenceFieldUpdater&lt;ConcurrentLinkedQueue, Node&gt;  
    headUpdater =  
    AtomicReferenceFieldUpdater.newUpdater  
    (ConcurrentLinkedQueue.class,  Node.class, "head");  
  
private boolean casTail(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {  
    return tailUpdater.compareAndSet(this, cmp, val);  
}  
  
private boolean casHead(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {  
    return headUpdater.compareAndSet(this, cmp, val);  
}  
  
private transient volatile Node&lt;E&gt; head = new Node&lt;E&gt;(null, null);  
  
private transient volatile Node&lt;E&gt; tail = head;  
...  
}  
</code></pre>
</div>

<p>先看看其内部数据结构Node的实现。由于使用了原子字段更新器<code class="highlighter-rouge">AtomicReferenceFieldUpdater&lt;T,V&gt;</code>（其中T表示持有字段的类的类型，V表示字段的类型），所以其对应的需要更新的字段要使用volatile进行声明。其<code class="highlighter-rouge">newUpdater(Class&lt;U&gt; tclass, Class&lt;W&gt; vclass, String fieldName)</code>方法实例化一个指定字段的更新器，参数分别表示：持有需要更新字段的类，字段的类，要更新的字段的名称。Node的内部变量item，next分别有对应自己的字段更新器，并且包含了对其原子性操作的方法<code class="highlighter-rouge">compareAndSet(T obj, V expect, V update)</code>，其中T是持有被设置字段的对象，后两者分别是期望值和新值。</p>

<p>对于ConcurrentLinkedQueue自身也有<strong>两个volatile的线程共享变量：head，tail分别对应队列的头指针和尾指针</strong>。要保证这个队列的线程安全就是保证对这两个Node的引用的访问（更新，查看）的原子性和可见性，由于volatile本身能够保证可见性，所以就是对其修改的原子性要被保证：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public boolean offer(E e) {  
if (e == null) throw new NullPointerException();  
Node&lt;E&gt; n = new Node&lt;E&gt;(e, null);  
for (;;) {  
    Node&lt;E&gt; t = tail;  
    Node&lt;E&gt; s = t.getNext();  
    if (t == tail) { //-----------------------------a  
        if (s == null) { //-------------------------b  
            if (t.casNext(s, n)) { //---------------c  
                casTail(t, n); //-------------------d  
                return true;  
            }  
        } else {  
            casTail(t, s); //-----------------------e  
        }  
    }  
}   }  
</code></pre>
</div>

<p>offer()方法都很熟悉了，就是入队的操作。涉及到改变尾指针的操作，所以要看这个方法实现是否保证了原子性。CAS操作配合循环是原子性操作的保证，这里也不例外。此方法的循环内首先获得尾指针和其next指向的对象，由于tail和Node的next均是volatile的，所以保证了获得的分别都是最新的值。</p>

<hr />

<ul>
  <li>
    <p>代码a：<code class="highlighter-rouge">t==tail</code>是最上层的协调，如果其他线程改变了tail的引用，则说明现在获得不是最新的尾指针需要重新循环获得最新的值。</p>
  </li>
  <li>
    <p>代码b：<code class="highlighter-rouge">s==null</code>的判断。静止状态下tail的next一定是指向null的，但是多线程下的另一个状态就是中间态：tail的指向没有改变，但是其next已经指向新的结点，即完成tail引用改变前的状态，这时候<code class="highlighter-rouge">s!=null</code>。这里就是协调的典型应用，直接进入代码e去协调参与中间态的线程去完成最后的更新，然后重新循环获得新的tail开始自己的新一次的入队尝试。另外值得注意的是a,b之间，其他的线程可能会改变tail的指向，使得协调的操作失败。从这个步骤可以看到无锁实现的复杂性。</p>
  </li>
  <li>
    <p>代码c：<code class="highlighter-rouge">t.casNext(s, n)</code>是入队的第一步，因为入队需要两步：更新Node的next，改变tail的指向。代码c之前可能发生tail引用指向的改变或者进入更新的中间态，这两种情况均会使得t指向的元素的next属性被原子的改变，不再指向null。这时代码c操作失败，重新进入循环。</p>
  </li>
  <li>
    <p>代码d：这是完成更新的最后一步了，就是更新tail的指向，最有意思的协调在这儿又有了体现。从代码看<code class="highlighter-rouge">casTail(t, n)</code>不管是否成功都会接着返回true标志着更新的成功。首先如果成功则表明本线程完成了两步的更新，返回true是理所当然的；如果 <code class="highlighter-rouge">casTail(t, n)</code>不成功呢？要清楚的是完成代码c则代表着更新进入了中间态，代码d不成功则是tail的指向被其他线程改变。意味着对于其他的线程而言：它们得到的是中间态的更新，<code class="highlighter-rouge">s!=null</code>，进入代码e帮助本线程执行最后一步并且先于本线程成功。这样本线程虽然代码d失败了，但是是由于别的线程的协助先完成了，所以返回true也就理所当然了。</p>
  </li>
</ul>

<hr />

<p>通过分析这个入队的操作，可以清晰的看到无锁实现的每个步骤和状态下多线程之间的协调和工作。理解了入队的整个过程，出队的操作<code class="highlighter-rouge">poll()</code>的实现也就变得简单了。基本上是大同小异的，无非就是同时牵涉到了head和tail的状态，在改变head的同时照顾到tail的协调，在此不多赘述。下面介绍一下其无锁下的查看访问，其内部不单单是查看更包含了线程间的协调，这是无锁实现的一个特点。不管是<code class="highlighter-rouge">contains()，size()</code>还是isEmpty()，只要获得了head后面第一个最新的Node就可以很轻松的实现，毕竟Node的<code class="highlighter-rouge">getNext()和getItem()</code>返回的都是对应的最新值。所以先看看这些方法内部的first()如何获得最新的第一个Node：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Node&lt;E&gt; first() {  
for (;;) {  
    Node&lt;E&gt; h = head;  
    Node&lt;E&gt; t = tail;  
    Node&lt;E&gt; first = h.getNext();  
    if (h == head) { //----------------  ---------a  
        if (h == t) { //--------------------------b  
            if (first ==null) --------------------c  
                return null;  
            else  
                casTail(t, first); //-------------d  
        } else {  
            if (first.getItem() != null) //-------e  
                return first;  
            else
			 // remove deleted node and continue  
                casHead(h, first); //-------------f  
        }  
    }  
}   }  
</code></pre>
</div>

<p>此方法在尝试获得最新的第一个非head结点的时候，在不同的阶段同样在协调着head和tail的更新任务，让人感觉无锁的世界没有纯粹的工作，呵呵。 
- 代码a：还是最上层的协调，head指向没改变的情况下才继续下面的操作。这时侯head只可能是静止的，因为<code class="highlighter-rouge">poll()</code>出队操作的步骤是反着的：首先更新head的指向进入中间态，然后更新原head的next的item为null。</p>

<ul>
  <li>
    <p>代码b：之所以<code class="highlighter-rouge">h==t</code>的情况独立于其他的情况(在出队<code class="highlighter-rouge">poll()</code>方法中同样)，主要是因为<code class="highlighter-rouge">first!=null</code>时可能对应着某一个更新的中间态，而产生中间态的的必要条件就是代码b成立。如果<code class="highlighter-rouge">h==t</code>则表示当前线程获得的首尾指针指向同一个结点，当然代码b执行之后可能其他线程会进行head或者tail的更新。</p>
  </li>
  <li>
    <p>代码c：<code class="highlighter-rouge">first==null</code>表明tail并没有进入更新的中间态而是处于静止状态，并且由于tail指向的是head的指向，所以返回null是唯一的选择。但是这美好的一切都是建立在代码b和代码c之间没有其他的线程更新tail。一旦有其他的线程执行了入队的操作并至少进入中间态的话，<code class="highlighter-rouge">h==t和first==null</code>都遗憾的成立，这就造成了取得幻象值，而实际上h.getNext()已经不再为null。个人认为代码c改成<code class="highlighter-rouge">if((first = h.getNext()) == null)</code>更能提高命中率。</p>
  </li>
  <li>
    <p>代码d：只要`first!=null，本线程则去尝试协调其他的线程先完成tail的更新，等待循环再次获取最新的head和tail。</p>
  </li>
  <li>
    <p>代码e：此处first一定不为null，tail更新与否不影响first的item的获取，但是head的更新会有影响。如果head正在被另一个线程更新并进入中间态，既是poll()内的<code class="highlighter-rouge">else if (casHead(h, first))</code> 成功，但是并没有执行first.setItem(null)之前。此时代码e是满足的，返回的也是当前的first的，但是随后head全部更新成功则first的item为null。所以此处返回的first的item并不一定是<code class="highlighter-rouge">item!=null</code>的结点，在使用此方法获得的结点的item时一定要再次的进行判断，这点在contains(…)等方法内都有体现。</p>
  </li>
  <li>
    <p>代码f：如果first的<code class="highlighter-rouge">item==null</code>，则更新head的指向。直观上看似乎多余，因为出队的操作是先更新head的指向再更新item为null的。但是另一个方法remove(…)则仅仅更新item的值而不改变head的指向，所以针对这样的多线程调用，代码f变得非常的必需了。</p>
  </li>
</ul>

<hr />
<p>这样通过这两个方法的分析可以推及对ConcurrentLinkedQueue共享变量的其他操作的实现，这样的无锁的实现印象最深的就是要考虑线程间的协调。不像锁机制的实现虽然牺牲了一定的性能，但是至少操作这些非线程安全的共享变量时不用过多的考虑其他线程的操作。</p>

		  </article>
		<hr>
	<br/>
        <p>
          本作品由 <a href="mailto:ouyanglip@gmail.com">Lippi.OuYang</a> 创作，采用
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="查看协议详细信息" target="_blank">CC BY-NC-SA 3.0 许可协议</a>
          进行许可。
        </p>
	<div style="margin-top:10px;margin-bottom:10px">
	  
	  <span class="next">
	    上篇：
	    <a href="/blog/2014/11/how-to-evaluate-the-hackers-and-painters.html">
	      如何评价『黑客与画家』
	    </a>
	  </span>
	   
	  
	  <span class="prev">
	    下篇：
	    <a href="/blog/2014/11/java-inner-class.html">
	      java中内部类
	    </a>
	  </span>
	  
	</div>
	</div>
	
        
	<div post-cate="java">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2015/08/volley-source-code.html" class="post-list-item">
                    <h2>Volley源码分析</h2>
                    <span class="date">Aug 27, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/07/hibernate-cache-guide.html" class="post-list-item">
                    <h2>Hibernate缓存配置笔记</h2>
                    <span class="date">Jul 24, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/06/java-lambda-expression.html" class="post-list-item">
                    <h2>Java Lambda简明教程</h2>
                    <span class="date">Jun 3, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/04/java-virtual-mechine.html" class="post-list-item">
                    <h2>Java虚拟机简介</h2>
                    <span class="date">Apr 18, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/04/java-code-opt-one.html" class="post-list-item">
                    <h2>优化java代码建议(1)</h2>
                    <span class="date">Apr 12, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/02/cache.html" class="post-list-item">
                    <h2>谈谈缓存和基本的缓存算法</h2>
                    <span class="date">Feb 4, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/12/improve-webServer-performance.html" class="post-list-item">
                    <h2>谈谈如何提高web服务器并发性能</h2>
                    <span class="date">Dec 5, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/11/java-inner-class.html" class="post-list-item">
                    <h2>java中内部类</h2>
                    <span class="date">Nov 14, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/11/java-concurrent-collections.html" class="post-list-item">
                    <h2>java同步容器与并发容器</h2>
                    <span class="date">Nov 8, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/09/returning-null.html" class="post-list-item">
                    <h2>关于返回 Null 值的问题</h2>
                    <span class="date">Sep 18, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/08/why-jdk-string-is-final.html" class="post-list-item">
                    <h2>为什么 jdk 中把 String 类设计成 final</h2>
                    <span class="date">Aug 29, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/08/78-golden-rules-of-the-java-programming.html" class="post-list-item">
                    <h2>java编程的78条黄金法则</h2>
                    <span class="date">Aug 16, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/08/java-multithread.html" class="post-list-item">
                    <h2>java并发和多线程</h2>
                    <span class="date">Aug 2, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/07/android-UI-Thread.html" class="post-list-item">
                    <h2>Android UI线程和子线程、Service通信</h2>
                    <span class="date">Jul 19, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/07/android-networkOnMainThreadException.html" class="post-list-item">
                    <h2>从android.os.NetworkOnMainThreadException引发的思考</h2>
                    <span class="date">Jul 18, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/06/26-methods-to-improve-java-performance.html" class="post-list-item">
                    <h2>Java编程Tips</h2>
                    <span class="date">Jun 18, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/06/15/in-the-rain.html" class="post-list-item">
                    <h2>在雨中</h2>
                    <span class="date">Jun 14, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="c">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2014/12/c-code-opt.html" class="post-list-item">
                    <h2>C代码优化小贴士</h2>
                    <span class="date">Dec 27, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/08/libevent.html" class="post-list-item">
                    <h2>处理并发之二：libevent的eventbuffer</h2>
                    <span class="date">Aug 24, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/08/linux-epoll.html" class="post-list-item">
                    <h2>处理并发之一：LINUX Epoll机制介绍</h2>
                    <span class="date">Aug 23, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/07/c-advaced-programming.html" class="post-list-item">
                    <h2>C语言高级编程指南</h2>
                    <span class="date">Jul 5, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="programming">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2015/03/install-texlive-in-ubuntu.html" class="post-list-item">
                    <h2>在Ubuntu下安装和编译LaTex</h2>
                    <span class="date">Mar 15, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/03/github-pages-blog.html" class="post-list-item">
                    <h2>利用github-pages建立个人博客</h2>
                    <span class="date">Mar 1, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/07/qualified-programmer-should-read-what-books.html" class="post-list-item">
                    <h2>一个合格的程序员应该读过哪些书</h2>
                    <span class="date">Jul 15, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/07/c-advaced-programming.html" class="post-list-item">
                    <h2>C语言高级编程指南</h2>
                    <span class="date">Jul 5, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="jekyll">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2014/07/use-jekyll-build-blog-on-github.html" class="post-list-item">
                    <h2>使用jekyll在Github上搭建博客</h2>
                    <span class="date">Jul 15, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/07/markdown-syntax.html" class="post-list-item">
                    <h2>Markdown 语法 (简体中文版)</h2>
                    <span class="date">Jul 11, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/07/markdown-basics.html" class="post-list-item">
                    <h2>markdown 快速入门</h2>
                    <span class="date">Jul 10, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="other">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2015/03/vim-plugins.html" class="post-list-item">
                    <h2>一些强大的Vim插件</h2>
                    <span class="date">Mar 20, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/03/install-texlive-in-ubuntu.html" class="post-list-item">
                    <h2>在Ubuntu下安装和编译LaTex</h2>
                    <span class="date">Mar 15, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/03/github-pages-blog.html" class="post-list-item">
                    <h2>利用github-pages建立个人博客</h2>
                    <span class="date">Mar 1, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/07/qualified-programmer-should-read-what-books.html" class="post-list-item">
                    <h2>一个合格的程序员应该读过哪些书</h2>
                    <span class="date">Jul 15, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="reprints">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2014/09/returning-null.html" class="post-list-item">
                    <h2>关于返回 Null 值的问题</h2>
                    <span class="date">Sep 18, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/08/why-jdk-string-is-final.html" class="post-list-item">
                    <h2>为什么 jdk 中把 String 类设计成 final</h2>
                    <span class="date">Aug 29, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/08/78-golden-rules-of-the-java-programming.html" class="post-list-item">
                    <h2>java编程的78条黄金法则</h2>
                    <span class="date">Aug 16, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/07/use-jekyll-build-blog-on-github.html" class="post-list-item">
                    <h2>使用jekyll在Github上搭建博客</h2>
                    <span class="date">Jul 15, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/07/qualified-programmer-should-read-what-books.html" class="post-list-item">
                    <h2>一个合格的程序员应该读过哪些书</h2>
                    <span class="date">Jul 15, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="Android">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2015/09/android-studio-plugins.html" class="post-list-item">
                    <h2>提高效率的Android Studio插件</h2>
                    <span class="date">Sep 9, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/10/android-opensource.html" class="post-list-item">
                    <h2>值得推荐的android开源框架</h2>
                    <span class="date">Oct 1, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="web">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2015/04/web-transmission-basis.html" class="post-list-item">
                    <h2>网络传输基础</h2>
                    <span class="date">Apr 16, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/11/web-server.html" class="post-list-item">
                    <h2>也谈如何构建高性能服务端程序</h2>
                    <span class="date">Nov 19, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/10/xmpp-analise.html" class="post-list-item">
                    <h2>XMPP协议分析-具体分析</h2>
                    <span class="date">Oct 31, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/10/androidDP-project.html" class="post-list-item">
                    <h2>Androidpn 消息推送总结</h2>
                    <span class="date">Oct 31, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/10/how-to-use-smack.html" class="post-list-item">
                    <h2>Smack开发手册</h2>
                    <span class="date">Oct 30, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/10/androidDP-introduction.html" class="post-list-item">
                    <h2>AndroidPN消息推送</h2>
                    <span class="date">Oct 30, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/10/xmpp.html" class="post-list-item">
                    <h2>XMPP协议分析-原理</h2>
                    <span class="date">Oct 28, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/10/jsp-jfreechart.html" class="post-list-item">
                    <h2>使用Jfreechart生成曲线显示到JSP中</h2>
                    <span class="date">Oct 22, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/10/how-http-works.html" class="post-list-item">
                    <h2>当我们打开网页时发生了什么</h2>
                    <span class="date">Oct 11, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="book">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2014/11/how-to-evaluate-the-hackers-and-painters.html" class="post-list-item">
                    <h2>如何评价『黑客与画家』</h2>
                    <span class="date">Nov 1, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="algorithm">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2014/12/skip-list.html" class="post-list-item">
                    <h2>skip list跳跃表实现</h2>
                    <span class="date">Dec 18, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/11/graph.html" class="post-list-item">
                    <h2>计算机算法--图算法介绍</h2>
                    <span class="date">Nov 29, 2014</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2014/11/leveldb.html" class="post-list-item">
                    <h2>leveldb原理剖析</h2>
                    <span class="date">Nov 18, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="c/c++">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2014/12/c-open-project.html" class="post-list-item">
                    <h2>值得推荐的C/C++框架和库</h2>
                    <span class="date">Dec 13, 2014</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="android">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2015/08/volley-source-code.html" class="post-list-item">
                    <h2>Volley源码分析</h2>
                    <span class="date">Aug 27, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/05/android-links.html" class="post-list-item">
                    <h2>安卓开发者必备的42个链接</h2>
                    <span class="date">May 19, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/05/define-custom-view.html" class="post-list-item">
                    <h2>Android自定义视图教程</h2>
                    <span class="date">May 17, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/03/android-studio-prefrence.html" class="post-list-item">
                    <h2>Android Studio多渠道打包和代码混淆教程</h2>
                    <span class="date">Mar 18, 2015</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="Gradle">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2015/05/gradle-dependency-management.html" class="post-list-item">
                    <h2>Gradle系列教程之依赖管理</h2>
                    <span class="date">May 5, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/04/gradle-task-management.html" class="post-list-item">
                    <h2>Gradle系列教程之任务管理</h2>
                    <span class="date">Apr 30, 2015</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="lambda">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2015/06/java-lambda-expression.html" class="post-list-item">
                    <h2>Java Lambda简明教程</h2>
                    <span class="date">Jun 3, 2015</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="gradle">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2015/08/dagger-dependency-injection.html" class="post-list-item">
                    <h2>Dagger依赖注入浅析</h2>
                    <span class="date">Aug 13, 2015</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/07/gradle-tasks-guide.html" class="post-list-item">
                    <h2>彻底理解Gradle的任务</h2>
                    <span class="date">Jul 27, 2015</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="Latex">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2015/08/latex-fonts-settings.html" class="post-list-item">
                    <h2>Latex中英文环境设置</h2>
                    <span class="date">Aug 22, 2015</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="Unix/Linux">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2016/02/baidu-spider-forbidden.html" class="post-list-item">
                    <h2>解决百度爬虫无法抓取github pages</h2>
                    <span class="date">Feb 18, 2016</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2016/01/apache-configuration-in-ubuntu.html" class="post-list-item">
                    <h2>Ubuntu下Apache服务器的配置</h2>
                    <span class="date">Jan 20, 2016</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2016/01/tmux-guide.html" class="post-list-item">
                    <h2>终端复用软件之tmux简介</h2>
                    <span class="date">Jan 19, 2016</span>
                  </a>
		</li>
                
              
                
		<li>
                  <a href="/blog/2015/08/linux-zsh.html" class="post-list-item">
                    <h2>Zsh-Linux下最好的Shell简介</h2>
                    <span class="date">Aug 23, 2015</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="Git">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2016/02/git-guide.html" class="post-list-item">
                    <h2>Git操作手册|命令速查表</h2>
                    <span class="date">Feb 20, 2016</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	<div post-cate="hi">
          <ul class="posts">
            
              
                
              
            
              
                
		<li>
                  <a href="/blog/2016/02/hi.html" class="post-list-item">
                    <h2>hi</h2>
                    <span class="date">Feb 22, 2016</span>
                  </a>
		</li>
                
              
            
          </ul>
	</div>
        
	 </div>

</div>


<!-- Blog Comments -->
<div class="media">
  <!-- UY BEGIN 
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2023801"></script>
UY END -->

<!-- 多说评论框 start -->
  <div class="post-comment">
            <span>Comments</span>
	<div class="ds-thread" data-thread-key="/blog/2014/11/java-concurrent-collections" data-title="java同步容器与并发容器" data-url="LippiOuYang.github.io/blog/2014/11/java-concurrent-collections.html">
	</div>
 </div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"lippiouyang"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
 
</div> 
</div>

        </div>

	 <div id="top" data-toggle="tooltip" data-placement="left" title="回到顶部">
	      <a href="javascript:;">
		<div class="arrow"></div>
		<div class="stick"></div>
	      </a>
	    </div>

        <!-- Blog Sidebar Widgets Column -->
        <div class="col-md-4">
          <!-- Blog Search Well -->  
	
                    <div class="shadow-corner-curl hidden-xs">
	  <div class="categories-list-header">站内搜索</div>
<!-- 使用该代码即表示您同意接受 Google 自定义搜索服务条款。 -->
<!-- 有关服务条款，请访问 http://www.google.com/cse/docs/tos.html?hl=zh-CN -->
<form name="cse" id="searchbox_demo" action="/search.html">
  <input type="hidden" name="cref" value="" />
  <input type="hidden" name="ie" value="utf-8" />
  <input type="hidden" name="hl" value="zh-CN" />
  <input name="q" type="text" size="30" />
  <input type="submit" name="sa" value="搜索" /> 
</form>
<script type="text/javascript" src="http://www.google.com/cse/tools/onthefly?form=searchbox_demo&lang=zh-CN"></script>			      
     
            
</div>








          <!-- Blog Categories Well -->
              

    <div class="shadow-corner-curl hidden-xs">
      <div class="categories-list-header">
        Categories
      </div>
      
      <a href="/index.html" class="categories-list-item" cate="All">
        All<span class="my-badge"> 61</span>
      </a>
      
        <a href="javascript:;" class="categories-list-item" cate="java">
          java <span class="my-badge">17</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="c">
          c <span class="my-badge">4</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="programming">
          programming <span class="my-badge">4</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="jekyll">
          jekyll <span class="my-badge">3</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="other">
          other <span class="my-badge">4</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="reprints">
          reprints <span class="my-badge">5</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="Android">
          Android <span class="my-badge">2</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="web">
          web <span class="my-badge">9</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="book">
          book <span class="my-badge">1</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="algorithm">
          algorithm <span class="my-badge">3</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="c/c++">
          c/c++ <span class="my-badge">1</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="android">
          android <span class="my-badge">4</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="Gradle">
          Gradle <span class="my-badge">2</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="lambda">
          lambda <span class="my-badge">1</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="gradle">
          gradle <span class="my-badge">2</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="Latex">
          Latex <span class="my-badge">1</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="Unix/Linux">
          Unix/Linux <span class="my-badge">4</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="Git">
          Git <span class="my-badge">1</span>
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="hi">
          hi <span class="my-badge">1</span>
        </a>
      
    </div>



 
         
              <div class="shadow-corner-curl hidden-xs">
      <div class="categories-list-header">
        热门文章
      </div>

 <ul class="list-unstyled">
      	<li><a href="/blog/2015/03/github-pages-blog.html" class="categories-list-item">利用Github-pages建立个人博客</a></li>	
<li><a href="/blog/2014/07/qualified-programmer-should-read-what-books.html" class="categories-list-item">一个合格的程序员应该读过哪些书</a></li>
<li><a href="/blog/2014/12/c-open-project.html" class="categories-list-item">值得推荐的C/C++框架和库</a></li>
<li><a href="/blog/2014/12/c-code-opt.html" class="categories-list-item">C代码优化小贴士</a></li>	
<li><a href="/blog/2014/06/26-methods-to-improve-java-performance.html" class="categories-list-item">Java编程Tips</a></li>
<li><a href="/blog/2015/04/gradle-task-management.html" class="categories-list-item">Gradle系列教程之任务管理</a></li>	
<li><a href="/blog/2015/05/android-links.html" class="categories-list-item">安卓开发者必备的42个链接</a></li>
<li><a href="/blog/2015/05/gradle-dependency-management.html" class="categories-list-item">Gradle系列教程之依赖管理</a></li>
<li><a href="/blog/2014/10/android-opensource.html" class="categories-list-item">值得推荐的android开源框架</a></li>	 
<li><a href="/blog/2015/07/hibernate-cache-guide.html" class="categories-list-item">Hibernate缓存配置笔记</a></li>	
	 
     </ul>
</div>
 
       
                   <div class="shadow-corner-curl hidden-xs">
      <div class="categories-list-header">
        相关链接
      </div>    
 <ul class="list-unstyled">
              <li>
                <a href="https://github.com/" class="categories-list-item">
                   GitHub 
                </a>
              </li>
<li>
                <a href="http://www.stackoverflow.com/" class="categories-list-item">
                   Stack Overflow 
                </a>
              </li>
<li>
                <a href="http://jekyllrb.com/docs/posts/" class="categories-list-item">
                  Jekyll文档 
                </a>
              </li>
               
               <li>
                <a href="https://news.ycombinator.com/" class="categories-list-item">
                   Hacker News 
                </a>
              </li>        
              
              <li>
                <a href="http://developer.android.com/" class="categories-list-item">
                   Android Developer 
                </a>
              </li>
              
              <li>
                <a href="http://www.ruanyifeng.com/blog/" class="categories-list-item">
                   Ruanyifeng's Blog 
                </a>
              </li>


  <li>
                <a href="http://www.importnew.com/" class="categories-list-item">
                   ImportNew 
                </a>
              </li>
<li>
                <a href="http://guides.codepath.com/android" class="categories-list-item">
                   CodePath Android Cliffnotes 
                </a>
              </li>
<li>
                <a href="http://androidweekly.net/" class="categories-list-item">
                   Androidweekly 	
                </a>
              </li>
<li>
			<a href="http://mvnrepository.com/" class="categories-list-item">
                   Mvnrepository 
                </a>
              </li>
<li>
			<a href="http://www.iteye.com/" class="categories-list-item">
                  Iteye 
                </a>
              </li>
              		
            </ul>

</div>
 

          <!-- Side Widget Well -->
           
        </div>
      </div>



      <!-- /.row -->
      <hr>
      <!-- Footer -->
      <footer>
           <p><small>Designed by <a href="https://github.com/EZLippi">Lippi</a> | Free hosted at <a href="https://github.com/EZLippi/EZLippi.github.io">Github</a> | Copyright 2014 - 2016  
										</p>

	<!--
<div class="container">
    <div class="row">
      <div class="col-md-12">
        <a href="mailto:ouyanglip@gmail.com"><span class="glyphicon glyphicon-envelope"></span> ouyanglip@gmail.com</a>
        <span class="point"> · </span>
        
          
          <a href="https://github.com/LippiOuYang">
            <span class="icon">
              <svg viewBox="0 0 16 16">
                <path fill="#aaa" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            Github
          </a>
          
          
          <span class="point"> · </span>
          <span><a href="/feed.xml">RSS</a></span>
          <span class="point"> · </span>
          <span>Draw my life with code</span>
          <span class="point"> · </span>
          <span>&copy; 2014 LippiOuYang</span>
          <span class="point"> · </span>
          <span>Designed by <a href="https://github.com/LippiOuYang">Lippi</a></span>

      </div>
    </div>
    </div>
	-->
 
              <div style="display:none;"><script src="http://s95.cnzz.com/z_stat.php?id=1254799848&web_id=1254799848" language="JavaScript"></script></div>
 

      </footer>
    </div>
    <!-- /.container -->
  </body>

</html>
