<h4 id="section">桥接模式： 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</h4>

<blockquote>
  <p>常用的场景</p>

  <p>1.当一个对象有多个变化因素的时候，考虑依赖于抽象的实现，而不是具体的实现。如上面例子中手机品牌有2种变化因素，一个是品牌，一个是功能。</p>

  <p>2.当多个变化因素在多个对象间共享时，考虑将这部分变化的部分抽象出来再聚合/合成进来，如上面例子中的通讯录和游戏，其实是可以共享的。</p>

  <p>3.当我们考虑一个对象的多个变化因素可以动态变化的时候，考虑使用桥接模式，如上面例子中的手机品牌是变化的，手机的功能也是变化的，所以将他们分离出来，独立的变化。
缺点：
（1）.客户必须知道选择哪一种类型的实现</p>

  <p>优点：
（1）分离抽象接口及其实现部分。 
（2）桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。
（3）桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都 不需要修改原有系统。
（4）实现细节对客户透明，可以对用户隐藏实现细节。</p>
</blockquote>

<h4 id="section-1">工厂模式：</h4>

<blockquote>
  <p>简单工厂、工厂模式和抽象工厂模式
下面总结一下“工厂系列”设计模式，简单工厂模式只有一份抽象的产品，工厂是具体的；（普通）工厂模式的同样也只有一份抽象的产品，但工厂有抽象的了；抽象工厂模式工厂当然是抽象的，但是它独特的地方在于产品至少有两份是抽象的。</p>
</blockquote>

<h4 id="section-2">建造者模式：</h4>

<blockquote>
  <p>建造者模式包含一个抽象的Builder类，还有它的若干子类——ConcreteBuilder，不用理会UML图上的Product，关键是看Director，Director里面的方法Construct()其实包含了Builder指针或引用的形参，由客户端传入某个ConcreateBuilder对象。Construct(Builder*
builder)的方法大致如下： Construct(Builder* builder) {
         Builder-&gt;BuildPartA();
         Builder-&gt;BuildPartB();
         … } 由多态性可知，客户端传进来的ConcreteBuilder是谁，就调用谁的方法。 原型模式： 当一个类中包含了指针，那么这个类一定要显示规定三个东西：拷贝构造函数，重载”=”操作符以及析构函数。如果程序员使用编译器默认产生的这三个函数，那么得到的对象是原来对象的“浅拷贝”，即只是简单拷贝了指针的值（只复制了地址），没有复制指针指向空间的内容。“浅拷贝”只会保留最近的修改结果，而且在析构时容易出现重复析构的错误。</p>
</blockquote>

<h4 id="section-3">单例模式：</h4>

<blockquote>
  <p>要使一个类只能生成一个对象，就是要限制使用它的构造函数，即将构造函数定义为private或protected的，然后另辟一个公有方法Instance，在这个方法里检查instance（instance是指向本类的一个指针或引用，这在C++语法中是可以的）是否为空指针，若为空指针，则说明是第一次生成对象，那么操作是允许的，instance = new Singleton()，若指针非空，说明在之前已经有一个对象（实例）了，单例模式不允许再次生成实例，因此直接返回之前生成的对象的地址。 将instance定义成static变量，就更符合“单例”模式了，因为static变量只有一份，它属于这个类，不属于某个对象。相应的Instance()方法应该也定义成static的，用Singleton::Instance()来调用。注意这里的static方法和变量是必须的，如果函数不是static，则要事先生成对象才能调用Instance，就破坏了“单例”的思想了，如果变量不是static，那么静态函数Instance又不能引用非static变量。</p>
</blockquote>

<p>未完待续。。。</p>
